[{"content":" SpringBoot Web入门 Spring 官网：spring.io\nSpring发展到今天已经形成了一种开发生态圈，Spring提供了若干个子项目，每个项目用于完成特定的功能，他们最底层都是基于Spring Framework\nSpring Boot简化配置，可以快速开发，对比起Spring Framework\nSpringBoot入门程序 创建一个项目：\n项目结构：\n新建的文件可以放在zzzyj里边\n入门程序：\n@RestController //标识当前类是一个请求处理类 public class HelloController { @RequestMapping (\u0026#34;/hello\u0026#34;)//标识请求路径 public String hello(String name){ System.out.println(\u0026#34;name:\u0026#34;+name); return \u0026#34;hello:\u0026#34;+name+\u0026#34;~\u0026#34;; } } “脚手架”（Scaffold）通常指的是一个自动生成的项目结构和基础代码框架。它帮助开发者快速搭建项目的初始结构，减少重复性的基础工作。\n连接不上的解决方法\n入门程序解析 为什么main方法能将程序启动起来\n运行起来tomcat\nhttp协议 概念：Hyper Text Transfer Protocol，超文本传输协议，规定了浏览器和服务器之间数据传输的规则。\n特点：\n基于TCP协议：面向连接，安全 基于请求-响应模型的：一次请求对应一次晌应 HTTP协议是无状态的协议：对于事务处理没有记忆能力。每次请求-响应都是独立的 • 缺点：多次请求间不能共享数据\n• 优点：速度快\nhttp请求协议 请求方式-GET：请求参数在请求行中，没有请求体，如：/brand/findAlL?name=OPPO\u0026amp;status=1。GET请求大小在浏览器中是有限制的。\n请求方式-POST：请求参数在请求体中，POST请求大小是没有限制的。\n请求头和请求体之间有一个空行隔开\nGET方式一般没有请求体，POST传递的数据在请求体中\nHost 请求的主机名 User-Agent 浏览器版本，例如Chrome浏览器的标识类似Mozilla/5.0 \u0026hellip; Chrome/79，IE浏览器的标识类似****Mozilla/5.0 (Windows NT \u0026hellip;) like Gecko Accept 表示浏览器能接收的资源类型，如****text/***，****image/或者/***表示所有； Accept-Language 表示浏览器偏好的语言，服务器可以据此返回不同语言的网页； Accept-Encoding 表示浏览器可以支持的压缩类型，例如gzip, deflate****等。 Content-Type 请求主体的数据类型。 Content-Length 请求主体的大小（单位：字节）。 请求数据的获取 Web服务器（Tomcat）对HTTP协议的请求数据进行解析，并进行了封装（HttpServletRequest），在调用Controller方法的时候传递给了该方法。这样，就使得程序员不必直接对协议进行操作，让web开发更加便捷。\n@RestController public class RequestController { @RequestMapping(\u0026#34;/request\u0026#34;) public String reques(HttpServletRequest request){ // 获取请求方法 String method = request.getMethod(); System.out.println(\u0026#34;method:\u0026#34;+method); // 获取请求参数 String name1 = request.getParameter(\u0026#34;name\u0026#34;); String name2 = request.getParameter(\u0026#34;age\u0026#34;); System.out.println(\u0026#34;name:\u0026#34;+name1); System.out.println(\u0026#34;age:\u0026#34;+name2); // 获取请求路径url和uri String url = request.getRequestURL().toString(); // 这是一个完整的路径 String uri = request.getRequestURI(); // 这是后边的相对路径 System.out.println(\u0026#34;url:\u0026#34;+url); System.out.println(\u0026#34;uri:\u0026#34;+uri); // 获取请求体 String header = request.getHeader(\u0026#34;User-Agent\u0026#34;); System.out.println(\u0026#34;header = \u0026#34; + header); return \u0026#34;ok\u0026#34;; } } http响应数据 响应码：\n1xx 响应中-临时状态码，表示请求已经接收，告诉客户端应该继续请求或者如果它已经完成则忽略它。 2xx 成功-表示请求已经被成功接收，处理已完成。 3xx 重定向-重定向到其他地方；让客户端再发起一次请求以完成整个处理。 4xx 客户端错误-处理发生错误，责任在客户端。如: 请求了不存在的资源、客户端未被授权、禁止访问等。 5xx 服务器错误-处理发生错误，责任在服务端。如：程序抛出异常等。 响应头：\nContent-Type 表示该响应内容的类型，例如text/html，application/json。 Content-Length 表示该响应内容的长度（字节数）。 Content-Encoding 表示该响应压缩算法，例如gzip。 Cache-Control 指示客户端应如何缓存，例如max-age=300表示可以最多缓存300秒。 Set-Cookie 告诉浏览器为当前页面所在的域设置cookie。 响应数据的设置 @RestController public class ResponseController { @RequestMapping(\u0026#34;/response\u0026#34;) public void response(HttpServletResponse response) throws IOException { // 设置响应状态码 response.setStatus(401); // 设置响应头 response.setHeader(\u0026#34;zzzzyj\u0026#34;,\u0026#34;哈哈哈\u0026#34;); // 设置响应体 response.getWriter().write(\u0026#34;\u0026lt;h1\u0026gt;hello,response\u0026lt;/h1\u0026gt;\u0026#34;); } @RequestMapping(\u0026#34;/response2\u0026#34;) public ResponseEntity\u0026lt;String\u0026gt; response2(){ // spring提供的 return ResponseEntity.status(401) .header(\u0026#34;zzzzyj\u0026#34;,\u0026#34;xixixi\u0026#34;) .body(\u0026#34;\u0026lt;h1\u0026gt;hello,response\u0026lt;/h1\u0026gt;\u0026#34;); } } 响应状态码 和 响应头如果没有特殊要求的话，通常不手动设定。服务器会根据请求处理的逻辑，自动设置响应状态码和响应头。\nSpringBoot案例 构建项目的时候，需要勾选上lombok依赖，这个就是之前在javase中学习的@Data注解，可以直接有getset和构造器方法\n返回的数据之所以可以是json格式，是因为加了注解@RestController，他的底层还有一个注解@ResponseBody 作用：将controller返回值直接作为响应体的数据直接响应；返回值是对象/集合-\u0026gt;json-\u0026gt;再响应\n@RestController public class UserController { // 当访问list的时候，就会读取txt文件返回数据，加载到html页面中 @RequestMapping(\u0026#34;/list\u0026#34;) public List\u0026lt;User\u0026gt; list(){ // 1、加载并读取文件 InputStream in = this.getClass().getClassLoader().getResourceAsStream(\u0026#34;user.txt\u0026#34;); ArrayList\u0026lt;String\u0026gt; lines = IoUtil.readLines(in, StandardCharsets.UTF_8, new ArrayList\u0026lt;\u0026gt;()); // 2、解析数据，封装成对象 --\u0026gt;集合 List\u0026lt;User\u0026gt; userList = lines.stream().map(line -\u0026gt; { String[] parts = line.split(\u0026#34;,\u0026#34;); Integer id = Integer.parseInt(parts[0]); String username = parts[1]; String password = parts[2]; String name = parts[3]; Integer age = Integer.parseInt(parts[4]); LocalDateTime updateTime = LocalDateTime.parse(parts[5], DateTimeFormatter.ofPattern(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;)); return new User(id, username, password, name, age, updateTime); // 流的终结方法，打回集合 }).collect(Collectors.toList()); // 3、响应数据 return userList; } } 分层解耦 三层架构 单一职责原则\ncontroller：控制层，接收前端发送的请求，对请求进行处理，并响应数据。\nservice：业务逻辑层，处理具体的业务逻辑。\ndao：数据访问层（Data Access Object）（持久层），负责数据访问操作，包括数据的增、删、改、查。\n转换后的代码\n分层解耦 耦合：衡量软件中各个层/各个模块的依赖关联程度。\n内聚：软件中各个功能模块内部的功能联系。\n软件设计原则：高内聚低耦合。\n因为用new创建了对象，所以是高耦合\n控制反转： Inversion Of Control，简称IOC。对象的创建控制权由程序自身转移到外部（容器），这种思想称为控制反转。\n依赖注入：Dependency Injection，简称DI。容器为应用程序提供运行时，所依赖的资源，称之为依赖注入。\nBean对象：IOC容器中创建、管理的对象，称之为Bean。\nIOC\u0026amp;DI入门 1、将Dao 及 Service层的实现类，交给IOC容器管理。\n2、为Controller 及 Service注入运行时所依赖的对象。\nIOC详解 要把某个对象交给IOC容器管理，需要在对应类中加上下列注解之一：\n注解 说明 位置 @Component 声明bean的基础注解 不属于以下三类时，用此注解 @Controller @Component的衍生注解 标注在控制层类上(@RestController中包含了@Controller) @Service @Component的衍生注解 标注在业务层类上 @Repository @Component的衍生注解 标注在数据访问层类上（由于与mybatis整合，用的少） 不指定Bean的名字默认是类名首字母小写\n使用以上四个注解都可以声明bean，但是在springboot集成web开发中，声明控制器bean只能用@Controller。\n前面声明bean的四大注解，要想生效，还需要被组件扫描注解@ComponentScan扫描。\n该注解虽然没有显式配置，但是实际上已经包含在了启动类声明注解@SpringBootAppljcatjon 中，默认扫描的范围是启动类所在包及其子包。\nDI详解 \u0026lt;font style=\u0026quot;color:rgb(222,120,2);\u0026quot;\u0026gt;@Autowired\u0026lt;/font\u0026gt;注解，默认是按照类型进行自动装配的（去IOC容器中找某个类型的对象，然后完成注入操作）\n入门程序举例：在EmpController运行的时候，就要到IOC容器当中去查找EmpService这个类型的对象，而我们的IOC容器中刚好有一个EmpService这个类型的对象，所以就找到了这个类型的对象完成注入操作。\n三种注解形式\n方式1：属性注入\n@RestController public class UserController { @Autowired private UserService userService; //...... } 优点：代码简洁、方便快速开发。\n缺点：隐藏了类之间的依赖关系、可能会破坏类的封装性。\n方式一破坏了类的封装性，因为封装性要求私有成员变量却没有提供get和set方法\n方式2：构造器注入\n@RestController public class UserController { //方式二: 构造器注入 private final UserService userService; @Autowired //如果当前类中只存在一个构造函数, @Autowired可以省略 public UserController(UserService userService) { this.userService = userService; } } 优点：能清晰地看到类的依赖关系、提高了代码的安全性。\n缺点：代码繁琐、如果构造参数过多，可能会导致构造函数臃肿。\n注意：如果只有一个构造函数，@Autowired注解可以省略。\n方式3：setter注入\n/** * 用户信息Controller */ @RestController public class UserController { //方式三: setter注入 private UserService userService; @Autowired public void setUserService(UserService userService) { this.userService = userService; } } 优点：保持了类的封装性，依赖关系更清晰。\n缺点：需要额外编写setter方法，增加了代码量。\n一般使用的比较多的是方式1和方式2\n@Autowired注解，默认是按照类型进行注入的。\n如果存在多个相同类型的bean，将会报出如下错误：\n解决方式1：使用@Primary注解\n注意注释的地方是在类的上边\n@Primary @Service public class UserServiceImpl implements UserService { } 解决方式2：使用@Qualifier注解\n指定当前要注入的bean对象。 在@Qualifier的value属性中，指定注入的bean的名称。 @Qualifier注解不能单独使用，必须配合@Autowired使用。\n@RestController public class UserController { @Qualifier(\u0026#34;userServiceImpl\u0026#34;) @Autowired private UserService userService; 解决方式3：使用@Resource注解\n是按照bean的名称进行注入。通过name属性指定要注入的bean的名称。\n@RestController public class UserController { @Resource(name = \u0026#34;userServiceImpl\u0026#34;) private UserService userService; @Resource 与 @Autowired区别？ • @Autowired是Spring框架提供的注解，而@Resource是JavaEE规范提供的\n• @Autowired默认是按照类型注入，而@Resource默认是按照名称注入\n","permalink":"https://wqnm1gb.github.io/posts/day04-web%E5%9F%BA%E7%A1%80/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"Day04%20Web%e5%9f%ba%e7%a1%80.assets/1731977559201-73e5a329-2595-4cae-bff1-05bfe1edee42.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003ch1 id=\"springboot-web入门\"\u003eSpringBoot Web入门\u003c/h1\u003e\n\u003ch2 id=\"spring\"\u003eSpring\u003c/h2\u003e\n\u003cp\u003e\u003c!-- raw HTML omitted --\u003e官网：\u003c!-- raw HTML omitted --\u003e\u003ca href=\"https://spring.io/\"\u003e\u003c!-- raw HTML omitted --\u003espring.io\u003c!-- raw HTML omitted --\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003c!-- raw HTML omitted --\u003eSpring发展到今天已经形成了一种开发生态圈，Spring提供了若干个子项目，每个项目用于完成特定的功能，他们最底层都是基于Spring Framework\u003c!-- raw HTML omitted --\u003e\u003c/p\u003e","title":"Day04 Web基础"},{"content":"Maven Maven是一款用于管理和构建Java项目的工具，是apache旗下的一个开源项目。\nMaven的作用 方便的依赖管理 方便快捷的管理项目依赖的资源（jar包）\n![](/images/Day03 Web后端基础.assets/1731494326881-f21bc48f-bd55-4a21-b0eb-612dff7aed76.png)\n标准的项目构建流程 标准化的跨平台（Linux、Windows、MacOs）的自动化项目构建方式\n统一结构的项目 提供标准、统一的项目结构\n仓库：用于存储资源，管理各种jar包。\n• 本地仓库：自己计算机上的一个目录。\n• 中央仓库：由Maven团队维护的全球唯一的。仓库地址：https://repo1.maven.org/maven2/\n• 远程仓库（私服）：一般由公司团队搭建的私有仓库。\n查找的顺序是\n1、本地仓库\n2、远程仓库（私服）\n3、中央仓库\nMaven坐标 什么是坐标？ Maven 中的坐标是资源（jar）的唯一标识，通过该坐标可以唯一定位资源位置\n使用坐标来定义项目或引入项目中需要的依赖\nMaven 坐标主要组成 groupId：定义当前Maven项目隶属组织名称（通常是域名反写，例如：com.itheima）\nartifactId：定义当前Maven项目名称（通常是模块名称，例如：order-service、goods-service）\nversion：定义当前项目版本号\nSNAPSHOT：功能不稳定、尚处于开发中的版本，即快照版本 RELEASE：功能趋于稳定、当前更新停止，可以用于发行的版本 导入Maven项目 方式1：\n方式2：\n建议将要导入的maven项目复制到你的项目目录下\n建议选择maven项目的pom.xml文件进行导入\n选择pom.xml文件导入，为了更方便的聚合（Maven高级）\nMaven依赖管理 依赖配置 依赖：指当前项目运行所需要的jar包，一个项目中可以引入多个依赖。\n配置：\n在 pom.xmL 中编写 标签\n在 标签中 使用 引入坐标\n3．定义坐标的 groupId,artifactId,version\n4．点击刷新按钮，引入最新加入的坐标\n如果不知道依赖的坐标信息，可以到 https://mvnrepository.com/中搜索。\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;6.1.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 排除依赖 排除依赖：指主动断开依赖的资源，被排除的资源无需指定版本。\n这个exclusions需要在dependecy里边\n![](/images/Day03 Web后端基础.assets/1731641715744-3b183973-818b-49cd-bcee-5a06cad06e70.png)\n想要有提示词，都需要先打一个\u0026laquo;/font\u0026gt;\n注意事项\n• 一旦依赖配置变更了，记得重新加载\n• 引入的依赖本地仓库不存在，记得联网\nMaven的生命周期 每套生命周期包含一些阶段（phase），阶段是有顺序的，后面的阶段依赖于前面的阶段。\n重点关注的几个阶段：\nclean：移除上一次构建生成的文件\ncompile：编译项目源代码\ntest：使用合适的单元测试框架运行测试（junit）\npackage：将编译后的文件打包，如：jar、war等\ninstall：安装项目到本地仓库\n在同一套生命周期中，当运行后面的阶段时，前面的阶段都会运行。（注意同一套）\n执行生命周期的两种方式：\n1、在idea中，右侧的maven工具栏，选中对应的生命周期，双击执行。\n2、在命令行中，通过命令执行\n只有点击install后，项目才会安装到Maven的本地仓库中，其他的文件都是生成在项目路径中\n测试 测试：是一种用来促进鉴定软件的正确性、完整性、安全性和质量的过程。\n阶段划分：单元测试、集成测试、系统测试、验收测试。\n测试方法：白盒测试，黑盒测试，灰盒测试\n单元测试 单元测试：就是针对最小的功能单元（方法），编写测试代码对其正确性进行测试。\nJUnit：最流行的Java测试框架之一，提供了一些功能，方便程序进行单元测试（第三方公司提供）。\nmain方法测试 1、测试代码与源代码未分开，难维护\n2、一个方法测试失败，影响后面方法\n3、无法自动化测试，得到测试报告\nJUnit单元测试 1、测试代码与源代码分开，便于维护\n2、可根据需要进行自动化测试\n3、可自动分析测试结果，产出测试报告\n测试方法：\n在pom.xml中，引入JUnit的依赖。 在test/java目录下，创建测试类，并编写对应的测试方法，并在方法上声明@Test注解。 运行单元测试（测试通过：绿色；测试失败：红色）。 JUnit单元测试类名命名规范：XxxxxTest【规范】。JUnit单元测试的方法，必须声明为 public void【规定】，可以有形参吗，可以的，@ParameterizedTest + @ValueSource\n断言 JUnit提供了一些辅助方法，用来帮我们确定被测试的方法是否按照预期的效果正常工作，这种方式称为断言。\n断言方法 描述 Assertions.assertEquals(Object exp, Object act, String msg) 检查两个值是否相等，不相等就报错。 Assertions.assertNotEquals(Object unexp, Object act, String msg) 检查两个值是否不相等，相等就报错。 Assertions.assertNull(Object act, String msg) 检查对象是否为null，不为null，就报错。 Assertions.assertNotNull(Object act, String msg) 检查对象是否不为null，为null，就报错。 Assertions.assertTrue(boolean condition, String msg) 检查条件是否为true，不为true，就报错。 Assertions.assertFalse(boolean condition, String msg) 检查条件是否为false，不为false，就报错。 Assertions. assertThrows(Class expType, Executable exec, String msg) 检查程序运行抛出的异常，是否符合预期。 上述方法形参中的最后一个参数 msg，表示错误提示信息，可以不指定（有对应的重载方法）。\nJUnit的常见注解 @ValueSource这个注解里边可以指定参数，传递到测试函数里边\n@DisplayName可以为测试命名解释\n@BeforAll只会运行一次\n注解 说明 备注 @Test 测试类中的方法用它修饰才能成为测试方法，才能启动执行 单元测试 @ParameterizedTest 参数化测试的注解 (可以让单个测试运行多次，每次运行时仅参数不同) 用了该注解，就不需要@Test注解了 @ValueSource 参数化测试的参数来源，赋予测试方法参数 与参数化测试注解配合使用 @DisplayName 指定测试类、测试方法显示的名称 （默认为类名、方法名） @BeforeEach 用来修饰一个实例方法，该方法会在每一个测试方法执行之前执行一次。 初始化资源(准备工作) @AfterEach 用来修饰一个实例方法，该方法会在每一个测试方法执行之后执行一次。 释放资源(清理工作) @BeforeAll 用来修饰一个静态方法，该方法会在所有测试方法之前只执行一次。 初始化资源(准备工作) @AfterAll 用来修饰一个静态方法，该方法会在所有测试方法之后只执行一次。 释放资源(清理工作) @DisplayName(\u0026#34;用户性别测试\u0026#34;) @ParameterizedTest @ValueSource(strings = {\u0026#34;110101200011011234\u0026#34;,\u0026#34;110101200011011214\u0026#34;,\u0026#34;110101200011011254\u0026#34;}) public void testGetGender2(String idCard){ UserService userService = new UserService(); String gender = userService.getGender(idCard); Assertions.assertEquals(\u0026#34;男\u0026#34;, gender); } 测试覆盖率\nClass 类覆盖率、Method 方法覆盖率、Line 代码覆盖率\n可以选定想要生成测试的函数，用AI一键生成\n依赖范围 依赖的jar包，默认情况下，可以在任何地方使用。可以通过 ..设置其作用范围。\n作用范围：\n＞ 主程序范围有效。（main文件夹范围内）\n＞ 测试程序范围有效。（test文件夹范围内）\n＞ 是否参与打包运行。（package指令范围内）\nscope****值 主程序 测试程序 打包（运行） 范例 compile（默认） Y Y Y log4j test - Y - junit provided Y Y - servlet-api runtime - Y Y jdbc驱动 常见问题的解决方案 ","permalink":"https://wqnm1gb.github.io/posts/day03-web%E5%90%8E%E7%AB%AF%E5%9F%BA%E7%A1%80/","summary":"\u003ch1 id=\"maven\"\u003eMaven\u003c/h1\u003e\n\u003cp\u003eMaven是一款用于\u003c!-- raw HTML omitted --\u003e管理和构建Java项目\u003c!-- raw HTML omitted --\u003e的工具，是apache旗下的一个开源项目。\u003c/p\u003e\n\u003ch2 id=\"maven的作用\"\u003eMaven的作用\u003c/h2\u003e\n\u003ch3 id=\"方便的依赖管理\"\u003e方便的依赖管理\u003c/h3\u003e\n\u003cp\u003e方便快捷的管理项目依赖的资源（jar包）\u003c/p\u003e","title":"Day03 Web后端基础"},{"content":"JavaScript Javascript（简称：Js）是一门跨平台、面向对象的脚本语言，是用来控制网页行为，实现页面的交互效果。\nJavascript 和 Java 是完全不同的语言，不论是概念还是设计。但是基础语法类似。\n组成：\n• ECMAScript： 规定了JS基础语法核心知识，包括变量、数据类型、流程控制、函数、对象等。\n• BOM：浏览器对象模型，用于操作浏览器本身，如：页面弹窗、地址栏操作、关闭窗口等。\n• DOM：文档对象模型，用于操作HTML文档，如：改变标签内的内容、改变标签内字体样式等。\nJS的引入方式 内部脚本：将JS代码定义在HTML页面中 JavaScript代码必须位于 标签之间 在HTML文档中，可以在任意地方，放置任意数量的 一般会把脚本置于 元素的底部，可改善显示速度，原因如下： 一般会把script标签放在body的底部，因为html标签是从上到下渲染的，放在底部可以先渲染html语句，改善显示速度，同时如果js中有对html里的标签进行操作，标签还没加载出来的话，就会报错\n外部脚本：将 JS代码定义在外部 JS文件中，然后引入到HTML页面中 变量和常量 **JS中用 let 关键字来声明变量（****弱类型语言，变量可以存放不同类型**的值）\n变量名需要遵循如下规则：\n• 只能用 字母、数字、下划线（_）、美元符号（$）组成，且数字不能开头\n• 变量名严格区分大小写，如 name 和 Name 是不同的变量\n• 不能使用关键字，如：let、var、if、for等\nJS中用 const 关键字来声明常量。\n一旦声明，常量的值就不能改变（不可以重新赋值）\n在早期的js中，声明变量还可以使用var，但是并不严谨（不推荐）\n输出语句：\nwindow.alert（） ：弹出警告框（使用频次较高） console.log（）：写入浏览器控制台（使用频次较高） document.write（）：向HTML的body内输出内容 数据类型 JavaScript的数据类型分为：基本数据类型和引用数据类型（对象）。\n基本数据类型：\nnumber：数字（整数、小数、NaN（Not a Number）） boolean：布尔，true,false null：对象为空，Javascript是大小写敏感的，因此null、NuLL、NULL是完全不同的 undefined：当声明的变量未初始化时，该变量的默认值是 undefined string：字符串，单引号、双引号、反引号皆可，推荐使用单引号 使用 typeof 运算符可以获取数据类型\n模板字符串语法：\n•``（反引号，英文输入模式下按键盘的tab键上方波浪线~那个键）\n• 内容拼接变量时，使用$｛｝包住变量\n\u0026lt;script\u0026gt; let name = \u0026#39;Tom\u0026#39;; let age = 18; console.log(\u0026#39;大家好, 我是新入职的\u0026#39; + name + \u0026#39;, 今年\u0026#39; + age + \u0026#39;岁了, 请多多关照\u0026#39;); console.log(`大家好, 我是新入职的${name}, 今年${age}岁了, 请多多关照`); \u0026lt;/script\u0026gt; 函数 介绍：函数（ function ）是被设计用来执行特定任务的代码块，方便程序的封装复用。\n定义：JavaScript中的函数通过function关键字进行定义，语法为：\nfunction functionName(参数1, 参数2 ...){ //要执行的代码 } 由于JS是弱类型语言，形参、返回值都不需要指定类型。在调用函数时，实参个数与形参个数可以不一致，但是建议一致。\n匿名函数 函数表达式：\nlet add = function(a, b){ return a + b; } 箭头函数：\nlet add = (a, b) =\u0026gt; { return a + b; } 匿名函数定义后，可以通过变量名直接调用\nlet result = add(10,20); alert(result); 自定义对象 定义格式\nlet 对象名 = { 属性名1: 属性值1, 属性名2: 属性值2, 属性名3: 属性值3, 方法名: function (形参列表) {} } 例子：\nlet user = { name: \u0026#39;Tom\u0026#39;, age: 20, gender: \u0026#39;男\u0026#39;, sing: function () { alert(this.name+\u0026#39;唱着最炫的民族风\u0026#39;) } } 里边的方法可以简化成：\nlet user = { name: \u0026#39;Tom\u0026#39;, age: 20, gender: \u0026#39;男\u0026#39;, sing() { alert(this.name+\u0026#39;唱着最炫的民族风\u0026#39;) } } 调用格式\n对象名.属性名; 对象名.方法名(); console.log(user.name); user.sing(); 注意：在定义对象中的方法时，尽量不要使用箭头函数（this），因为在箭头函数里边，this会指向当前对象的父级对象 JSON 概念：Javascript Object Notation,Javascript对象标记法（JS对象标记法书写的文本）。\n由于其语法简单，层次结构鲜明，现多用于作为数据载体，在网络中进行数据传输。\nJSON.parse ：将json字符串转为js对象\nJSON.stringify：将js对象转为json字符串\nDOM 概念：Document Object Model，文档对象模型。\n将标记语言的各个组成部分封装对应的对象：\n• Document ： 整个文档对象\n• Element：元素对象\n• Attribute：属性对象\n• Text：文本对象\n• Comment： 注释对象\nJavaScript通过DOM，就能够对HTML进行操作：\n• 改变 HTML 元素的内容\n• 改变 HTML 元素的样式（CSS）\n• 对 HTML DOM 事件作出反应\n• 添加和删除 HTML 元素\nDOM操作 DOM操作核心思根：将网页中所有的元素当做对象来处理。（标签的所有属性在该对象上都可以找到）\nDOM是：文档对象模型，JS提供的专门用来操作网页内容的\n操作步骤\n• 获取要操作的DOM元素对象\n• 操作DOM对象的属性或方法（查文档或AI）\n获取DOM对象\n• 根据CSS选择器来获取DOM元素，获取匹配到的第一个元素：document.querySelector(\u0026lsquo;选择器\u0026rsquo;)\n#sid（id选择器） .txt（类选择器） span（标签选择器）\n• 根据CSS选择器来获取DOM元素，获取匹配到的所有元素：document.querySelectorALL（\u0026lsquo;选择器\u0026rsquo;）\n注意：得到的是一个NodeList节点集合，是一个伪数组（有长度、有索引的数组）\n事件监听 事件：HTML事件是发生在HTML元素上的“事情”。比如：\n• 按钮被点击\n• 鼠标移动到元素上\n• 按下键盘按键\n事件监听：JavaScript可以在事件触发时，就立即调用一个函数做出响应，也称为事件绑定或注册事件。\n语法：事件源.addEventListener（\u0026lsquo;事件类型\u0026rsquo;，事件触发执行的函数）；\n事件监听三要素\n事件源：哪个dom元素触发了事件，要获取dom元素 事件类型：用什么方式触发，比如：鼠标单击 click 事件触发执行的函数：要做什么事 \u0026lt;input id=\u0026#34;btn\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;点我一下试试2\u0026#34;\u0026gt; \u0026lt;script\u0026gt; document.querySelector(\u0026#39;#btn\u0026#39;).addEventListener(\u0026#39;click\u0026#39;,()=\u0026gt;{ alert(\u0026#39;试试就试试\u0026#39;); }) \u0026lt;/script\u0026gt; 早期版本写法（了解）：事件源.on事件= function（）｛\u0026hellip;｝\n\u0026lt;input id=\u0026#34;btn\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;点我一下试试2\u0026#34;\u0026gt; \u0026lt;script\u0026gt; document.querySelector(\u0026#39;#btn\u0026#39;).onclick = function () { alert(\u0026#39;试试就试试\u0026#39;); } \u0026lt;/script\u0026gt; 区别：on方式会被覆盖，addEventListener方式可以绑定多次，拥有更多特性，推荐使用\n事件源.addEventListener（\u0026lsquo;事件类型\u0026rsquo;，要执行的函数）\n常见事件 鼠标事件\nclick：鼠标点击\nmouseenter： 鼠标移入\nmouseleave：鼠标移出\n键盘事件\nkeydown：键盘按下触发\nkeyup：键盘抬起触发\n焦点事件\nfocus：获得焦点触发\nblur：失去焦点触发\n表达事件\ninput： 用户输入时触发\nsubmit： 表单提交时触发\nJS优化-模块化设计 \u0026lt;script src=\u0026#34;./js/eventDemo.js\u0026#34; type=\u0026#34;module\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; import { printLog } from \u0026#34;./utls.js\u0026#34;; //click: 鼠标点击事件 document.querySelector(\u0026#39;#b2\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { printLog(\u0026#34;我被点击了...\u0026#34;); }) //mouseenter: 鼠标移入 document.querySelector(\u0026#39;#last\u0026#39;).addEventListener(\u0026#39;mouseenter\u0026#39;, () =\u0026gt; { printLog(\u0026#34;鼠标移入了...\u0026#34;); }) export function printLog(msg){ console.log(msg); } Vue基础入门 Vue是一款用于构建用户界面的渐进式的JavaScript框架。\n构建用户界面：把数据变成用户能看得懂的形式进行展示\n渐进式：指的是我们使用Vue框架呢，我们不需要把所有的组件、语法全部学习完毕才可以使用Vue。 而是，我们学习一点就可以使用一点了\n框架：就是一套完整的项目解决方案，用于快速构建项目。\n优点：大大提升前端项目的开发效率。\n缺点：需要理解记忆框架的使用规则。（参照官网）\n准备\n• 引入Vue模块（官方提供）\n• 创建Vue程序的应用实例，控制视图的元素\n• 准备元素（div），被Vue控制\n数据驱动视图\n• 准备数据\n• 通过插值表达式渲染页面\n\u0026lt;body\u0026gt; \u0026lt;div id = \u0026#34;app\u0026#34;\u0026gt; 用插值表达式来渲染页面 \u0026lt;h1\u0026gt;{{message}}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; // 相当于引用了一个createApp这个函数，mount指定接管的区域 // data方法的返回值就是在vue中定义的数据 import { createApp, ref } from \u0026#39;https://unpkg.com/vue@3/dist/vue.esm-browser.js\u0026#39;; createApp({ data() { return { message: \u0026#39;Hello Vue!\u0026#39; } } }).mount(\u0026#39;#app\u0026#39;) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 在vs中 []括起来的是数组，{}括起来的是对象\n差值表达式不能写在标签的内部\nv-for 作用：列表渲染，遍历容器的元素或者对象的属性\n语法：\n\u0026lt;tr v-for=\u0026#34;(item,index) in items\u0026#34; :key=\u0026#34;item.id\u0026#34;\u0026gt; {{item}}\u0026lt;/tr\u0026gt; 参数说明：\n• items 为遍历的数组\n• item 为遍历出来的元素\n• index 为索引/下标，从0开始；可以省略，省略index语法：v-for=\u0026ldquo;item in items\nkey：\n作用：给元素添加的唯一标识，便于vue进行列表项的正确排序复用，提升渲染性能\n• 推荐使用id作为key（唯一），不推荐使用index作为key（会变化，不对应）\n遍历的数组，必须在data中定义；要想让哪个标签循环展示多次，就在哪个标签上使用 v-for 指令\nv-bind 作用：动态为HTML标签绑定属性值，如设置href，src，style样式等\n语法：v-bind：属性名=\u0026ldquo;属性值\u0026rdquo;\n\u0026lt;img v-bind:src=\u0026#34;item.image\u0026#34; width=\u0026#34;30px\u0026#34;\u0026gt; 简化：:属性名=\u0026ldquo;属性值\u0026rdquo;\n\u0026lt;img :src=\u0026#34;item.image\u0026#34; width=\u0026#34;30px\u0026#34;\u0026gt; 动态的为标签的属性绑定值，不能使用插值表达式，得使用 v-bind 指令。且绑定的数据，必须在data中定义。\nv-if \u0026amp; v-show 作用：这两个指令都是用来控制元素的显示与隐藏\nv-if • 语法：v-if=\u0026ldquo;表达式\u0026rdquo;，表达式值为 true，显示；false，隐藏 作用在标签上\n• 原理：基于条件判断，来控制创建或移除元素节点（条件渲染）\n• 场景：要么显示，要么不显示，不频繁切换的场景\n• 其它：可以配合 v-else-if / v-else 进行链式调用条件判断\nv-else-if必须出现在v-if之后，可以出现多个；v-else 必须出现在v-if/v-else-if之后。\nv-show • 语法：v-show=\u0026ldquo;表达式\u0026rdquo;，表达式值为 true，显示；false，隐藏\n• 原理：基于CSS样式display来控制显示与隐藏\n• 场景：频繁切换显示隐藏的场景\nv-show的表达式不论是真是假，都会渲染出来，但是底层是通过css的样式来控制显示还是隐藏\nvue的指令需要作用在标签中，类似于标签中的属性\nv-model 作用：在表单元素上使用，双向数据绑定。可以方便的 获取 或 设置 表单项数据\n语法：v-model=\u0026ldquo;变量名\u0026rdquo;\nv-model 中绑定的变量，必须在data中定义。\n双向数据绑定，就是页面和数据模型之间的绑定，数据和页面的展示都会改变\nv-on 作用：为html标签绑定事件（添加事件监听）\n语法：\n• v-on：事件名=\u0026ldquo;方法名\u0026rdquo;\n• 简写为@事件名=\u0026rdquo;..\u0026quot;\nmethod是与data平级的关系\nmethods函数中的this指向Vue实例，可以通过this获取到data中定义的数据。\nAjax 介绍：Asynchronous Javascript And XML，异步的javascript和XML。\n作用：\n•数据交换：通过Ajax可以给服务器发送请求，并获取服务器响应的数据。\n•异步交互：可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术，如：搜索联想、用户名是否可用的校验等等。\nXML：（英语：Extensible Markup Language） 可扩展标记语言，本质是一种数据格式，可以用来存储复杂的数据结构。\nAxios 介绍：Axios 对原生的Ajax进行了封装，简化书写，快速开发。\n官网：https://www.axios-http.cn\n步骤：\n• 引入Axios的js文件（参照官网）\n• 使用Axios发送请求，并获取响应结果\n为了方便起见，Axios已经为所有支持的请求方法提供了别名\n格式：axios.请求方式（url ［，data ［， config］］）\nasync \u0026amp; await 可以通过async、await可以让异步变为同步操作。async就是来声明一个异步方法，await是用来等待异步任务执行。\nawait关键字只在async函数内有效，await关键字取代then函数，等待获取到请求成功的结果值。\nVue的生命周期 生命周期：指一个对象从创建到销毁的整个过程。\n生命周期的八个阶段：每触发一个生命周期事件，会自动执行一个生命周期方法（钩子）。\n状态 阶段周期 beforeCreate 创建前 created 创建后 beforeMount 载入前 mounted 挂载完成 beforeUpdate 数据更新前 updated 数据更新后 beforeUnmount 组件销毁前 unmounted 组件销毁后 \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import { createApp } from \u0026#39;https://.../vue.esm-browser.js\u0026#39; const app = createApp({ data() { return { message: \u0026#34;Hello Vue\u0026#34; } },\u000b//生命周期-钩子函数 mounted mounted() { console.log(\u0026#39;Vue挂载完毕, 发送请求获取数据 ...\u0026#39;); } }).mount(\u0026#34;#app\u0026#34;); \u0026lt;/script\u0026gt; ","permalink":"https://wqnm1gb.github.io/posts/day02-jsvueajax/","summary":"\u003ch1 id=\"javascript\"\u003eJavaScript\u003c/h1\u003e\n\u003cp\u003eJavascript（简称：Js）是一门跨平台、\u003c!-- raw HTML omitted --\u003e面向对象\u003c!-- raw HTML omitted --\u003e的脚本语言，是用来控制网页行为，实现页面的交互效果。\u003c/p\u003e","title":"Day02 JS\u0026Vue\u0026Ajax"},{"content":"Web的三个组成部分：\n• HTML：负责网页的结构（页面元素和内容）。\n• CSS：负责网页的表现（页面元素的外观、位置等页面样式，如：颜色、大小等）。\n• Javascript：负责网页的行为（交互效果）。\nhtml HTML（HyperText Markup Language）：超文本标记语言\n超文本：超越了文本的限制，比普通文本更强大。除了文字信息，还可以定义图片、音频、视频等内容\n标记语言：由标签“\u0026lt;标签名\u0026gt;\u0026ldquo;构成的语言\nHTML标签都是预定义好的。例如：使用展示标题，使用展示图片，使用展示视频。HTML代码直接在浏览器中运行，HTML标签由浏览器解析。\nhtml语言的特点 html标签是不区分大小写的，但是通常是使用小写 属性值可以用双引号括起来也可以用单引号括起来，但是通常使用双引号 html语法没那么严谨，可以不写结束标签也可以用 超链接 a 标签 标签：央视网\n属性：\nhref: 指定资源访问的url target: 指定在何处打开资源链接 _self: 默认值，在当前页面打开 _blank: 在空白页面打开 常见标签 标签 作用 属性/说明 视频标签 src：指定视频的url（绝对路径/相对路径） controls：是否显示播放控件 width：宽度（像素/相对于父元素百分比） height：高度（像素/相对于父元素百分比） 图片标签 src, width，height 段落标签 标签 作用 属性/说明 / 加粗 具有强调语义 / 下划线 具有强调语义 / 倾斜 \u0026laquo;/font\u0026gt;em\u0026gt; 具有强调语义 / 删除线 具有强调语义 字符实体 属性/说明 \u0026amp;nbsp; 空格 \u0026amp;lt; \u0026laquo;/font\u0026gt; \u0026amp;gt; \u0026gt; 资源路径写法\n绝对路径 绝对磁盘路径（D:/xxX.ipg） 绝对网络路径（https://xxx.jpg） 相对路径 当前目录：./（可以省略） 上一级目录：../ 页面原型 指在应用程序开发初期，由产品经理制作的一个早期项目模型，它用于展示页面的基本布局、功能和交互设计。通常用来帮助设计师、开发者等更好地理解和讨论最终产品的外观和行为。\n表单标签 表单：在网页中主要负责数据采集功能，如注册、登录等数据采集。\n标签：\n表单项：不同类型的 input 元素、下拉列表、文本域等。\n• ：定义表单项，通过type属性控制输入形式（text/password/\u0026hellip;）\n• ：定义下拉列表，定义列表项\n• ：定义文本域\n属性：\n• action：规定当提交表单时向何处发送表单数据，URL\n• method： 规定用于发送表单数据的方式。GET、POST\nget: 在url后面拼接表单数据, 比如: ?username=Tom\u0026amp;age=12 , url长度有限制（默认值）\npost: 在消息体(请求体)中传递的, 参数大小无限制的\n注意：表单项必须有name属性才可以提交。\n// 如果想要只能选择一个，必须保证name是一样的，value的意思是会提交给服务器什么数据 // label标签是为了提升用户体验的，如果没有的话就需要精准的点击选择框，如果有的话 // 点击女字也可以选中 性别: \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; value=\u0026#34;1\u0026#34;\u0026gt; 男 \u0026lt;label\u0026gt;\u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; value=\u0026#34;2\u0026#34;\u0026gt; 女 \u0026lt;/label\u0026gt; 取值 描述 形式 text 默认值，定义单行的输入字段 password 定义密码字段 radio 定义单选按钮 checkbox 定义复选框 file 定义文件上传按钮 date/time/datetime-local 定义日期/时间/日期时间 hidden 定义隐藏域 submit/reset/button 定义提交按钮 / 重置按钮 / 可点击按钮 表格标签 标签 描述 定义表格整体 用于定义表格头部(可选) 定义表格中的主体部分(可选) 表格的行，可以包裹多个 表格单元格(普通)，可以包裹内容；如果是表头单元格，可以替换为 CSS CSS的引入方式 lCSS引入方式：\n•行内样式：写在标签的style属性中（配合JavaScript使用）\n\u0026lt;span style=\u0026#34;color: gray;\u0026#34;\u0026gt;2024年05月15日 20:07\u0026lt;/span\u0026gt; •内部样式：写在style标签中（可以写在页面任何位置，但通常约定写在head标签中）\n\u0026lt;style\u0026gt; span { color: gray; } \u0026lt;/style\u0026gt; •外部样式：写在一个单独的.css文件中（需要通过 link 标签在网页中引入）\nspan { color: gray; } \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;css/news.css\u0026#34;\u0026gt; 表示方式 属性值 说明 示例 关键字 颜色英文单词 red、green、blue red、green、blue\u0026hellip; rgb表示法 rgb(r,g,b) 红绿蓝三原色，取值：0-255 rgb(0,0,0)、rgb(255,0,0) rgba表示法 rgba(r,g,b,a) 红绿蓝三原色，a表示透明度，取值：0-1 rgba(0,0,0,0.3)、rgba(255,0,0,0.5) 十六进制表示法 #rrggbb #开头，将数字转换成十六进制表示 #000000、#ff0000，简写：#000、#f00 CSS选择器 选择器 写法 示例 示例说明 元素选择器 元素名称 {\u0026hellip;} h1 {\u0026hellip;} 选择页面上所有的标签 类选择器 .class属性值 {\u0026hellip;} .cls{\u0026hellip;} 选择页面上所有class属性为cls的标签 id****选择器 #id属性值 {\u0026hellip;} #hid {\u0026hellip;} 选择页面上id属性为hid的标签 当都出现的时候，优先级大小：\nid选择器\u0026gt;类选择器\u0026gt;元素选择器\nCSS属性 line-height：设置行高\ntext-indent：首行缩进\n盒子模型 盒子：页面中所有的元素（标签），都可以看做是一个盒子，由盒子将页面中的元素包含在一个矩形区域内，通过盒子的视角更方便的进行页面布局\n盒子模型组成：内容区域（content）、内边距区域（padding）、边框区域（border）、外边距区域（margin）\n布局标签：网页开发中，会使用 div 和 span 这两个没有语义的布局标签。\n标签： 一行只显示一个（独占一行） 宽度默认是父元素的宽度，高度默认由内容撑开 可以设置宽高（width、height） 标签： 一行可以显示多个 宽度和高度默认由内容撑开 不可以设置宽高（width、height） \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;盒子模型\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; div { width: 200px; /* 宽度 */ height: 200px; /* 高度 */ box-sizing: border-box; /* 指定width height为盒子的高宽 */ background-color: aquamarine; /* 背景色 */ padding: 20px 20px 20px 20px; /* 内边距, 上 右 下 左 , 边距都一行, 可以简写: padding: 20px;*/ border: 10px solid red; /* 边框, 宽度 线条类型 颜色 */ margin: 30px 30px 30px 30px; /* 外边距, 上 右 下 左 , 边距都一行, 可以简写: margin: 30px; */ } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt; A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; flex布局 flex是flexible Box的缩写，意为“弹性布局”，是一种一维的布局模型。flex布局可以为元素之间提供强大的空间分布和对齐能力。\n通过给父容器添加flex的相关属性，来控制子元素的位置和排列方式。\n属性 取值 含义 display flex 使用flex布局 flex-direction（设置主轴） row 主轴方向为x轴，水平向右。（默认） column 主轴方向为y轴，垂直向下。 justify-content（子元素在主轴上的对齐方式） flex-start 从头开始排列 flex-end 从尾部开始排列 center 在主轴居中对齐 space-around 平分剩余空间 space-between 先两边贴边，再平分剩余空间 总结 html：\n类别 标签 说明 文本处理标签 - 一级标题 - 六级标题 \u0026laquo;/font\u0026gt;br\u0026gt;、 换行、段落 、\u0026laquo;/font\u0026gt;em\u0026gt;、、 文本加粗、倾斜、下划线、删除线 \u0026lt;a href=\u0026rdquo;\u0026hellip;\u0026quot;\u0026gt; 超链接 （属性：href、target） 图片、音视频标签 \u0026laquo;/font\u0026gt;imgsrc=\u0026quot;\u0026hellip;\u0026quot;\u0026gt; 图片（路径：绝对路径、相对路径） \u0026lt;audio src=\u0026quot;\u0026hellip;\u0026quot;\u0026gt;、\u0026lt;video src=\u0026quot;\u0026hellip;\u0026quot;\u0026gt; 音频、视频 布局标签 、 没有语义的布局标签，配合CSS实现页面布局 表格标签 、、 表格、表头、表格主体 / 、 行 / 单元格 表单标签 定义表单（属性：action、method） 表单项（文本输入框、按钮\u0026hellip;） / 表单项（下拉列表/选项） css：\n类别 属性 说明 盒子模型 作用：控制元素尺寸、内边距、边框、外边距，从而控制页面的布局展示 width、height 高度、宽度 box-sizing 高度和宽度的计算方式；content-box，border-box padding 内边距（上、右、下、左；上下、左右） border 边框 margin 外边距（上、右、下、左；上下、左右） flex弹性布局 作用：是一种一维的布局模型，为元素之间提供强大的空间分布和对齐能力。 display flex：使用flex布局 flex-direction 设置主轴方向（row：x轴，水平方向；column：y轴，垂直方向） justify-content 子元素在主轴上的对齐方式 ","permalink":"https://wqnm1gb.github.io/posts/day01-htmlcss/","summary":"\u003cp\u003eWeb的三个组成部分：\u003c/p\u003e\n\u003cp\u003e• HTML：负责网页的结构（页面元素和内容）。\u003c/p\u003e\n\u003cp\u003e• CSS：负责网页的表现（页面元素的外观、位置等页面样式，如：颜色、大小等）。\u003c/p\u003e","title":"Day01 html\u0026css"},{"content":"单元测试 就是针对最小的功能单元：方法，编写测试代码对其进行正确性测试。\n咱们之前是如何进行单元测试的？有啥问题？\n• 只能在main方法编写测试代码，去调用其他方法进行测试。\n• 无法实现自动化测试，一个方法测试失败，可能影响其他方法的测试。\n• 无法得到测试的报告，需要程序员自己去观察测试是否成功。\nJunit单元测试框架 可以用来对方法进行测试，它是第三方公司开源出来的（很多开发工具已经集成了Junit框架比如IDEA）\n优点\n• 可以灵活的编写测试代码，可以针对某个方法执行测试，也支持一键完成对全部方法的自动化测试，且各自独立。\n• 不需要程序员去分析测试的结果，会自动生成测试报告出来。\nJunit单元测试的使用步骤 需求\n• 某个系统，有多个业务方法，请使用Junit单元测试框架，编写测试代码，完成对这些方法的正确性测试。\n具体步骤\n① 将Junit框架的jar包导入到项目中（注意：IDEA集成了Junit框架，不需要我们自己手工导入了）\n② 为需要测试的业务类，定义对应的测试类，并为每个业务方法，编写对应的测试方法（必须：公共、无参、无返回值）\n③ 测试方法上必须声明@Test注解，然后在测试方法中，编写代码调用被测试的业务方法进行测试\n④ 开始测试：选中测试方法，右键选择“JUnit运行”，如果测试通过则是绿色；如果测试失败，则是红色\n反射 反射就是：加载类，并允许以编程的方式解剖类中的各种成分（成员变量、方法、构造器等）\nidea中能提示各种类里边的信息就是用了反射的方式\n获取class的三种方式 Class c1=类名.class // 1、方式1：Class c1=类名.class Class c1= Student.class; System.out.println(c1); 调用Class提供方法：public static Class forName（String package） // 2、方式2：调用Class提供方法：public static Class forName（String package） Class c2 = Class.forName(\u0026#34;com.demo02Reflect.Student\u0026#34;); System.out.println(c1==c2); Object提供的方法：public Class getClassO； Class c3 = 对象.getClassl // 3、方式3：使用对象.getClass() Student s = new Student(); Class c3 = s.getClass(); System.out.println(c3); 获取类中的构造器 反射的第一步都是拿到类\n方法 说明 Constructor[] getConstructors() 获取全部构造器（只能获取public修饰的） Constructor[] getDeclaredConstructors() 获取全部构造器（只要存在就能拿到，私有构造器也能拿到） Constructor getConstructor(Class\u0026hellip; parameterTypes) 获取某个构造器（只能获取public修饰的） Constructor getDeclaredConstructor(Class\u0026hellip; parameterTypes) 获取某个构造器（只要存在就能拿到） 获取类构造器的作用：依然是初始化对象返回 Constructor****提供的方法 说明 T newInstance(Object\u0026hellip; initargs) 调用此构造器对象表示的构造器，并传入参数，完成对象的初始化并返回 public void setAccessible(boolean flag) 设置为true，表示禁止检查访问控制（暴力反射） @Test public void getConstructor() throws Exception { Class c1 = Dog.class; // 返回一个Constructor数组 Constructor[] cons = c1.getDeclaredConstructors(); for (Constructor con : cons) { System.out.println(con); } // 获取单个构造器，里边有String和Int变量的 Constructor con1 = c1.getDeclaredConstructor(String.class, int.class); System.out.println(con1); // 创建对象并且返回 Dog d1 = (Dog)con1.newInstance(\u0026#34;小黑\u0026#34;, 2); System.out.println(d1); } 获取类中的成员变量 方法 说明 public Field[] getFields() 获取类的全部成员变量（只能获取public修饰的） public Field[] getDeclaredFields() 获取类的全部成员变量（只要存在就能拿到） public Field getField(String name) 获取类的某个成员变量（只能获取public修饰的） public Field getDeclaredField(String name) 获取类的某个成员变量（只要存在就能拿到） 获取到成员变量的作用：依然是赋值、取值\n方法 说明 void set(Object obj, Object value)： 赋值 Object get(Object obj)s 取值 public void setAccessible(boolean flag) 设置为true，表示禁止检查访问控制（暴力反射） @Test public void getField() throws Exception { // 获取成员变量 Class c1 = Dog.class; Field[] f1 = c1.getDeclaredFields(); for (Field f : f1) { System.out.println(f.getName()+\u0026#34;(\u0026#34;+f.getType().getName()+\u0026#34;)\u0026#34;); } // 获取单个成员变量 Field f2 = c1.getDeclaredField(\u0026#34;hobby\u0026#34;); System.out.println(f2.getName()+\u0026#34;(\u0026#34;+f2.getType().getName()+\u0026#34;)\u0026#34;); // 给成员变量赋值 Dog d1 = new Dog(\u0026#34;小黑\u0026#34;, 2); // 因为hobby是私有变量，所以需要暴力反射 f2.setAccessible(true); // 需要拿到f2（变量对象），再拿到d1（对象），才能进行修改 f2.set(d1, \u0026#34;看门\u0026#34;); } 获取类中的成员方法 方法 说明 Method[] getMethods() 获取类的全部成员方法（只能获取public修饰的） Method[] getDeclaredMethods() 获取类的全部成员方法（只要存在就能拿到） Method getMethod(String name, Class\u0026hellip; parameterTypes) 获取类的某个成员方法（只能获取public修饰的） Method getDeclaredMethod(String name, Class\u0026hellip; parameterTypes) 获取类的某个成员方法（只要存在就能拿到） 成员方法的作用：依然是执行\nMethod****提供的方法 说明 public Object invoke(Object obj, Object\u0026hellip; args) 触发某个对象的该方法执行。 public void setAccessible(boolean flag) 设置为true，表示禁止检查访问控制（暴力反射） public void getMethod() throws Exception { // 获取类中的方法 Class c1 = Dog.class; Method[] m1 = c1.getDeclaredMethods(); for (Method m : m1) { System.out.println(m.getName() + \u0026#34;(\u0026#34; + m.getParameterCount() + \u0026#34;)\u0026#34;); } // 获取单个成员方法 Method m2 = c1.getDeclaredMethod(\u0026#34;eat\u0026#34;); Method m3 = c1.getDeclaredMethod(\u0026#34;eat\u0026#34;, String.class); System.out.println(m2.getName() + \u0026#34;(\u0026#34; + m2.getParameterCount() + \u0026#34;)\u0026#34;); System.out.println(m3.getName() + \u0026#34;(\u0026#34; + m3.getParameterCount() + \u0026#34;)\u0026#34;); // 4、获取成员方法的目的依然是调用方法。 Dog d1 = new Dog(\u0026#34;小黑\u0026#34;, 2); m2.setAccessible(true); Object invoke = m2.invoke(d1); System.out.println(invoke); // 带回来的返回值，void参数所以是null Object invoke2 = m3.invoke(d1, \u0026#34;骨头\u0026#34;); System.out.println(invoke2); // 带回来的返回值：狗说：谢谢！谢谢！汪汪汪！ } 反射的作用 基本作用：可以得到一个类的全部成分然后操作\n可以破坏封装性。\n可以绕过泛型的约束（因为泛型是在编译的时候替换的，反射可以直接获得class文件，这个是运行时的文件，所以可以绕过约束）\n最重要的用途是：适合做Java的框架，基本上，主流的框架都会基于反射设计出一些通用的功能。\n使用反射做一个简易版的框架 需求：\n对于任意一个对象，该框架都可以把对象的字段名和对应的值，保存到文件中去。\n实现步骤\n① 定义一个方法，可以接收任意对象。\n② 每收到一个对象后，使用反射获取该对象的Class对象，然后获取全部的成员变量。\n③ 遍历成员变量，然后提取成员变量在该对象中的具体值。\n④ 把成员变量名、和其值，写出到文件中去即可。\n注解 就是Java代码里的特殊标记，比如：@Override、@Test等，作用是：让其他程序根据注解信息来决定怎么执行该程序\n注意：注解可以用在类上、构造器上、方法上、成员变量上、参数上、等位置处，最后边不需要加分号。\n自定义注解 就是自己定义注解\npublic @interface 注解名称 { public 属性类型 属性名() default 默认值 ; } 特殊属性名：value\n如果注解中只有一个value属性，使用注解时，value名称可以不写\n@A(10) public @interface A { int value(); int a() default 20; } 注解的原理 注解本质是一个接口，Java中所有注解都是继承了Annotation接口的。\n@注解（..）：其实就是一个实现类对象，实现了该注解以及Annotation接口。\n元注解 注解注解的注解\n@Retention(RetentionPolicy.RUNTIME) @Target({ElementType.METHOD}) public @interface Test { } @Target 作用：声明被修饰的注解只能在哪些位置使用\n@Target （ElementType.TYPE）\nTYPE，类，接口\nFIELD，成员变量\nMETHOD，成员方法\nPARAMETER，方法参数\nCONSTRUCTOR，构造器\nLOCAL_VARIABLE，局部变量\n@Retention 作用：声明注解的保留周期。\n@Retention（RetentionPolicy.RUNTIME）\nSOURCE：只作用在源码阶段，字节码文件中不存在。\nCLASS（默认值）：保留到字节码文件阶段，运行阶段不存在.\nRUNTIME（开发常用）：一直保留到运行阶段。\n注解的解析 就是判断类上、方法上、成员变量上是否存在注解，并把注解里的内容给解析出来\n如何解析注解 指导思想：要解析谁上面的注解，就应该先拿到谁。\n比如要解析类上面的注解，则应该先获取该类的Class对象，再通过Class对象解析其上面的注解。\n比如要解析成员方法上的注解，则应该获取到该成员方法的Method对象，再通过Method对象解析其上面的注解。\nClass、 Method、Field, Constructor、都实现了AnnotatedElement接口，它们都拥有解析注解的能力。\nAnnotatedElement****接口提供了解析注解的方法 说明 public Annotation[] getDeclaredAnnotations() 获取当前对象上面的注解。 public T getDeclaredAnnotation(Class annotationClass) 获取指定的注解对象 public boolean isAnnotationPresent(Class annotationClass) 判断当前对象上是否存在某个注解 使用注解开发出一个简易版的Junit框架 需求：定义若干个方法，只要加了Mytest注解，就会触发该方法执行\n① 定义一个自定义注解MyTest，只能注解方法，存活范围是一直都在\n② 定义若干个方法，部分方法加上@MyTest注解修饰，部分方法不加\n③ 模拟一个junit程序，可以触发加了@MyTest注解的方法执行\n注解里边的成员变量可以用来指示运行的次数\n动态代理设计模式 用明星的例子来理解\n对象如果嫌身上干的事太多的话，可以通过代理来转移部分职责。对象有什么方法想被代理，代理就一定要有对应的方法\n中介如何知道要派有唱歌、跳舞方法的代理呢 ？接口\njava.lang.reflect.Proxy类：提供了为对象产生代理对象的方法：\npublic static Object newProxyInstance(ClassLoader loader,Class[] interfaces, InvocationHandler h) 参数一：用于指定用哪个类加载器，去加载生成的代理类\n参数二：指定接口，这些接口用于指定生成的代理长什么，也就是有哪些方法\n参数三：用来指定生成的代理对象要干什么事情\n// 采用了多态的写法，返回一个接口，但是可以通过这个接口来创建代理对象 public static StarServer createProxy (Star s) { /** * 参数一：用于执行用哪个类加载器去加载生成的代理类。 * 参数二：用于指定代理类需要实现的接口: 明星类实现了哪些接口，代理类就实现哪些接口 * 参数三：用于指定代理类需要如何去代理（代理要做的事情）。 */ StarServer proxy =(StarServer)Proxy.newProxyInstance(ProxyUtl.class.getClassLoader(), s.getClass().getInterfaces(), new InvocationHandler() { // 用来声明代理对象要干的事情。 // 参数一： proxy接收到代理对象本身（暂时用处不大） // 参数二： method代表正在被代理的方法 // 参数三： args代表正在被代理的方法的参数 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 有两种method方法，判断一下 String name = method.getName(); if (\u0026#34;sing\u0026#34;.equals(name)) { System.out.println(\u0026#34;准备话筒，收钱20w\u0026#34;); } else if (\u0026#34;dance\u0026#34;.equals(name)) { System.out.println(\u0026#34;准备场地，收钱310w\u0026#34;); } // 把明星喊过来干活 Object invoke = method.invoke(s, args); return invoke; } }); return proxy; } 执行的时候，会先执行代理里边的方法\n","permalink":"https://wqnm1gb.github.io/posts/day16-java%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/","summary":"\u003ch1 id=\"单元测试\"\u003e单元测试\u003c/h1\u003e\n\u003cp\u003e就是针对最小的功能单元：方法，编写测试代码对其进行正确性测试。\u003c/p\u003e\n\u003cp\u003e咱们之前是如何进行单元测试的？有啥问题？\u003c/p\u003e\n\u003cp\u003e• 只能在main方法编写测试代码，去调用其他方法进行测试。\u003c/p\u003e","title":"Day16 Java高级技术"},{"content":"InetAddress类 代表IP地址\nInetAddress类的常用方法 说明 public static InetAddress getLocalHost() throws UnknownHostException 获取本机IP，返回一个InetAddress对象 public String getHostName() 获取该ip地址对象对应的主机名。 public String getHostAddress() 获取该ip地址对象中的ip地址信息。 public static InetAddress getByName(String host) throws UnknownHostException 根据ip地址或者域名，返回一个inetAddress对象 public boolean isReachable(int timeout) throws IOException 判断主机在指定毫秒内与该ip对应的主机是否能连通 UDP通信 特点：无连接、不可靠通信。\n不事先建立连接；发送端每次把要发送的数据（限制在64KB内）、接收端IP、等信息封装成一个数据包，发出去就不管了。\nJava提供了一个java.net.DatagramSocket类来实现UDP通信。\nDatagramSocket：用于创建客户端、服务端\n构造器 说明 public DatagramSocket() 创建客户端的Socket对象, 系统会随机分配一个端口号。 public DatagramSocket(int port) 创建服务端的Socket对象, 并指定端口号 方法 说明 public void send(DatagramPacketdp****) 发送数据包 public void receive(DatagramPacket p) 使用数据包接收数据 DatagramPacket：创建数据包\n构造器 说明 public DatagramPacket(byte[] buf, int length, InetAddress address, int port) 创建发出去的数据包对象 public DatagramPacket(byte[] buf, int length) 创建用来接收数据的数据包 方法 说明 public int getLength() 获取数据包，实际接收到的字节个数 客户端实现步骤 ① 创建DatagramSocket对象（客户端对象）\u0026mdash;\u0026mdash;\u0026gt;扔韭菜的人\n② 创建DatagramPacket对象封装需要发送的数据（数据包对象）\u0026mdash;\u0026ndash;\u0026gt;韭菜盘子\n③ 使用Datagramsocket对象的send方法，传入DatagramPaket对象 \u0026mdash;\u0026ndash;\u0026gt;开始抛出韭菜\n④ 释放资源\n客户端实现可以反复发送数据 ① 创建DatagramSocket对象（发送端对象）\n② 使用while死循环不断的接收用户的数据输入，如果用户输入的exit则退出程序\n③ 如果用户输入的不是exit，把数据封装成DatagramPacket\n④ 使用DatagramSocket对象的send方法将数据包对象进行发送\n⑤ 释放资源\n服务端实现步骤 ① 创建DatagramSocket对象并指定端口（服务端对象）\u0026mdash;\u0026ndash;\u0026gt; 接韭菜的人\n② 创建DatagramPacket对象接收数据（数据包对象）\u0026mdash;\u0026mdash;-\u0026gt; 韭菜盘子\n③ 使用DatagramSocket对象的receive方法，传入DatagramPacket对象 \u0026mdash;\u0026mdash;-\u0026gt;开始接收韭菜\n④ 释放资源\n服务端实现可以反复发送数据 ① 创建DatagramSocket对象并指定端口（服务端对象）\u0026mdash;\u0026ndash;\u0026gt; 接韭菜的人\n② 创建DatagramPacket对象接收数据（数据包对象）\u0026mdash;\u0026mdash;-\u0026gt; 韭菜盘子\n③ 使用DatagramSocket对象的receive方法，传入DatagramPacket对象 \u0026mdash;\u0026mdash;-\u0026gt;开始接收韭菜\n④ 使用while死循环不断的进行第3步\nUDP的接收端为什么可以接收很多发送端的消息？\n接收端只负责接收数据包，无所谓是哪个发送端的数据包。\nTCP通信 客户端程序就是通过java.net包下的Socket类来实现的。\n构造器 说明 public Socket(String host , int port) 根据指定的服务器ip、端口号请求与服务端建立连接，连接通过，就获得了客户端socket 方法 说明 public OutputStreamgetOutputStream() 获得字节输出流对象 public InputStreamgetInputStream() 获得字节输入流对象 通过流对象来接收和传输数据\n服务端是通过java.net包下的ServerSocket类来实现的。\n构造器 说明 public ServerSocket(int port) 为服务端程序注册端口 方法 说明 public Socket accept() 阻塞等待客户端的连接请求，一旦与某个客户端成功连接，则返回服务端这边的Socket对象。 客户端实现步骤 ① 创建客户端的Socket对象，请求与服务端的连接。\n② 使用socket对象调用getOutputstream()方法得到字节输出流。\n③ 使用字节输出流完成数据的发送。\n④ 释放资源：关闭socket管道。\n服务端实现步骤 ① 创建ServerSocket对象，注册服务端端口。\n② 调用ServerSocket对象的accept()方法，等待客户端的连接，并得到Socket管道对象。\n③ 通过Socket对象调用getInputStream()方法得到字节输入流、完成数据的接收。\n④ 释放资源：关闭socket管道\n继承了Thread类本身也可以当一个Runnable对象来进行使用，因为Thread类也实现了Runnable接口！\n时间类 JDK8之后的新方案\nLocalDate：代表本地日期（年、月、日、星期）\nLocalTime：代表本地时间（时、分、秒、纳秒）\nLocalDateTime：代表本地日期、时间（年、月、日、星期、时、分、秒、纳秒）\n方法名 示例 public static Xxxx now(): 获取系统当前时间对应的该对象 LocaDateld = LocalDate.now(); LocalTimelt = LocalTime.now(); LocalDateTimeldt = LocalDateTime.now(); LocalDateTime的常用API（可以处理年、月、日、星期、时、分、秒、纳秒等信息）\n方法名 说明 getYear、getMonthValue、getDayOfMonth、getDayOfYeargetDayOfWeek、getHour、getMinute、getSecond、getNano 获取年月日、时分秒、纳秒等 withYear、withMonth、withDayOfMonth、withDayOfYearwithHour、withMinute、withSecond、withNano 修改某个信息，返回新日期时间对象 plusYears、plusMonths、plusDays、plusWeeksplusHours、plusMinutes、plusSeconds、plusNanos 把某个信息加多少，返回新日期时间对象 minusYears、minusMonths、minusDays、minusWeeksminusHours、minusMinutes、minusSeconds、minusNanos 把某个信息减多少，返回新日期时间对象 equals isBeforeisAfter 判断2个时间对象，是否相等，在前还是在后 字符串高效操作 +号拼接字符串内容，效率不高，原因是String的对象是不可变变量，每次都要指向新的对象\n对于字符串相关的操作，如频繁的拼接、修改等，建议用StringBuidler，效率更高！\n注意：如果操作字符串较少，或者不需要操作，以及定义字符串变量，还是建议用String。\nStringBuilder代表可变字符串对象，相当于是一个容器，它里面装的字符串是可以改变的，就是用来操作字符串的。\n好处：StringBuilder比String更适合做字符串的修改操作，效率会更高，代码也会更简洁，而且支持链式操作\n构造器 说明 public StringBuilder() 创建一个空白的可变的字符串对象，不包含任何内容 public StringBuilder(String str) 创建一个指定字符串内容的可变字符串对象 方法名称 说明 public StringBuilder append(任意类型) 添加数据并返回StringBuilder对象本身 public StringBuilder reverse() 将对象的内容反转 public int length() 返回对象内容长度 public String toString() 通过toString()就可以实现把StringBuilder转换为String BigDecimal 用于解决浮点型运算时，出现结果失真的问题\n构造器 说明 public BigDecimal(double val) 注意：不推荐使用这个 将 double转换为 BigDecimal public BigDecimal(String val) 把String转成BigDecimal 方法名 说明 public static BigDecimal valueOf(double val) 转换一个 double成 BigDecimal public BigDecimal add(BigDecimal b) 加法 public BigDecimal subtract(BigDecimal b) 减法 public BigDecimal multiply(BigDecimal b) 乘法 public BigDecimal divide(BigDecimal b) 除法 public BigDecimal divide (另一个BigDecimal对象，精确几位，舍入模式) 除法、可以控制精确到小数几位 public double doubleValue() 将BigDecimal转换为double 应该如何把浮点型转换成Biglecimal的对象？\nBigDecimal b1 = BigDecimal. valueOf（0.1）\n","permalink":"https://wqnm1gb.github.io/posts/day15-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","summary":"\u003ch1 id=\"inetaddress类\"\u003eInetAddress类\u003c/h1\u003e\n\u003cp\u003e代表IP地址\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e\u003c!-- raw HTML omitted --\u003eInetAddress\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e类的常用方法\u003c!-- raw HTML omitted --\u003e\u003c/th\u003e\n          \u003cth\u003e\u003c!-- raw HTML omitted --\u003e说明\u003c!-- raw HTML omitted --\u003e\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003epublic static \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eInetAddress \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003egetLocalHost\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e() \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003ethrows \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eUnknownHostException\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003e获取本机\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eIP\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e，返回一个\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eInetAddress\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e对象\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003epublic \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eString \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003egetHostName\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e()\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003e获取该\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eip\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e地址对象对应的主机名。\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003epublic \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eString \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003egetHostAddress\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e()\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003e获取该\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eip\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e地址对象中的\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eip\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e地址信息。\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003epublic static \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eInetAddress \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003egetByName\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e(\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eString host\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e)   \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e    \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003ethrows \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eUnknownHostException\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003e根据\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eip\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e地址或者域名，返回一个\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003einetAddress\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e对象\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003epublic boolean \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eisReachable\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e(\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eint \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003etimeout\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e) \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003ethrows \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eIOException\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003e判断主机在指定毫秒内与该\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eip\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e对应的主机是否能连通\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch1 id=\"udp通信\"\u003eUDP通信\u003c/h1\u003e\n\u003cp\u003e特点：无连接、不可靠通信。\u003c/p\u003e","title":"Day15 网络编程"},{"content":"多线程 什么是线程？\n线程（Thread）是一个程序内部的一条执行流程\n程序中如果只有一条执行流程，那这个程序就是单线程的程序\n多线程是指从软硬件上实现的多条执行流程的技术（多条线程由CPU负责调度执行）\n创建线程的方式一：继承Thread类 ① 定义一个子类MyJhread继承线程类java.lang.Thread，重写run()方法\n② 创建MyThread类的对象\n③ 调用线程对象的start()方法启动线程（启动后还是执行run方法的）\n方式一优缺点：\n优点：编码简单\n缺点：线程类已经继承Thread，无法继承其他类，不利于功能的扩展。\n创建线程的注意事项 启动线程必须是调用start方法，不是调用run方法。\n•直接调用run方法会当成普通方法执行，此时相当于还是单线程执行。\n•只有调用start方法才是启动一个新的线程执行。\n不要把主线程任务放在启动子线程之前。\n• 这样主线程一直是先跑完的，相当于是一个单线程的效果了。\n创建线程的方式二：实现Runnable接口 ① 定义一个线程任务类MyRunnable实现Runnable接口，重写run()方法\n② 创建MyRunnable任务对象\n③ 把MyRunnable任务对象交给Thread处理。\nThread****类提供的构造器 说明 public Thread(Runnable target) 封装Runnable对象成为线程对象 ④ 调用线程对象的start()方法启动线程\n方式二的优缺点\n优点：任务类只是实现接口，可以继续继承其他类、实现其他接口，扩展性强。\n缺点：需要多一个Runnable对象。\n匿名内部类的写法\n① 可以创建Runnable的匿名内部类对象。\n② 再交给Thread线程对象。\n③ 再调用线程对象的start()启动线程。\nnew Thread(()-\u0026gt;{for (int i = 0; i \u0026lt; 5; i++) { System.out.println(\u0026#34;子线程2输出：\u0026#34;+ i); }}).start(); 创建线程的方式三：实现Callabel接口 ①创建任务对象\n定义一个类实现Callable接口，重写call方法，封装要做的事情，和要返回的数据。把Callable类型的对象封装成FutureJask（线程任务对象）\n②把线程任务对象交给Thread对象\n③调用Thread对象的start方法启动线程\n④线程执行完毕后、通过FutureJask对象的的get方法去获取线程任务执行的结果\nFutureTask的API\nFutureTask****提供的构造器 说明 public FutureTask\u0026lt;\u0026gt;(Callable call) 把Callable对象封装成FutureTask对象。 FutureTask****提供的方法 说明 public V get() throws Exception 获取线程执行call方法返回的结果。 线程创建方式三的优缺点\n优点：线程任务类只是实现接口，可以继续继承类和实现接口，扩展性强；可以在线程执行完毕后去获取线程执行的结果。\n缺点：编码复杂一点\n三种线程方式的对比 方式 优点 缺点 继承Thread类 编程比较简单，可以直接使用Thread类中的方法 扩展性较差，不能再继承其他的类，不能返回线程执行的结果 实现Runnable接口 扩展性强，实现该接口的同时还可以继承其他的类。 编程相对复杂，不能返回线程执行的结果 实现Callable接口 扩展性强，实现该接口的同时还可以继承其他的类。可以得到线程执行的结果 编程相对复杂 Thread的常用方法 Thread****提供的常用方法 说明 public void run() 线程的任务方法 public void start() 启动线程 public String getName****() 获取当前线程的名称，线程名称默认是Thread-索引 public void setName****(String name) 为线程设置名称，设置名字要在启动线程之前 public static Thread currentThread****() 获取当前执行的线程对象 public static void sleep(long time) 让当前执行的线程休眠多少毫秒后，再继续执行 public final void join()\u0026hellip; 让调用当前这个方法的线程先执行完，相当于插队 Thread****提供的常见构造器 说明 public Thread(String name) 可以为当前线程指定名称 public Thread(Runnable target) 封装Runnable对象成为线程对象 public Thread(Runnable target,String name) 封装Runnable对象成为线程对象，并指定线程名称 主线程的名字是main\n创建的线程名字是 Thread-编号\n解决线程安全问题的方法 方法1：同步代码块 作用：把访问共享资源的核心代码给上锁，以此保证线程安全。\nsynchronized（同步锁）{ 访问共享资源的核心代码 } 原理：每次只允许一个线程加锁后进入，执行完毕后自动解锁，其他线程才可以进来执行\n同步锁的注意事项\n对于当前同时执行的线程来说，同步锁必须是同一把（同一个对象），否则会出bug。\n锁对象随便选择一个唯一的对象好不好呢？\n不好，会影响其他无关线程的执行。\n锁对象的使用规范\n建议使用共享资源作为锁对象，对于实例方法建议使用this作为锁对象。\n对于静态方法建议使用字节码（类名.class）对象作为锁对象。\n方法2：同步方法 作用：把访问共享资源的核心方法给上锁，以此保证线程安全。\n修饰符 synchronized 返回值类型 方法名称（形参列表）{ 操作共享资源的代码 } 原理：每次只能一个线程进入，执行完毕以后自动解锁，其他线程才可以进来执行\n同步方法底层原理\n同步方法其实底层也是有隐式对象的，只是锁的范围是整个方法代码。\n如果方法是实例方法：同步方法默认用this作为的锁对象。\n如果方法是静态方法：同步方法默认用类名.class作为的锁对象。\n把run方法用synchronized修饰不一定有效果\n同步代码块好还是同步方法好？\n范围上：同步代码块锁的范围更小，同步方法锁的范围更大\n可读性：同步方法更好\n方式3：Lock锁 Lock锁是JDK5开始提供的一个新的锁定操作，通过它可以创建出锁对象进行加锁和解锁，更灵活、更方便、更强大。\nLock是接口，不能直接实例化，可以采用它的实现类Reentrantlgck来构建Lock锁对象。\n构造器 说明 public ReentrantLock() 获得Lock锁的实现类对象 方法名称 说明 void lock() 获得锁 void unlock() 释放锁 锁对象建议加上什么修饰？\n建议使用final修饰，防止被别人篡改\n释放锁的操作建议放到哪里？\n建议将释放锁的操作放到finally代码块中，确保锁用完了一定会被释放\n线程池 线程池就是一个可以复用线程的技术。\n不使用线程池的问题\n用户每发起一个请求，后台就需要创建一个新线程来处理，下次新任务来了肯定又要创建新线程处理的，创建新线程的开销是很大的，并且请求过多时，肯定会产生大量的线程出来，这样会严重影响系统的性能。\n任务队列中只能是Runnable和Callable任务\n创建线程池 JDK 5.0起提供了代表线程池的接口：ExecutorService。\n方式一：使用ExecutorService的实现类ThreadPoolExecutor自创建一个线程池对象\nThreadPoolExecutor类提供的构造器 作用 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue\u0026laquo;/font\u0026gt;Runnable\u0026gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) 使用指定的初始化参数创建一个新的线程池对象 参数一：corePoolSize：指定线程池的核心线程的数量。 正式工：3\n参数二：maximumPoolSize：指定线程池的最大线程数量。最大员工数：5 临时工：2\n参数三：keepAliveTime：指定临时线程的存活时间。 临时工空闲多久被开除\n参数四：unit：指定临时线程存活的时间单位（秒、分、时、天）\n参数五：workQueue：指定线程池的任务队列。 客人排队的地方\n参数六：threadFactory：指定线程池的线程工厂。 负责招聘员工的（hr）\n参数七：handler：指定线程池的任务拒绝策略（线程都在忙，任务队列也满了的时候，新任务来了该怎么处理） 忙不过来咋办？\n方式二：使用Executors（线程池的工具类）调用方法返回不同特点的线程池对象\n方法名称 说明 public static ExecutorService newFixedThreadPool(int nThreads) 创建固定线程数量的线程池，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程替代它。 public static ExecutorService newSingleThreadExecutor() 创建只有一个线程的线程池对象，如果该线程出现异常而结束，那么线程池会补充一个新线程。 public static ExecutorService newCachedThreadPool() 线程数量随着任务增加而增加，如果线程任务执行完毕且空闲了60s则会被回收掉。 public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) 创建一个线程池，可以实现在给定的延迟后运行任务，或者定期执行任务。 大型并发系统环境中使用Executors如果不注意可能会出现系统风险\nExecutors工具类底层是基于什么方式实现的线程池对象？\n线程池ExecutorSeryi.ce的实现类：ThreadPooJExecutor\nExecutors是否适合做大型互联网场景的线程池方案？\n不合适。\n建议使用ThreadPoolExecutor来指定线程池参数，这样可以明确线程池的运行规则，规避资源耗尽的风险。\n处理Runnable任务 方法名称 说明 void execute(Runnable command) 执行 Runnable 任务 Future submit(Callable task) 执行 Callable 任务，返回未来任务对象，用于获取线程返回的结果 void shutdown() 等全部任务执行完毕后，再关闭线程池！ List\u0026laquo;/font\u0026gt;Runnable\u0026gt; shutdownNow() 立刻关闭线程池，停止正在执行的任务，并返回队列中未执行的任务 线程池的注意事项 什么时候开始创建临时线程？ 新任务提交时发现核心线程都在忙，任务队列也满了，并且还可以创建临时线程，此时才会创建临时线程。\n什么时候会拒绝新任务？ 核心线程和临时线程都在忙，任务队列也满了，新的任务过来的时候才会开始拒绝任务。\n任务拒绝策略\n策略 说明 ThreadPoolExecutor.AbortPolicy() 丢弃任务并抛出RejectedExecutionException异常。是默认的策略 ThreadPoolExecutor. DiscardPolicy() 丢弃任务，但是不抛出异常，这是不推荐的做法 ThreadPoolExecutor. DiscardOldestPolicy() 抛弃队列中等待最久的任务 然后把当前任务加入队列中 ThreadPoolExecutor. CallerRunsPolicy() 由主线程负责调用任务的run()方法从而绕过线程池直接执行 处理Callable任务 线程池如何处理Callable任务，并得到任务执行完后返回的结果？\n使用ExecutorService的方法\nFuture submit（Callable command） 多态写法，返回一个RunnableFuture对象，可以调用里边get()方法\n进程 正在运行的程序（软件）就是一个独立的进程\n线程是属于进程的，一个进程中可以同时运行很多个线程\n进程中的多个线程其实是并发和并行执行的\n并发的含义 进程中的线程是由CPU负责调度执行的，但CPU能同时处理线程的数量有限，为了保证全部线程都能往前执行，CPU会轮询为系统的每个线程服务，由于CPU切换的速度很快，给我们的感觉这些线程在同时执行，这就是并发。\n并行的理解 在同一个时刻上，同时有多个线程在被CPU调度执行。\n","permalink":"https://wqnm1gb.github.io/posts/day14-thread/","summary":"\u003ch2 id=\"多线程\"\u003e多线程\u003c/h2\u003e\n\u003cp\u003e什么是线程？\u003c/p\u003e\n\u003cp\u003e线程（Thread）是一个程序内部的一条执行流程\u003c/p\u003e\n\u003cp\u003e程序中如果只有一条执行流程，那这个程序就是单线程的程序\u003c/p\u003e\n\u003cp\u003e多线程是指从软硬件上实现的多条执行流程的技术（多条线程由CPU负责调度执行）\u003c/p\u003e","title":"Day14 Thread"},{"content":"File File是java.io.包下的类，File类的对象，用于代表当前操作系统的文件（可以是文件、或文件夹）\n注意：File类只能对文件本身进行操作，不能读写文件里面存储的数据\n可以使用相对路径定位文件对象\n只要带盘符的都称之为：绝对路径E:/resource/aaa.jpg\n相对路径：不带盘符，默认是到你的idea工程下直接寻找文件的，一般用来找工程下的项目文件的\n注意只能相对到工程，后边的文件夹名和src还需要手动写\n创建File对象 构造器 说明 public File(String pathname) 根据文件路径创建文件对象 public File(String parent, String child) 根据父路径和子路径名字创建文件对象 File对象既可以代表文件、也可以代表文件夹。\nFile封装的对象仅仅是一个路径名，这个路径可以是存在的，也允许是不存在的。\n可以用/，也可以用\\\nFile提供的判断文件类型、获取文件信息功能 方法名称 说明 public boolean exists() 判断当前文件对象，对应的文件路径是否存在，存在返回true public booleanisFile() 判断当前文件对象指代的是否是文件，是文件返回true，反之。 public booleanisDirectory() 判断当前文件对象指代的是否是文件夹，是文件夹返回true，反之。 public String getName() 获取文件的名称（包含后缀） public long length() 获取文件的大小，返回字节个数 public long lastModified() 获取文件的最后修改时间。 public String getPath() 获取创建文件对象时，使用的路径 public String getAbsolutePath() 获取绝对路径 File提供的创建和删除文件的方法 File类创建文件的功能 方法名称 说明 public booleancreateNewFile() 创建一个新的空的文件 public booleanmkdir() 只能创建一级文件夹 public booleanmkdirs() 可以创建多级文件夹 File类删除文件的功能 方法名称 说明 public boolean delete() 删除文件、空文件夹 注意：delete方法默认只能删除文件和空文件夹，删除后的文件不会进入回收站。\nFile提供的遍历文件夹的方法 方法名称 说明 public String[] list() 获取当前目录下所有的\u0026quot;一级文件名称\u0026quot;到一个字符串数组中去返回。 public File[] listFiles() 获取当前目录下所有的\u0026quot;一级文件对象\u0026quot;到一个文件对象数组中去返回（重点） 使用listFiles方法时的注意事项：\n• 当主调是文件，或者路径不存在时，返回null\n• 当主调是空文件夹时，返回一个长度为0的数组\n• 当主调是一个有内容的文件夹时，将里面所有一级文件和文件夹的路径放在File数组中返回\n• 当主调是一个文件夹，目里面有隐藏文件时，将里面所有文件和文件夹的路径放在File数组中返回，包含隐藏文件\n• 当主调是一个文件夹，但是没有权限访问该文件夹时，返回null\n递归的三要素 递归的公式： f(n)= f(n-1)*n；\n递归的终结点：f(1)\n递归的方向必须走向终结点\n文件搜索 先找出D:盘下的所有一级文件对象\n遍历全部一级文件对象，判断是否是文件\n如果是文件，判断是否是自己想要的\n如果是文件夹，需要继续进入到该文件夹，重复上述过程\n字符集 标准的ASCII编码 ASCII（American Standard Code for Information Interchange）：美国信息交换标准代码，包括了英文、符号等。\n标准ASCIl使用1个字节存储一个字符，首位是0因此，总共可表示128个字符，对美国佬来说完全够用。\nGBK（汉字内码扩展规范，国标） 汉字编码字符集，包含了2万多个汉字等字符，GBK中一个中文字符编码成两个字节的形式存储。\n注意：GBK兼容了ASCII字符集。\nGBK规定：汉字的第一个字节的第一位必须是1\nUnicode字符集（统一码，也叫万国码） Unicode是国际组织制定的，可以容纳世界上所有文字、符号的字符集。\nUTF-8字符集 是Unicode字符集的一种编码方案，采取可变长编码方案，共分四个长度区：1个字书，2个字节，3个字节，4个字节（不像Unicode会占用4个字节，太大了）\n英文字符、数字等只占1个字节（兼容标准ASCII编码），汉字字符占用3个字节。\n前缀码\n注意1：字符编码时使用的字符集，和解码时使用的字符集必须一致，否则会出现乱码\n注意2：英文，数字一般不会乱码，因为很多字符集都兼容了ASCII编码。\n对字符集进行编码\nString提供了如下方法 说明 byte[] getBytes() 使用平台的默认字符集将该String编码为一系列字节，将结果存储到新的字节数组中 byte[] getBytes(String charsetName) 使用指定的字符集将该 String编码为一系列字节，将结果存储到新的字节数组中 对字符的解码\nString****提供了如下方法 说明 String(byte[] bytes) 通过使用平台的默认字符集解码指定的字节数组来构造新的 String String(byte[] bytes, String charsetName) 通过指定的字符集解码指定的字节数组来构造新的 String IO流 用于读写数据的（可以读写文件，或者网络上的数据）\nIO流的分类 IO流的体系 FileInputStream（文件字节输入流） 作用：以内存为基准，可以把磁盘文件中的数据以字节的形式读入到内存中去。\n构造器 说明 public FileInputStream(File file) 创建字节输入流管道与源文件接通 public FileInputStream(String pathname) 创建字节输入流管道与源文件接通 方法名称 说明 public int read() 每次读取一个字节返回，如果发现没有数据可读会返回-1，性能较差，而且不能读中文，每次读一个字节的话，中文会乱码 public int read(byte[] buffer) 每次用一个字节数组去读取数据，返回字节数组读取了多少个字节，如果发现没有数据可读会返回-1 使用FilelnputStream每次读取一个字节，读取性能较差，并且读取汉字输出会乱码。\n使用FilelnputStream每次读取多个字节，读取性能得到了提升，但读取汉字输出还是会乱码。\n1、使用字节流读取中文，如何保证输出不乱码，怎么解决？\n定义一个与文件一样大的字节数组，一次性读取完文件的全部字节（只适合读小文件）\nJava提供了方法：\n方法名称 说明 public byte[] readAllBytes() throws IOException 直接将当前字节输入流对应的文件对象的字节数据装到一个字节数组返回 如果文件过大，创建的字节数组也会过大，可能引起内存溢出。\n读取文本适合用字符流 字节流适合做数据的转移，比如：文件复制\nFileOutputStream文件字节输出流 作用：以内存为基准，把内存中的数据以字节的形式写出到文件中去。\n用完流后都要关闭\n\u0026ldquo;\\r\\n\u0026rdquo;.getBytes(); // 写出一个换行符\n构造器 说明 public FileOutputStream(File file) 创建字节输出流管道与源文件对象接通 public FileOutputStream(String filepath) 创建字节输出流管道与源文件路径接通 public FileOutputStream(File file，boolean append) 创建字节输出流管道与源文件对象接通，可追加数据，后边跟true表示可以追加 public FileOutputStream(String filepath，boolean append) 创建字节输出流管道与源文件路径接通，可追加数据 方法名称 说明 public void write(int a) 写一个字节出去 public void write(byte[] buffer) 写一个字节数组出去 public void write(byte[] buffer , int pos , int len) 写一个字节数组的一部分出去。 public void close() throws IOException 关闭流。 资源释放的问题 try-catch-finally finally代码区的特点：无论try中的程序是正常执行了，还是出现了异常，最后都一定会执行finally区，除非JVM终止。\n作用：一般用于在程序执行完成后进行资源的释放操作（专业级做法），但是比较臃肿\ntry-with-resource try(定义资源1;定义资源2;…）{ 可能出现异常的代码; }catch(异常类名 变量名){ 异常的处理代码; } 该资源使用完毕后，会自动调用其close()方法，完成对资源的释放！\n()中只能放置资源，否则报错\n什么是资源呢？\n资源一般指的是最终实现了AutoCloseable接口。\n字符流 FileReader文件字符输入流 作用：以内存为基准，可以把文件中的数据以字符的形式读入到内存中去。\n拓展：文件字符输入流每次读取多个字符，性能较好，而且读取中文是按照字符读取，不会出现乱码！这是一种读取中文很好的方案。\n构造器 说明 public FileReader****(File file) 创建字符输入流管道与源文件接通 public FileReader****(String pathname) 创建字符输入流管道与源文件接通 方法名称 说明 public int read() 每次读取一个字符返回，如果发现没有数据可读会返回-1. public int read(char[] buffer) 每次用一个字符数组去读取数据，返回字符数组读取了多少个字符，如果发现没有数据可读会返回-1. 读文档的时候，不要需加换行符，文档中自己有换行符\n�\nFileWriter文件字符输出流 以内存为基准，把内存中的数据以字符的形式写出到文件中去。\n构造器 说明 public FileWriter(File file) 创建字节输出流管道与源文件对象接通 public FileWriter(String filepath) 创建字节输出流管道与源文件路径接通 public FileWriter(File file，boolean append) 创建字节输出流管道与源文件对象接通，可追加数据 public FileWriter(String filepath，boolean append) 创建字节输出流管道与源文件路径接通，可追加数据 方法名称 说明 void write(int c) 写一个字符 void write(String str) 写一个字符串 void write(String str, int off, int len) 写一个字符串的一部分 void write(char[] cbuf) 写入一个字符数组 字符输出流写出数据后，必须刷新流，或者关闭流，写出去的数据才能生效\n方法名称 说明 public void flush() throws IOException 刷新流，就是将内存中缓存的数据立即写到文件中去生效！ public void close() throws IOException 关闭流的操作，包含了刷新！ 使用close就会默认刷新，或者使用try with resource也会默认在关闭的时候刷新\nBufferedInputstream缓冲字节输入和输出流 作用：可以提高字节输入流读取数据的性能\n原理：缓冲字节输入流自带了8KB缓冲池；缓冲字节输出流也自带了8KB缓冲池。\n构造器 说明 public BufferedInputStream(InputStream is) 把低级的字节输入流包装成一个高级的缓冲字节输入流，从而提高读数据的性能 public BufferedOutputStream(OutputStreamos) 把低级的字节输出流包装成一个高级的缓冲字节输出流，从而提高写数据的性能 BufferedReader缓冲字符输入流 作用：自带8K（8192）的字符缓冲池，可以提高字符输入流读取字符数据的性能。\n构造器 说明 public BufferedReader(Reader r) 把低级的字符输入流包装成字符缓冲输入流管道，从而提高字符输入流读字符数据的性能 字符缓冲输入流新增的功能：按照行读取字符\n方法 说明 public String readLine() 读取一行数据返回，如果没有数据可读了，会返回null Bufferedwriter缓冲字符输出流 作用：自带8K的字符缓冲池，可以提高字符输出流写字符数据的性能。\n构造器 说明 public BufferedWriter(Writer r) 把低级的字符输出流包装成一个高级的缓冲字符输出流管道，从而提高字符输出流写数据的性能（把低级管道变成一个高级管道，里边包着一个高级管道） 字符缓冲输出流新增的功能：换行\n方法 说明 public void newLine() 换行 可以把低级管道的缓冲桶加大，那么这样性能就会接近高级管道，所以并不是低级管道的新能一定差，相对来说，桶越大，复制速度越快\n其他流 InputStreamReader（字节输入转换流） 解决不同编码时，字符流读取文本内容乱码的问题。\n解决思路： 先获取文件的原始字节流再将其按真实的字符集编码转成字符输入流，这样字符输入流中的字符就不乱码了。\n这也是个高级流，里边可以包着一个低级流\n构造器 说明 public InputStreamReader(InputStream is) 把原始的字节输入流，按照代码默认编码转成字符输入流（与直接用FileReader的效果一样） public InputStreamReader(InputStream is ，String charset) 把原始的字节输入流，按照指定字符集编码转成字符输入流(重点) PrintStream/PrintWriter（打印流） 作用：打印流可以实现更方便、更高效的打印数据出去，能实现打印啥出去就是啥出去，性能也高。\nPrintStream提供的打印数据的方案\n构造器 说明 public PrintStream(OutputStream/File/String) 打印流直接通向字节输出流/文件/文件路径 publicPrintStream(String fileName, Charset charset) 可以指定写出去的字符编码 publicPrintStream(OutputStream out, boolean autoFlush) 可以指定实现自动刷新 publicPrintStream(OutputStream out, boolean autoFlush, String encoding) 可以指定实现自动刷新，并可指定字符的编码 方法 说明 public void println(Xxx**** xx) 打印任意类型的数据出去，天生自带换行 public void write(int/byte[]/byte[]一部分) 可以支持写字节数据出去 PrintWriter提供的打印数据的方案\n构造器 说明 public Print****Writer(OutputStream/Writer/File/String) 打印流直接通向字节输出流/文件/文件路径 publicPrintWriter(String fileName, Charset charset) 可以指定写出去的字符编码 publicPrintWriter(OutputStream out/Writer, boolean autoFlush) 可以指定实现自动刷新 publicPrintWriter(OutputStream out, boolean autoFlush, String encoding) 可以指定实现自动刷新，并可指定字符的编码 方法 说明 public void println(Xxx**** xx) 打印任意类型的数据出去 public void write(int/String/char[]/..) 可以支持写字符数据出去 PrintStream和PrintWriter的区别 • 打印数据的功能上是一模一样的：都是使用方便，性能高效（核心优势）\n• PrintStream继承自字节输出流OutputStream，因此支持写**字节数据**的方法。\n• PrintWriter继承自**字符输出流Writer，因此支持写字符数据**出去。\nDataOutputStream（数据输出流） 允许把数据和其类型一并写出去。\n构造器 说明 public DataOutputStream(OutputStream**** out) 创建新数据输出流包装基础的字节输出流 方法 说明 public final void writeByte(int v) throws IOException 将byte类型的数据写入基础的字节输出流 public final void writeInt****(int v) throws IOException 将int类型的数据写入基础的字节输出流 public final void writeDouble(Double v) throws IOException 将double类型的数据写入基础的字节输出流 public final void writeUTF(String str) throws IOException 将字符串数据以UTF-8编码成字节写入基础的字节输出流 public void write(int/byte[]/byte[]一部分) 支持写字节数据出去 DatalnputStream（数据输入流） 用于读取数据输出流写出去的数据。\n构造器 说明 public DataInputStream(InputStream**** is) 创建新数据输入流包装基础的字节输入流 方法 说明 Public final byte readByte() throws IOException 读取字节数据返回 public final int readInt****() throws IOException 读取int类型的数据返回 public final double readDouble() throws IOException 读取double类型的数据返回 public final String readUTF****() throws IOException 读取字符串数（UTF-8）据返回 public int readInt()/read(byte[]) 支持读字节数据进来 IO框架 什么是框架？\n框架（Framework）是一个预先写好的代码库或一组工具，旨在简化和加速开发过程\n框架的形式：一般是把类、接口等编译成class形式，再压缩成一个.jar结尾的文件发行出去\n导入commons-io-2.11.0jar框架到项目的步骤\n① 在项目中创建一个文件夹：lib\n② 将commons-io-2.6.jar文件复制到1ib文件夹\n③ 在jar文件上点右键，选择 Add as Library -\u0026gt; 点击OK\n④ 在类中导包使用\nCommons-io框架\nCommons-io是apache开源基金组织提供的一组有关IO操作的小框架，目的是提高IO流的开发效率。\nFileUtils类提供的部分方法展示 说明 public static void copyFile(File srcFile, File destFile) 复制文件。 public static void copyDirectory(File srcDir, File destDir) 复制文件夹 public static void deleteDirectory(File directory) 删除文件夹 public static String readFileToString(File file, String encoding) 读数据 public static void writeStringToFile(File file, String data, String charname, boolean append) 写数据 IOUtils类提供的部分方法展示 说明 public static int copy(InputStreaminputStream, OutputStreamoutputStream) 复制文件。 public static int copy(Reader reader, Writer writer) 复制文件。 public static void write(String data, OutputStream output, String charsetName) 写数据 ","permalink":"https://wqnm1gb.github.io/posts/day13-file%E5%92%8Cio%E6%B5%81/","summary":"\u003ch2 id=\"file\"\u003eFile\u003c/h2\u003e\n\u003cp\u003eFile是java.io.包下的类，File类的对象，用于代表当前操作系统的文件（可以是文件、或文件夹）\u003c/p\u003e\n\u003cp\u003e注意：File类\u003c!-- raw HTML omitted --\u003e只能对文件本身进行操作，不能读写文件里面存储的数据\u003c!-- raw HTML omitted --\u003e\u003c/p\u003e","title":"Day13 File和IO流"},{"content":"Set系列集合：添加的元素是无序、不重复、无索引 HashSet： 无序、不重复、无索引\nLinkedHashSet： 有序、不重复、无索引\nTreeSet：排序（按照大小默认升序排序）、不重复、无索引\nSet要用到的常用方法，基本上就是Collection提供的！！\n自己几乎没有额外新增一些常用功能！\nHashSet的底层原理 哈希值：就是一个int类型的随机值，Java中每个对象都有一个哈希值。\nJava中的所有对象，都可以调用Obejct类提供的hashCode方法，返回该对象自己的哈希值。\n对象哈希值的特点 同一个对象多次调用hashCode()方法返回的哈希值是相同的。\n不同的对象，它们的哈希值大概率不相等，但也有可能会相等（哈希碰撞）。\n基于哈希表存储数据的。\n哈希表\n• JDK8之前，哈希表=数组+链表\n创建一个默认长度16的数组，默认加载因子为0.75，16*0.75=12，存的数据超过12，扩容，增加一被的容量，数组名table\n使用元素的哈希值对数组的长度做运算计算出应存入的位置\n判断当前位置是否为null，如果是null直接存入\n如果不为null，表示有元素，则调用equals方法比较相等，则不存；不相等，则存入数组\nJDK 8之前，新元素存入数组，占老元素位置，老元素挂下面\nJDK 8开始之后，新元素直接挂在老元素下面\nJDK8开始 当链表长度超过8 且数组长度\u0026gt;=64时 自动将链表转成红黑树（提高检索性能）\n• JDK8开始，哈希表=数组+链表+红黑树\n• 哈希表是一种增删改查数据，性能都较好的数据结构\nHashSet集合去重复机制\n结论：如果希望Set集合认为2个内容一样的对象是重复的，必须重写对象的hashCode()和equals()方法\nLinkHashSet的底层原理 依然是基于哈希表（数组、链表、红黑树）实现的。\n但是，它的每个元素都额外的多了一个双链表的机制记录它前后元素的位置。\nTreeSet集合 特点：不重复、无索引、可排序（默认升序排序，按照元素的大小，由小到大排序）\n底层是基于红黑树实现的排序。\n注意：\n• 对于数值类型：Integer,Double，默认按照数值本身的大小进行升序排序。\n• 对于字符串类型：默认按照首字符的编号升序排序。\n• 对于自定义类型如Student对象，TreeSet默认是无法直接排序的。\n结论：TreeSet集合默认不能 给白定义对象排序啊，因为不知道大小规则，并且一定要实现\n1、对象类实现一个Comparable比较接口，重写compareTo方法，指定大小比较规则\n@Override public int compareTo(Teacher o) { //用年龄进行比较 if(this.age\u0026gt;o.age) return 1; if(this.age\u0026lt;o.age) return -1; //如果return 0的话，两个相等的值就只会保留一个，如果想都保留，需要在相等的时候return1 return 1; // return 0; } 2、public Treeset （Comparator c）集合自带比较器Comparator对象，指定比较规则（优先级更高）\n//解决方法2、public Treeset （Comparator c）集合自带比较器Comparator对象，指定比较规则（优先级更高） // Set\u0026lt;Teacher\u0026gt; set = new TreeSet\u0026lt;\u0026gt;(new Comparator\u0026lt;Teacher\u0026gt;() { // @Override // public int compare(Teacher o1, Teacher o2) { // return o2.getAge()-o1.getAge(); // } // }); Set\u0026lt;Teacher\u0026gt; set = new TreeSet\u0026lt;\u0026gt;((o1, o2) -\u0026gt; o2.getAge()-o1.getAge()); Map-双列集合 每个元素包含两个值（键值对）\nMap集合也被叫做“键值对集合”，格式：｛keyl=valuel，key2=value2,key3=value3，\u0026hellip;｝\nMap集合的所有键是不允许重复的，但值可以重复，键和值是一一对应的，每一个键只能找到自己对应的值\n需要存储一一对应的数据时，就可以考虑使用Map集合来做\nMap集合体系的特点 注意：Map系列集合的特点都是由键决定的，值只是一个附属品，值是不做要求的\n• HashMap（由键决定特点）：无序、不重复、无索引、键值对可以都是null；（用的最多）\n• LinkedHashMap（由键决定特点）：由键决定的特点：有序、不重复、无索引、键值对可以都是null\n• TreeMap（由键决定特点）：按照大小默认升序排序、不重复、无索引\nMap集合的常用方法 方法名称 说明 public V put(K key,V value) 添加元素 public int size() 获取集合的大小 public void clear() 清空集合 public booleanisEmpty() 判断集合是否为空，为空返回true , 反之 public V get(Object key) 根据键获取对应值 public V remove(Object key) 根据键删除整个元素 public booleancontainsKey(Object key) 判断是否包含某个键 public booleancontainsValue(Object value) 判断是否包含某个值 public Set keySet() 获取全部键的集合 public Collection values() 获取Map集合的全部值 Map集合的遍历方式 方式1：键找值 先获取Map集合全部的键，再通过遍历键来找值\npublic static void main(String[] args) { //遍历方式1 键找值：通过Set集合获得键集合，然后找到所有的值集合 Map\u0026lt;String,Integer\u0026gt; m =new HashMap\u0026lt;\u0026gt;(); m.put(\u0026#34;张三\u0026#34;,18); m.put(\u0026#34;李四\u0026#34;,19); m.put(\u0026#34;王五\u0026#34;,20); m.put(\u0026#34;王五\u0026#34;,22);//键相同的情况下只会保留一个键值对 m.put(\u0026#34;赵六\u0026#34;,21); Set\u0026lt;String\u0026gt; keys = m.keySet(); for (String key : keys) { System.out.println(key+\u0026#34;--\u0026gt;\u0026#34;+m.get(key)); } } 方式2：键值对 Map****提供的方法 说明 Set\u0026laquo;/font\u0026gt;Map.Entry\u0026lt;K, V\u0026raquo; entrySet() 获取所有“键值对”的集合 Map.Entry****提供的方法 说明 K getKey() 获取键 V getValue() 获取值 public static void main(String[] args) { //遍历方式2 键值对：Set\u0026lt;Map.Entry\u0026lt;K, V\u0026gt;\u0026gt; entrySet() Map\u0026lt;String,Integer\u0026gt; m =new HashMap\u0026lt;\u0026gt;(); m.put(\u0026#34;张三\u0026#34;,18); m.put(\u0026#34;李四\u0026#34;,19); m.put(\u0026#34;王五\u0026#34;,20); m.put(\u0026#34;王五\u0026#34;,22);//键相同的情况下只会保留一个键值对 m.put(\u0026#34;赵六\u0026#34;,21); Set\u0026lt;Map.Entry\u0026lt;String,Integer\u0026gt;\u0026gt; set = m.entrySet(); // Map.Entry\u0026lt;String,Integer\u0026gt;相当于是一个类型 for (Map.Entry\u0026lt;String, Integer\u0026gt; stringIntegerEntry : set) { String s = stringIntegerEntry.getKey(); Integer i = stringIntegerEntry.getValue(); System.out.println(s+\u0026#34;---\u0026gt;\u0026#34;+i); } } 方式3：Lambda 本质也是增强for\n方法名称 说明 default void forEach(BiConsumer\u0026lt;? super K, ? super V\u0026gt; action) 结合lambda遍历Map集合 public static void main(String[] args) { //遍历方式3 Lambda Map\u0026lt;String,Integer\u0026gt; m =new HashMap\u0026lt;\u0026gt;(); m.put(\u0026#34;张三\u0026#34;,18); m.put(\u0026#34;李四\u0026#34;,19); m.put(\u0026#34;王五\u0026#34;,20); m.put(\u0026#34;王五\u0026#34;,22);//键相同的情况下只会保留一个键值对 m.put(\u0026#34;赵六\u0026#34;,21); m.forEach((k,v)-\u0026gt;System.out.println(k+\u0026#34;--\u0026gt;\u0026#34;+v)); m.forEach(new BiConsumer\u0026lt;String, Integer\u0026gt;() { @Override public void accept(String s, Integer integer) { //重写accpet方法就可以遍历 System.out.println(s+\u0026#34;--\u0026gt;\u0026#34;+integer); } }); HashMap的底层原理 实际上：原来学的Set系列集合的底层就是基于Map实现的，只是Set集合中的元素只要键数据，不要值数据而已。\nLinkHashMap的底层原理 实际上：原来学习 的LinkedHashSet集合的底层原理就是LinkedHashMap。\nTreeMap的底层原理 特点：不重复、无索引、可排序（按照键的大小默认升序排序，只能对键排序）\n原理：TreeMap跟TreeSet集合的底层原理是一样的，都是基于红黑树实现的排序。\nTreeMap集合同样也支持两种方式来指定排序规则\n• 让类实现Comparable接口，重写比较规则。\n• TreeMap集合有一个有参数构造器，支持创建Comparator比较器对象，以便用来指定比较规则。\nStream流 是Jdk8开始新增的一套API （java.util.stream.*），可以用于操作集合或者数组的数据。\n优势：Stream流大量的结合了Lambda的语法风格来编程，功能强大，性能高效，代码简洁，可读性好。\nStream流的使用步骤 获取Stream流 • 获取集合的Stream流\nCollection提供的如下方法\ndefault Streams stream()\n获取当前集合对象的stream流\n• 获取 数组的Stream流\nArrays类提供的如下方法\npublic static Streams stream(T[] array)\n获取当前数组的stream流\nStream类提供的如下方法\npublic static Streams of (T\u0026hellip; values)\n//\u0026hellip;是可变参数\n获取当前接收数据的stream流\nStream流上的常用方法 称为中间方法，用完之后会返回一个新的流，支持链式编程\npublic static void main(String[] args) { // 目标：认识Stream流的常用方法 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;张无忌\u0026#34;); list.add(\u0026#34;周芷若\u0026#34;); list.add(\u0026#34;赵敏\u0026#34;); list.add(\u0026#34;张强\u0026#34;); list.add(\u0026#34;张三丰\u0026#34;); list.add(\u0026#34;张翠山\u0026#34;); // 1、过滤方法 list.stream().filter(s -\u0026gt; s.startsWith(\u0026#34;张\u0026#34;) \u0026amp;\u0026amp; s.length() == 3).forEach(System.out::println); System.out.println(\u0026#34;=========================\u0026#34;); // 2.排序方法 List\u0026lt;Double\u0026gt; scores = new ArrayList\u0026lt;\u0026gt;(); scores.add(88.6); scores.add(66.6); scores.add(66.6); scores.add(77.6); scores.add(77.6); scores.add(99.6); scores.stream().sorted().forEach(System.out::println); // 升序 System.out.println(\u0026#34;=========================\u0026#34;); // 降序需要重写 scores.stream().sorted((o1,o2)-\u0026gt; Double.compare(o2,o1)).forEach(System.out::println); System.out.println(\u0026#34;=========================\u0026#34;); // 3、只要前两名 scores.stream().sorted((o1,o2)-\u0026gt; Double.compare(o2,o1)).limit(2).forEach(System.out::println); System.out.println(\u0026#34;=========================\u0026#34;); // 4、跳过前两名 scores.stream().sorted((o1,o2)-\u0026gt; Double.compare(o2,o1)).skip(2).forEach(System.out::println); System.out.println(\u0026#34;=========================\u0026#34;); // 5、去重 scores.stream().sorted((o1,o2)-\u0026gt; Double.compare(o2,o1)).distinct().forEach(System.out::println); // 6、映射/加工方法，把流上的数据加工后，再次放回流里边去 scores.stream().map(s -\u0026gt;\u0026#34;加十分后:\u0026#34; + s+10).forEach(System.out::println); // 7、合并流 Stream\u0026lt;String\u0026gt; s1 = Stream.of(\u0026#34;张三丰\u0026#34;, \u0026#34;张无忌\u0026#34;, \u0026#34;张翠山\u0026#34;, \u0026#34;张良\u0026#34;, \u0026#34;张学友\u0026#34;); Stream\u0026lt;Integer\u0026gt; s2 = Stream.of(111, 22, 33, 44); Stream\u0026lt;Object\u0026gt; s3 = Stream.concat(s1, s2); s3.forEach(System.out::println); // 流没有重写toString方法java.util.stream.ReferencePipeline$Head@77459877 System.out.println(s3); } Stream上的终结方法 收集Stream流：就是把Stream流操作后的结果转回到集合或者数组中去返回。\nStream流：方便操作集合/数组的手段； 集合/数组：才是开发中的目的。\n流只能收集一次\npublic static void main(String[] args) { // 目标：掌握Stream流的统计，收集操作（终结方法） List\u0026lt;Teacher\u0026gt; teachers = new ArrayList\u0026lt;\u0026gt;(); teachers.add(new Teacher(\u0026#34;张三\u0026#34;, 23, 5000)); teachers.add(new Teacher(\u0026#34;金毛狮王\u0026#34;, 54, 16000)); teachers.add(new Teacher(\u0026#34;李四\u0026#34;, 24, 6000)); teachers.add(new Teacher(\u0026#34;王五\u0026#34;, 25, 7000)); teachers.add(new Teacher(\u0026#34;白眉鹰王\u0026#34;, 66, 108000)); teachers.add(new Teacher(\u0026#34;陈昆\u0026#34;, 42, 48000)); teachers.stream().filter(t -\u0026gt; t.getSalary() \u0026gt; 15000).forEach(System.out::println); System.out.println(\u0026#34;--------------------------------------------------\u0026#34;); long count = teachers.stream().filter(t -\u0026gt; t.getSalary() \u0026gt; 15000).count(); System.out.println(count); System.out.println(\u0026#34;--------------------------------------------------\u0026#34;); // 获取薪水最高的老师对象 Optional\u0026lt;Teacher\u0026gt; max = teachers.stream().max((t1, t2) -\u0026gt; Double.compare(t1.getSalary(), t2.getSalary())); Teacher maxTeacher = max.get(); // 获取Optional对象中的元素 System.out.println(maxTeacher); Optional\u0026lt;Teacher\u0026gt; min = teachers.stream().min((t1, t2) -\u0026gt; Double.compare(t1.getSalary(), t2.getSalary())); Teacher minTeacher = min.get(); // 获取Optional对象中的元素 System.out.println(minTeacher); System.out.println(\u0026#34;---------------------------------------------------------\u0026#34;); List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;张无忌\u0026#34;); list.add(\u0026#34;周芷若\u0026#34;); list.add(\u0026#34;赵敏\u0026#34;); list.add(\u0026#34;张强\u0026#34;); list.add(\u0026#34;张三丰\u0026#34;); list.add(\u0026#34;张三丰\u0026#34;); list.add(\u0026#34;张翠山\u0026#34;); // 流只能收集一次 // 收集到集合或者数组中去。 Stream\u0026lt;String\u0026gt; s1 = list.stream().filter(s -\u0026gt; s.startsWith(\u0026#34;张\u0026#34;)); // 收集到List集合 List\u0026lt;String\u0026gt; list1 = s1.collect(Collectors.toList()); System.out.println(list1); // Set\u0026lt;String\u0026gt; set2 = new HashSet\u0026lt;\u0026gt;(); // set2.addAll(list1); // 收集到Set集合 Stream\u0026lt;String\u0026gt; s2 = list.stream().filter(s -\u0026gt; s.startsWith(\u0026#34;张\u0026#34;)); Set\u0026lt;String\u0026gt; set = s2.collect(Collectors.toSet()); System.out.println(set); // 收集到数组中去 Stream\u0026lt;String\u0026gt; s3 = list.stream().filter(s -\u0026gt; s.startsWith(\u0026#34;张\u0026#34;)); Object[] array = s3.toArray(); System.out.println(\u0026#34;数组：\u0026#34; + Arrays.toString(array)); System.out.println(\u0026#34;------------------收集到Map集合---------------------------\u0026#34;); // 收集到Map集合：键是老师名称，值是老师薪水 Map\u0026lt;String, Double\u0026gt; map = teachers.stream().collect(Collectors.toMap(Teacher::getName, Teacher::getSalary)); System.out.println(map); } 方法中的可变参数 就是一种特殊形参，定义在方法、构造器的形参列表里，格式是：数据类型⋯参数名称；\n可变参数的特点和好处 特点：可以不传数据给它；可以传一个或者同时传多个数据给它；也可以传一个数组给它。\n好处：常常用来灵活的接收数据。\n可变参数对内其实就是一个数组\n可变参数在形参列表中只能有一个，可变参数必须放在形参列表的最后面\npublic static void main(String[] args) { // 认识方法中的可变参数 show(); show(1,2,3); show(new int[]{1,2,3,4,4}); } public static void show(int... args){ // 内部怎么拿数据： // 可变参数对内实际上就是一个数组。nums就是数组 System.out.println(args.length); System.out.println(Arrays.toString(args)); System.out.println(\u0026#34;------------------------------------------------\u0026#34;); } Collections工具类 1、给集合批量加数据\n2、打乱顺序\npublic static void main(String[] args) { // 目标：Colllections工具类 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); // list.add(\u0026#34;张无忌\u0026#34;); // list.add(\u0026#34;周芷若\u0026#34;); // list.add(\u0026#34;赵敏\u0026#34;); // list.add(\u0026#34;张强\u0026#34;); // list.add(\u0026#34;张三丰\u0026#34;); // list.add(\u0026#34;张翠山\u0026#34;); // 1、Collections的方法批量加 Collections.addAll(list,\u0026#34;张无忌\u0026#34;,\u0026#34;周芷若\u0026#34;,\u0026#34;赵敏\u0026#34;,\u0026#34;张强\u0026#34;,\u0026#34;张三丰\u0026#34;,\u0026#34;张翠山\u0026#34;); System.out.println(list); // 2、打乱顺序 Collections.shuffle(list); System.out.println(list); }\t","permalink":"https://wqnm1gb.github.io/posts/day12-mapstream%E6%B5%81/","summary":"\u003ch3 id=\"set系列集合添加的元素是无序不重复无索引\"\u003eSet系列集合：添加的元素是\u003c!-- raw HTML omitted --\u003e无序、不重复、无索引\u003c!-- raw HTML omitted --\u003e\u003c/h3\u003e\n\u003cp\u003eHashSet： \u003c!-- raw HTML omitted --\u003e无序\u003c!-- raw HTML omitted --\u003e、不重复、无索引\u003c/p\u003e\n\u003cp\u003eLinkedHashSet： \u003c!-- raw HTML omitted --\u003e有序\u003c!-- raw HTML omitted --\u003e、不重复、无索引\u003c/p\u003e","title":"Day12 Map、Stream流"},{"content":"异常 Error Error 代表的系统级别错误（属于严重问题），也就是说系统一旦出现问题，sun公司会把这些问题封装成Error对象给出来（说白了，Error是给sun公司自己用的，不是给我们程序员用的，因此我们开发人员不用管它）\nException 运行时异常 编译阶段不报错，运行时报错，继承自RunTimeException，一旦错误出现，程序就会结束\nNullPointException空指针\n编译时异常 提醒程序员这里的程序很容易出错，需要小心\n使用try catch解决(可以解决编译时异常，也可以解决运行时异常），提醒会更加的强烈，同时处理完异常后，程序不会结束\n异常的基本处理 throws抛出异常 在方法上使用throws关键字，可以将方法内部出现的异常抛出去给调用者处理。\ntry catch捕获异常 直接捕获可能出现的异常\n异常的作用 1、用来定位bug的关键信息\n2、作为方法内部的一种特殊的返回值，以便通知上层调用者，方法执行的问题\n自定义异常 Java无法为这个世界上全部的问题都提供异常类来代表 如果企业自己的某种问题， 想通过异常来表示，以便用异常来管理该问题，那就需要自己来定义异常类了。\n建议使用运行时异常，这样提醒没有那么强烈\n自定义运行时异常 定义一个异常类继承RuntimeException\n重写构造器\n通过throw new 异常类（xxx）来创建异常对象并拋出\n特点：编译阶段不报错，运行时才可能出现！提醒不属于激进型\n自定义编译时异常 定义一个异常类继承Exception\n重写构造器\n通过throw new 异常类（xxxx）创建异常对象并抛出\n特点：编译阶段就报错，提醒比较激进\n异常的处理方案 command option t 快捷生成try catch\n方案1 底层异常层层往上抛出，最外层捕获异常，记录下异常信息，并响应适合用户观看的信息进行提示\n有多个异常的时候，直接抛Exception，这样不用多个异常写多个异常的种类\n然后catch的时候，也就catch Exception类就行了\n方案2 最外层捕获异常后，尝试重新修复\n泛型 定义类、接口、方法时，同时声明了一个或者多个类型变量（如：）\n称为泛型类、泛型接口，泛型方法、它们统称为泛型。\npublic class ArrayList\u0026lt;E\u0026gt;{ } 作用：泛型提供了在编译阶段约束所能操作的数据类型，并自动进行检查的能力！\n泛型的本质：把具体的数据类型作为参数传给类型变量\n泛型类 修饰符 class类名\u0026lt;类型变量，类型变量，…\u0026gt;｛ ｝ 注意：类型变量建议用大写的英文字母，常用的有：E、T、K、V等\n泛型接口 修饰符 interface 接口名\u0026lt;类型变量，类型变量，...\u0026gt; ｝ 泛型方法，通配符，上下限 泛型方法 修饰符\u0026lt;类型变量，类型变量，…＞返回值类型 方法名（形参列表）｛ ｝ // 泛型方法声明都有一个类型参数声明部分（由尖括号分隔） public static \u0026lt;T\u0026gt; void test（T t）｛ ｝ 通配符 就是“？”，可以在“使用泛型”的时候代表一切类型；ET KV 是在定义泛型的时候使用。\n泛型的上下限 • 泛型上限：？extends Car：？能接收的必须是Car或者其子类。\n• 泛型下限：？super Car：？能接收的必须是Car或者其父类。\n泛型支持的类型 泛型不支持基本数据类型，只能支持对象类型（引用数据类型）\n泛型擦除：泛型工作在编译阶段，等编译后泛型就没用了，所以泛型在编译后都会被擦除。所有类型会恢复成Object类型，Object一定要指向一个对象\n包装类 包装类就是把基本类型的数据包装成对象的类型\nInteger把-128-127先缓存起来了\nInteger it1 = Integer.valueof(100); Integer it3 = 100;//和第一句一样的，自动装箱，变成对象 Integer it2 = Integer.valueof(100); System.out.println(it1==it2);//true 自动装箱：基本数据类型可以自动转换为包装类型。\n自动拆箱：包装类型可以自动转换为基本数据类型。\n包装类的其他功能 可以把基本类型的数据转换成字符串类型。\npublic static String toString(double d) public String toString() //功能比较鸡肋，一般转成字符串会用 String s1 = 123 + \u0026#34;\u0026#34;; 可以把字符串类型的数值转换成数值本身对应的真实数据类型（这个重要）\npublic static int parselnt(String s) public static Integer valueOf(String s) 集合框架 集合是一种容器，用来装数据的，类似于数组，但集合的大小可变，开发中也非常常用\n集合体系结构 集合的结构分成了两类\nCollection-单列集合 每个元素（数据）只包含一个值\n常用功能\n方法名 说明 public boolean add(E e) 把给定的对象添加到当前集合中 public void clear() 清空集合中所有的元素 public boolean remove(E e) 把给定的对象在当前集合中删除 public boolean contains(Object obj) 判断当前集合中是否包含给定的对象 public boolean isEmpty() 判断当前集合是否为空 public int size() 返回集合中元素的个数。 public Object[] toArray() 把集合中的元素，存储到数组中，默认转换成Object数组 Collection的遍历方式1：迭代器遍历\nnext() 函数默认是在第一个元素的位置，先取值在去到下一个元素位置\nhasnext() 函数是判断当前位置是否有元素\n获取迭代器\n方法名称 说明 Iterator iterator() 返回集合中的迭代器对象，该迭代器对象默认指向当前集合的第一个元素 迭代器中常用的方法\n方法名称 说明 boolean hasNext() 询问当前位置是否有元素存在，存在返回true ,不存在返回false E next() 获取当前位置的元素，并同时将迭代器对象指向下一个元素处。 Collection的遍历方式2：增强for循环\nfor (元素的数据类型 变量名 : 数组或者集合) { } 增强for可以用来遍历集合或者数组\n增强for遍历集合，本质就是迭代器遍历集合的简化写法\n快捷方式 数组/集合名.for\n底层就是基于迭代器\nCollection的遍历方式3：Lambda表达式\n要使用如下方法来完成\n方法名称 说明 default void forEach(Consumer\u0026lt;? super T\u0026gt; action) 结合lambda遍历集合 public static void main(String[] args) { //遍历方式3：使用Lambda表达式 ArrayList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;张三\u0026#34;); list.add(\u0026#34;李四\u0026#34;); list.add(\u0026#34;王五\u0026#34;); list.add(\u0026#34;赵6\u0026#34;); list.forEach(s -\u0026gt; System.out.println(s)); list.forEach(System.out::println); } 三种遍历的区别 认识并发修改异常问题\n遍历集合的同时又存在增删集合元素的行为时可能出现业务异常，这种现象被称之为并发修改异常问题。\nfor循环删除元素没删干净的本质原因是：删除一个元素后，后边一个元素立马补上来，导致了漏删\n解决方案1：删除元素后做一步i\u0026ndash;\n解决方案2：倒着遍历删除（前提是支持索引），原因是后边的元素补过来都是判断后不用删的，而顺着遍历前边的元素补上来不知道是否要删除\n1、迭代器遍历并删除存在并发修改异常问题，解决方案：使用迭代器自己的删除方法\n2、增强for和lambda都没办法解决并发修改异常问题，他们只适合做遍历，不适合做增删\n如果知道索引可以使用i\u0026ndash;的方式解决，如果不知道索引，就用迭代器的删除功能\nList系列集合：添加的元素是有序、可重复、有索引 List集合因为支持索引，所以多了很多与索引相关的方法，当然，Collection的功能List也都继承了。\n方法名称 说明 void add(int index,E element) 在此集合中的指定位置插入指定的元素 E remove(int index) 删除指定索引处的元素，返回被删除的元素 E set(int index,E element) 修改指定索引处的元素，返回被修改的元素 E get(int index) 返回指定索引处的元素 ArrayList、LinekdList：有序、可重复、有索引\nArrayList底层是基于数组存储数据的 数组的特点\n查询速度快（注意：是根据索引查询数据快）：查询数据通过地址值和索引定位，查询任意数据耗时相同。\n增删数据效率低：可能需要把后面很多的数据进行前移。\n第一次创建的时候是创建一个空数组，第一次添加的时候才扩容为初始大小为10的数组，二次添加后，会添加成之前的1.5倍\nLinkedList底层是基于链表存储数据的 链表的特点\n链表中的数据是一个一个独立的结点组成的，结点在内存中是不连续的，每个结点包含数据值和下一个结点的地址。是基于双链表实现的，特点：对首尾元素进行增删改查的速度是极快的，占用的内存更多\nLinkedList新增了：很多首尾操作的特有方法。\n链表的特点1：查询慢，无论查询哪个数据都要从头开始找。\n链表的特点2：链表增删相对快\n只需要一个的对象可以用static修饰\nSet系列集合：添加的元素是无序、不重复、无索引 HashSet： 无序、不重复、无索引\nLinkedHashSet： 有序、不重复、无索引\nTreeSet：按照大小默认升序排序、不重复、无索引\nMap-双列集合 每个元素包含两个值（键值对）\n","permalink":"https://wqnm1gb.github.io/posts/day11-%E5%BC%82%E5%B8%B8%E6%B3%9B%E5%9E%8B%E5%92%8C%E9%9B%86%E5%90%88/","summary":"\u003ch2 id=\"异常\"\u003e异常\u003c/h2\u003e\n\u003ch3 id=\"error\"\u003eError\u003c/h3\u003e\n\u003cp\u003eError 代表的系统级别错误（属于严重问题），也就是说系统一旦出现问题，sun公司会把这些问题封装成Error对象给出来（说白了，Error是给sun公司自己用的，不是给我们程序员用的，因此我们开发人员不用管它）\u003c/p\u003e","title":"Day11 异常、泛型和集合"},{"content":"ArrayList集合 数组定义完成并且启动后，长度就固定了\n集合大小可变，功能丰富，开发中用的更多\n要用泛型定义集合\n构造器 说明 public ArrayList() 创建一个空的集合对象 常用方法名 说明 public boolean add(E e) 将指定的元素添加到此集合的末尾 public void add(intindex,E element) 在此集合中的指定位置插入指定的元素 public E get(int index) 返回指定索引处的元素 public int size() 返回集合中的元素的个数 public E remove(int index) 删除指定索引处的元素，返回被删除的元素 public boolean remove(Object o) 删除指定的元素，返回删除是否成功 public E set(intindex,E element) 修改指定索引处的元素，返回被修改的元素 ","permalink":"https://wqnm1gb.github.io/posts/day10-arraylist%E9%9B%86%E5%90%88/","summary":"\u003ch2 id=\"arraylist集合\"\u003eArrayList集合\u003c/h2\u003e\n\u003cp\u003e数组定义完成并且启动后，长度就固定了\u003c/p\u003e\n\u003cp\u003e集合大小可变，功能丰富，开发中用的更多\u003c/p\u003e\n\u003cp\u003e要用泛型定义集合\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e\u003c!-- raw HTML omitted --\u003e构造器\u003c!-- raw HTML omitted --\u003e\u003c/th\u003e\n          \u003cth\u003e\u003c!-- raw HTML omitted --\u003e说明\u003c!-- raw HTML omitted --\u003e\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003epublic \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eArrayList\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e()\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003e创建一个空的集合对象\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e\u003c!-- raw HTML omitted --\u003e常用方法名\u003c!-- raw HTML omitted --\u003e\u003c/th\u003e\n          \u003cth\u003e\u003c!-- raw HTML omitted --\u003e说明\u003c!-- raw HTML omitted --\u003e\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003epublic \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eboolean\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e add(E e)\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003e将指定的元素添加到此集合的末尾\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003epublic void add(\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eint\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eindex,E\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e element)\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003e在此集合中的指定位置插入指定的元素\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003epublic E get(\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eint\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e index)\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003e返回指定索引处的元素\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003epublic \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eint\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e size()\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003e返回集合中的元素的个数\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003epublic E remove(\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eint\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e index)\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003e删除指定索引处的元素，返回被删除的元素\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003epublic \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eboolean\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e remove(Object o)\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003e删除指定的元素，返回删除是否成功\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003epublic E set(\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eint\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eindex,E\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e element)\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003e修改指定索引处的元素，返回被修改的元素\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e","title":"Day10 ArrayList集合"},{"content":"函数式编程 此“函数”类似于数学中的函数（强调做什么），只要输入的数据一致返回的结果也是一致的\n可以用于替代某些匿名内部类对象，从而让程序更简洁，可读性更好。\n(被重写方法的形参列表) -\u0026gt;{ 被重写方法的方法体代码 } 注意：Lambda表达式只能替代函数式接口的匿名内部类！！！\n什么是函数式接口：只有一个抽象方法的接口\n@FunctionInterface 专门用来声明函数式接口\nLambda表达式的省略规则 • 作用：用于进一步简化Lambda表达式的写法。\n具体规则\n1、参数类型全部可以省略不写。\n2、如果只有一个参数，参数类型省略的同时“（）”也可以省略，但多个参数不能省略（）”\n3、如果Lambda表达式中只有一行代码，大括号可以不写，同时要省略分号“；”如果这行代码是return\n语句，也必须去掉return。\n方法引用 静态方法引用 类名::静态方法\n使用场景\n如果某个Lambda表达式里只是调用一个静态方法，并且“-\u0026gt;”前后参数的形式一致，就可以使用静态方法引用。\nArrays.sort(students,Student::compare); 实例方法引用 对象名::实例方法。\n使用场景\n如果某个Lambda表达式里只是通过对象名称调用一个实例方法，并且“-\u0026gt;”前后参数的形式一致，就可以\n使用实例方法引用。\n特定类的方法引用 特定类的名称：方法\n使用场景\n如果某个Lambda表达式里只是调用一个特定类型的实例方法，并且前面参数列表中的第一个参数是作为方法的主调，后面的所有参数都是作为该实例方法的入参的，则此时就可以使用特定类型的方法引用。\n构造器引用 类名::new\n使用场景\n如果某个Lambda表达式里只是在创建对象，并且“-\u0026gt;”前后参数情况一致，就可以使用构造器引用。\nString类 String代表字符串，它的对象可以封装字符串数据，并提供了很多方法完成对字符串的处理。\n创建对线的区别\n只要是以\u0026quot;..\u0026ldquo;方式写出的字符串对象，会存储到字符串常量池，且相同内容的字符串只存储一份（节约内存）；\n通过new方式创建字符串对象，每new一次都会产生一个新的对象放在堆内存中。\n字符串对象的内容比较不要用==号，==号默认比较的是地址，字符串对象的内容一样时地址不一定一样\n建议使用String提供的equals方法，只关心内容，不关心地址\nsc.next()用来接收字符串对象\nString创建字符串对象的方式 构造器 说明 public String() 创建一个空白字符串对象，不含有任何内容 public String(String original) 根据传入的字符串内容，来创建字符串对象 public String(char[] chars) 根据字符数组的内容，来创建字符串对象 public String(byte[] bytes) 根据字节数组的内容，来创建字符串对象 String提供的常用方法 方法名 说明 public int length() 获取字符串的长度返回（就是字符个数） public char charAt(int index) 获取某个索引位置处的字符返回 public char[] toCharArray()： 将当前字符串转换成字符数组返回 public boolean equals(Object anObject) 判断当前字符串与另一个字符串的内容一样，一样返回true public booleanequalsIgnoreCase(String anotherString) 判断当前字符串与另一个字符串的内容是否一样(忽略大小写) public String substring(int beginIndex, int endIndex) 根据开始和结束索引进行截取，得到新的字符串（包前不包后，索引从0开始） public String substring(int beginIndex) 从传入的索引处截取，截取到末尾，得到新的字符串返回 public String replace(CharSequence target, CharSequence replacement) 使用新值，将字符串中的旧值替换，得到新的字符串 public boolean contains(CharSequence s) 判断字符串中是否包含了某个字符串 public booleanstartsWith(String prefix) 判断字符串是否以某个字符串内容开头，开头返回true，反之 public String[] split(String regex) 把字符串按照某个字符串内容分割，并返回字符串数组回来 ","permalink":"https://wqnm1gb.github.io/posts/day09-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E5%92%8Cstring%E7%B1%BB/","summary":"\u003ch2 id=\"函数式编程\"\u003e函数式编程\u003c/h2\u003e\n\u003cp\u003e此“函数”类似于数学中的函数（强调做什么），只要输入的数据一致返回的结果也是一致的\u003c/p\u003e\n\u003cp\u003e可以用于替代某些匿名内部类对象，从而让程序更简洁，可读性更好。\u003c/p\u003e","title":"Day09 函数式编程、方法引用和String类"},{"content":"接口 Java提供了一个关键字interface定义出接口\nJDK8之前，接口只能定义常量和抽象方法\n接口中定义常量，可以省略public static final不写，默认会加上去\n接口中定义方法，可以省略public abstract不写，默认会加上去\n注意：接口不能创建对象\n接口是用采被类实现（implements）的，买现接口的类称为买现类， 一个类可以同时实现**多个**接口（多实现）。\n实现类实现了多个接口，必须重写完全部接口的全部抽象方法，否则这个类要定义为抽象类\n接口的好处 弥补了类单继承的不足，一个类同时可以实现多个接口，使类的角色更多，功能更强大。\n让程序可以面向接口编程，这样程序员就可以灵活方便的切换各种业务实现（更利于程序的解耦合）\nJDK8开始接口新增了3种方法\n1、默认方法（普通实例方法）：必须加default修饰，默认会用public修饰。\n2、私有方法（JDK 9开始才支持的）私有的实例方法。如何调用？使用接口中的其他实例方法来调用它（间接调用）\n3、静态方法默认会用public修饰。如何调用？只能使用当前接口名来调用。\n类必须extend在前，implement在后\n接口的注意事项 1、接口与接口可以多继承：一个接口可以同时继承多个接口［重点］。\n类与类：单继承 一个类只能继承一个直接父类\n类与接口：多实现，一个类可以同时实现多个接口。\n接口与接口：多继承，一个接口可以同时继承多个接口（用的是extends关键字）。\n2、一个接口继承多个接口，如果多个接口中存在方法签名冲突，则此时不支持多继承，也不支持多实现。\n4、一个类继承了父类，又同时实现了接口，如果父类中和接口中有同名的方法，实现类会优先用父类的。\n5、一个类实现了多个接口，如果多个接口中存在同名的默认方法，可以不冲突，这个类重写该方法即可。\n接口和抽象类的对比 相同点：\n1、都是抽象形式，都可以有抽象方法，都**不能创建对象****。**\n2、都是派生子类形式，抽象类是被子类继承使用，接口是被实现类实现。\n3、一个类继承抽象类，或者实现接口，都必须重写完他们的抽象方法，否则自己要成为抽象类或者报错！\n4、都能支持的多态，都能够实现解耦合。\n不同点：\n1、抽象类中可以定义类的**全部普通成员****，接口只能定义常量，抽象方法（JDK8新增的三种方式）**\n2、抽象类只能被类**单继承，接口可以被类多实现****。**\n3、一个类继承抽象类就不能再继承其他类，一个类实现了接口还可以继承其他类或者实现其他接口。\n4、抽象类体现**模板思想****：更利于做父类，实现代码的复用性。最佳实践**\n5、接口更适合**做功能的解耦合****：解耦合性更强更灵活。 最佳实践**\n代码块 代码块是类的5大成分之一（成员变量、构造器、方法、代码块、内部类）\n静态代码块 格式：static{}\n特点：类加载时自动执行，由于类只会加载一次，所以静态代码块也只会执行一次。\n作用：完成类的初始化，例如：对静态变量的初始化赋值。\n比如说给静态数组赋值\nArrarys.toString(数组名) //返回数组的内容\n实例代码块： 格式：{}\n特点：属于对象，每次创建对象时，执行实例代码块，并在构造器前执行。\n作用：和构造器一样，都是用来完成对象的初始化的例如：对实例变量进行初始化赋值。\n内部类 如果一个类定义在另一个类的内部，这个类就是内部类。\n场景：当一个类的内部，包含了一个完整的事物，且这个事物没有必要单独设计时，就可以把这个事物设计成内部类。\n成员内部类 就是类中的一个普通成员，类似前面我们学过的普通的成员变量、成员方法。\n成员内部类：无stati修饰，属于外部类的对象持有的。\n外部类名.内部类名 对象名=new 外部类(\u0026hellip;).new 内部类(..)；\n成员内部类中访问其他成员的特点：\n1、成员内部类种可以直接访问外部类的实例成员、静态成员。\n2、成员内部类的实例方法中，可以直接拿到当前外部类对象，格式是：外部类名.this。\nclass OuterClass { private String outerField = \u0026#34;Outer Field\u0026#34;; class InnerClass { private String innerField = \u0026#34;Inner Field\u0026#34;; public void display() { // 访问内部类的成员 System.out.println(innerField); // 访问外部类的成员 外部类名.this System.out.println(OuterClass.this.outerField); } } } public class Test { public static void main(String[] args) { OuterClass outer = new OuterClass(); OuterClass.InnerClass inner = outer.new InnerClass(); inner.display(); } } 静态内部类 有static修饰的内部类，属于外部类自己持有。\n外部类名.内部类名 对象名=new 外部类.内部类(..)；\nOuter.Inner in = new Outer.Inner() ；\n可以直接访问外部类的静态成员，不能直接访问外部类的实例成员。\n匿名内部类 是一种特殊的局部内部类；\n所谓匿名：指的是程序员不需要为这个类声明名字，默认有个隐藏的名字。\n特点：匿名内部类本质就是一个子类，并会立即创建出一个子类对象。\n作用：用于更方便的创建一个子类对象。\n匿名内部类实际上是有名字：外部类名$编号.class\n匿名内部类在开发中的常见形式\n通常作为一个对象参数传输给方法。\n需求：学生，老师要参加游泳比赛。\n开发中不是我们要主动去写匿名内部类，而是用别人的功能的时候，别人可以让我们写一个匿名内部类吗，我们才会写！\npublic static void sort(T[] a, Comparator\u0026lt;T\u0026gt; c) 参数一：需要排序的数组 参数二： 需要给sort声明一个Comparator比较器对象（指定排序的规则） sort方法会调用匿名内部类对象的compare 方法 对数组中的学生对象进行两两比较从而实现排序 指定排序规则： 如果你认为左边对象 大于 右边对象 那么返回正整数。 如果你认为左边对象 小于 右边对象 那么返回负整数。 如果两边相等那么返回0。 // 调用排序的函数，用匿名内部类的方式实现 Arrays.sort(students, new Comparator\u0026lt;Student\u0026gt;() { @Override public int compare(Student o1, Student o2) { //规则是左边大于右边，返回正整数 // 左边小于右边，返回负整数 // 左边等于右边，返回0 // if(o1.getHight()\u0026gt;o2.getHight()){ // return 1; // }else if(o1.getHight()\u0026lt;o2.getHight()){ // return -1; // }else { // return 0; // } return (int) (o2.getHight()-o1.getHight()); } }); ","permalink":"https://wqnm1gb.github.io/posts/day08-%E6%8E%A5%E5%8F%A3%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/","summary":"\u003ch2 id=\"接口\"\u003e接口\u003c/h2\u003e\n\u003cp\u003eJava提供了一个关键字interface定义出接口\u003c/p\u003e\n\u003cp\u003eJDK8之前，接口只能定义常量和抽象方法\u003c/p\u003e\n\u003cp\u003e接口中定义常量，可以省略public static final不写，默认会加上去\u003c/p\u003e","title":"Day08 接口和面向对象编程"},{"content":"多态 有对象多态，行为多态\n编译看左，运行看右\n多态的前提 有继承/实现关系，存在父类引用子类对象，存在方法重写\n使用多态的好处 1、在多态形态下，右边对象是解耦合的，便于扩展和维护\n2、定义方法的时候，使用父类类型的形参，可以接收一切子类对象，扩展性更强，更便利\n多态产生的问题 不能调用子类独有的行为\n多态下的类型转换 可以解决多态下调用独有功能\n自动类型转换：父类 变量名 = new 子类();\nPeople p = new Teacher();\n强制类型转换：子类 变量名 = (子类)父类变量;\nTeacher t = (Teacher) p;\n注意事项 1、存在继承/实现关系就可以在编译阶段进行强制类型转换，编译阶段不会报错。\n2、运行时，如果发现对象的真实类型与强转后的类型**不同****，就会报类型转换异常（ClassCastException）的错误出来。**\n强制转换前，Java建议先判断对象的真实类型\np instanceof Student 会返回TRUE或FALSE\nfinal关键字 1、修饰类：该类称为最终类，不能再被继承（工具类）\n2、修饰方法：该方法称为最终方法，特点是不能被重写（下边的模板方法的设计模式）\n3、修饰变量：该变量有且仅能被赋值一次，第二次赋值会报错\n变量的类型\na.成员变量：\n静态成员变量\n实例成员变量\nb.局部变量\n使用final修饰后\na.成员变量：\n静态成员变量：这个变量今后被称为常量，可以记住一个固定值，并且在程序中不能修改了，通常这个值作为系统的配置信息（常量的名称建议全部大写，多个单词用下划线分隔）\n实例成员变量：一般没有意义\nb.局部变量\n注意事项\nfinal修饰**基本类型**的变量，变量存储的数据不能被改变。\nfinal修饰**引用类型的变量，变量存储的地址不能被改变，但地址所指向对象的内容是**可以被改变的。\nstatic和final的区别 final修饰的变量是不能再修改的\nstatic修饰的变量只强调加载一份，可以再修改\n常量 使用了 static final 修饰的成员变量就被称为常量.\n作用：常用于记录系统的配置信息。\n使用常量：代码可读性更好，可维护性也更好。\n程序编译后，常量会被“宏替换”：出现常量的地方全部会被替换成其记住的字面量，这样可以保证使用常量和直接用字面量的**性能是一样的****。（编译后的文件是.class文件，去out文件夹里边找）**\n单例类（设计模式） 什么是设计模式\n一个问题通常有n种解法，其中肯定有一种解法是最优的，这个最优的解法被人总结出来了，称之为设计模式。\n怎么学设计模式\n1、解决了什么问题 2、怎么写\n单例模式\n作用：确保某个类只能创建一个对象\n实现步骤\n1、把类的构造器私有化（确保单例类在外边不能创建太多的对象，单例才有了可能性）\n2、定义一个类变量记住类的一个对象\n3、定义一个类方法，返回对象\n饿汉式单例：用对象时，对象已经创建好了\n懒汉式单例：用对象时，才开始创建对象\n枚举类 枚举类是一种特殊的类\n枚举类的写法\n修饰符 enum 枚举类名{ 名称1,名称2,名称3; 其他成员... } 1、枚举都是**最终类****，不可以被继承，枚举类都是继承java.lang.Enum类的。**\n2、枚举类的第一行只能罗列一些名称，这些名称都是常量，并且每个常量会记住枚举类的一个对象。\n**3、枚举类的构造器都是私有的（写不写都只能是私有的），因此，枚举类对外不能创建对象。所以枚举类是多例模式 **\n4、编译器为枚举类新增了几个方法。\n枚举适合做信息的标志和分类\n抽象类 在Java中有一个关键字叫：abstract，它就是抽象的意思，可以用它修饰类、成员方法。\nabstract修饰类，这个类就是抽象类。\nabstract修饰方法，这个方法就是抽象方法（只能有方法签名，不能有方法体）\n抽象类的特点：\n1、抽象类中不一定要有抽象方法，有抽象方法的类必须是抽象类。\n2、类有的成员：成员变量、方法、构造器，抽象类都可以有。\n3、****抽象类最主要的特点：抽象类不能创建对象，仅作为一种特殊的父类，让子类继承并实现。\n抽象类的使命就是被继承\n4、一个类继承抽象类，必须重写完抽象类的全部抽象方法，否则这个类也必须定义成抽象类。\n**抽象方法不能使用private修饰 **\n抽象类的好处 父类知道每个子类都要做某个行为，但每个子类要做的情况不一样，父类就定义成抽象方法，交给子类去重写实现， 我们设计这样的抽象类，就是为了更好的支持多态（原因是如果不用抽象类定义方法，那么会多写无用的代码，如果不写，会无法实现多态）。\n模板方法设计模式 提供一个方法作为完成某类功能的模板，模板方法封装了每个实现步骤，但允许子类提供特定步骤的实现。\n模板方法设计模式可以：提高代码的复用、并简化子类设计。\n写法\n1、定义一个抽象类。\n2、在里面定义2个方法\n3、一个是模板方法：把共同的实现步骤放里面去。\n4、一个是抽象方法：不确定的实现步骤，交给具体的子类来完成。\n建议使用final关键字修饰模板方法，为什么？\n模板方法是给子类直接使用的，不能被子类重写。一旦子类重写了模板方法，模板方法就失效了。\n","permalink":"https://wqnm1gb.github.io/posts/day07-%E5%A4%9A%E6%80%81%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/","summary":"\u003ch2 id=\"多态\"\u003e多态\u003c/h2\u003e\n\u003cp\u003e有对象多态，行为多态\u003c/p\u003e\n\u003cp\u003e\u003c!-- raw HTML omitted --\u003e编译看左，运行看右\u003c!-- raw HTML omitted --\u003e\u003c/p\u003e\n\u003ch3 id=\"多态的前提\"\u003e多态的前提\u003c/h3\u003e\n\u003cp\u003e有\u003c!-- raw HTML omitted --\u003e继承/实现\u003c!-- raw HTML omitted --\u003e关系，存在父类引用子类对象，存在\u003c!-- raw HTML omitted --\u003e方法重写\u003c!-- raw HTML omitted --\u003e\u003c/p\u003e","title":"Day07 多态和面向对象编程"},{"content":" 不仅会退出循环，还会结束整个方法的执行\n比如说匹配id的时候，找到id就直接退出方法，没找到id的话在循环语句后边还会有一个没找到id的提示\n子类能继承父类的非私有成员（成员变量，成员方法）如果定义的变量是私有的，那么能继承公有的get，set方法\n子类对象是由子类和父类多张设计图共同创建出来的对象，所以子类对象是完整的\nprivate 只能本类 缺省 本类，同一个包中的类 protected 本类，同一个包中的类，子孙类中 public 任意位置 private\u0026lt;缺省\u0026lt;protected\u0026lt;public\n**java为什么不支持多继承 **\njava中的祖宗类object\njava中的所有类，要么直接继承object，要么默认继承object，要么间接继承object\n如果子类中，出现了重名的成员，会优先使用子类的，如果此时一定要使用父类的，需要加上super关键字\nJava的多个类中有且仅有一个可以用public修饰\n重写的时候会加上 @Override 在上边，这是方法重写的校验注解（标志），要求方法名称和形参列表必须与被重写的方法一致，否则报错\n优点：更安全，更易读\n注意事项\n1、子类方法重写时候，访问权限一定要大于等于父类方法的权限（public\u0026gt;protected\u0026gt;缺省）\n2、重写方法的返回值类型，必须与父类的返回值类型一样或者范围更小\n3、私有方法，静态方法不能被重写，如果重写会报错（原因是子类只能继承非私有的成员，所以不能重写）\n直接输出对象，会调用对象的toString()方法，返回对象的地址信息\n具体是调用父类的有参还是无参由自己决定，如果不管，默认调用无参，如果没有无参，需要自己写一个有参\n如何实现调用父类的构造器的？\n默认情况下，子类构造器的第一行都是super();（写不写都有），会调用父类的无参构造器\n如果父类没有无参构造器，则子类构造器的第一行必须手写一个super()，去指定调用父类的有参构造器\nthis调用本类中的兄弟构造器\nthis的作用是，在构造器中调用本类的其他构造器\n注意，super()和this()必须写在构造器的第一行，而且两者不能同时出现\npublic class Person { private String name; private int age; // 第一个构造器 public Person(String name) { this(name, 20); // 调用第二个构造器 } // 第二个构造器 public Person(String name, int age) { this.name = name; this.age = age; } // 其他方法 public void display() { System.out.println(\u0026#34;Name: \u0026#34; + name + \u0026#34;, Age: \u0026#34; + age); } public static void main(String[] args) { Person p1 = new Person(\u0026#34;Alice\u0026#34;); p1.display(); // 输出: Name: Alice, Age: 20 Person p2 = new Person(\u0026#34;Bob\u0026#34;, 30); p2.display(); // 输出: Name: Bob, Age: 30 } } ","permalink":"https://wqnm1gb.github.io/posts/day06-%E7%BB%A7%E6%89%BF/","summary":"\u003c!-- raw HTML omitted --\u003e\n\u003cp\u003e不仅会退出循环，还会\u003c!-- raw HTML omitted --\u003e结束整个方法的执行\u003c!-- raw HTML omitted --\u003e\u003c/p\u003e\n\u003cp\u003e比如说匹配id的时候，找到id就直接退出方法，没找到id的话在循环语句后边还会有一个没找到id的提示\u003c/p\u003e","title":"Day06 继承"},{"content":"","permalink":"https://wqnm1gb.github.io/posts/my-new-post/","summary":"","title":"My New Post"},{"content":"对象 对象是一种特殊的数据结构，可以用来记住一个事物的数据，从而代表该事物\n1、先设计一个对象的模板，也就是对象的设计图：类\n2、通过new关键字，每new一次就得到一个新的对象\n内存分成了栈内存，堆内存和方法区\n方法区存放类文件\nnew出来的东西叫做对象，会放在堆里边\n方法需要使用的时候，会被掉到栈内存中\n设计对象的关键就是设计类，对象的模板\n构造器 创建对象的时候，对象会自动的调用构造器\n常见应用场景\n构造器的作用： 创建对象时，同时完成对对象成员变量（属性）的初始化赋值、\n//构造器的语法 class Student{ public Student(){ //名字必须要和类名相同，可以带参数也可以不带参数，没有返回值 } } 构造器的注意事项 1、类默认就带了一个无参构造器\n2、如果类定义了有参构造器，类默认的无参构造器就没有了，此时如果还想用无参构造器，就要自己手写一个无参构造器\nthis关键字 this就是一个变量，可以用在方法中，来拿到当前对象（拿的对象地址）\n哪个对象调用这个方法，this就拿到哪个对象\n**this对象主要用来解决：****变量名称冲突**的问题\n成员变量与方法内部变量的名称一样的时候，导致的命名冲突的问题\n封装 面向对象的三大特征：封装，继承，多态\n类，方法就是一种封装\n封装的设计要求\n合理隐藏，合理暴露\n如何隐藏：使用private关键字进行修饰成员变量，就只能在本类中被直接访问，其他任何地方不能直接访问\n如何暴露： 使用public修饰的get和set方法合理暴露成员变量的取值和\nJavabean（实体类） 是一种特殊类，满足下列要求\n1、类中的成员变量全是私有的，并且提供public修饰的getter和setter方法\n2、需要提供一个无参数的构造器，有参数的可选\n实体类的基本作用：创建他的新对象，存取数据（封装数据）\n实体类的应用场景：\n实体类的对象只负责数据的存取，而不负责数据的处理，数据的处理交给其他类的对象来完成，已实现数据和业务处理相分离\nstatic关键字 static修饰变量 可以用来修饰成员变量和成员方法\n类在运行的时候只会被加载一次\n成员变量按照有无static修饰可以分成两种：\n1、静态变量（类变量）：有static修饰属于类，在计算机中只有一份，会被全部对象共享，以最后的改动为准\n2、实例变量（对象的变量）（实例就是对象，对象就是实例（实例化之后就会占用内存） ，类是比他们高一个等级的抽象概念（不占用内存））：无static修饰，属于每个对象的\n推荐访问静态变量的方式\n类名.静态变量（推荐）\n实例名.静态变量（不推荐）\n静态变量的应用场景\n**如果某个数据只需要一份，且希望能够被共享（访问、修改），则该数据可以定义成静态变量来记住 **\n同一个类中，访问静态成员，可以省略类名不写\nstatic修饰方法 静态方法：有static修饰的成员方法，属于类持有\n实例方法：无static修饰的成员方法，属于对象\n如果这个方法只是为了做一个功能并且不需要直接访问对象的数据，这个方法直接定义为静态方法\n如果这个方法是对象的行为，需要访问对象的数据，这个方法必须定义为实例方法\n常见应用场景：做工具类，工具类中的所有方法都是一些静态方法，每一个方法来完成一个功能\n使用工具类的好处：提高代码复用，调用方便，提高了开发效率，不会占用内存\n工具类没有必要创建对象，可以把构造器进行私有化\npublic class Tools{ private Tools(){ //别人无法创建这个类 } } public修饰和没有关键字修饰（只能用这两种修饰符来修饰类） public修饰符 类级别: 如果一个类被声明为 public，它可以被任何地方访问，无论是在同一个包内还是其他包中，只要导入了该类所在的包。\n方法/字段级别: 如果类的成员（方法或字段）被声明为 public，那么任何类都可以访问这些成员，无论它们位于哪个包。\n没有修饰符（Package-private） **类级别: **如果一个类没有使用任何修饰符（即默认情况下），它只能在同一个包内访问。其他包中的类无法访问这个类，即使它们导入了该包。\n方法/字段级别: 如果类中的方法或字段没有使用访问修饰符，它们只能在同一个包内访问，而不能被其他包中的类访问。\n静态方法，实例方法的注意事项 1、静态方法中可以**直接访问静态成员****， 不可以直接访问实例成员**\n2、实例方法中既可以直接访问静态成员，也可以直接访问实例成员\n3、实例方法中可以出现this关键字，静态方法中**不可以出现this关键字**\n","permalink":"https://wqnm1gb.github.io/posts/day05-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/","summary":"\u003ch2 id=\"对象\"\u003e对象\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e对象是一种特殊的数据结构，可以用来记住一个事物的数据，从而代表该事物\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e1、先设计一个对象的模板，也就是对象的设计图：类\u003c/p\u003e\n\u003cp\u003e2、通过new关键字，每new一次就得到一个新的对象\u003c/p\u003e","title":"Day05 面向对象编程"},{"content":" ","permalink":"https://wqnm1gb.github.io/posts/testpicture/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://cdn.nlark.com/yuque/0/2024/png/28219979/1728611073038-cdcb6289-b485-4060-9727-8c3732d22bfe.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/image.png\" alt=\"\"  /\u003e\n\u003c/p\u003e","title":"testPicture"},{"content":"无限循环 无限循环下边不能再写其他的代码了，因为执行不到了\n//for格式的无限循环 for(;;){ } //while格式的无限循环 while(true){ } continue和break continue：跳过本次循环，继续执行下次循环\nbreak：结束整个循环\nRandom类 使用步骤：\nimport java.util.Random; Random r = new Random(); int num = r.nextInt(随机数范围); int num = r.nextInt(100);//0~99内取值 //生成任意随机数的方法 //例如我要生成1~100的随机数 //先把左边的范围变成0，然后通过加法补上 //例如要生成1~100之间的随机数 import java.util.Random; Random r = new Random(); //首先生成0~99的数字，然后再+1，变成1~100 int num = r.nextInt(100)+1; 随机数的范围，包头不包尾，包左不包右\n0-100 包括0但是不包括100\n数组 数组：是一种容器，可以存储同种数据类型的多个值\n完整格式：数据类型[] 数组名 = new 数据类型[]{元素1,元素2,元素3\u0026hellip;};\nint[] array = new int[]{11,22,33} //简化格式 int[] arrary = {11,22,33}; array.length可以快速的获取数组的长度\n二维数组中的每一个数据都是一个一维数组\nfor-each循环 public class TestArray { public static void main(String[] args) { double[] myList = {1.9, 2.9, 3.4, 3.5}; // 打印所有数组元素 for (double element: myList) { System.out.println(element); } } } 数组的动态初始化和静态初始化 静态初始化：初始化的时候直接赋值\n动态初始化：初始化的时候只指定数组的长度，由系统为数组分配初始值\nint[] array = new int[3]; 数组默认初始化值的规律\n1、整数类型：默认初始化值是0\n2、小数类型：默认初始化值是0.0\n3、字符类型：默认初始化值是\u0026rsquo;/u0000\u0026rsquo; 显示出来是一个空格\n4、布尔类型：默认初始化值是FALSE\n5、引用数据类型：默认初始化值是null\n换行输出和不换行输出 System.out.print(\u0026#34;这是不换行输出\u0026#34;); System.out.println(\u0026#34;这是换行输出\u0026#34;); 拆分数字 12345这个四位数\n拆分 12345%10=5 12345/10=1234 1234%10=4 1234/10=123 123%10=3 123/10=12 12%10=2 12/10=1 1%10=1 1/10=0 //循环结束 组合 //组合是从高位向低位组合，比如说给出的是1，2，3，4这样的顺序 sum=0; sum = 1 + sum*10; //sum=1 sum = 2 + sum*10;//sum=12 sum = 3 + sum*10//sum=123 方法 方法：是程序中最小的执行单元\n要么全都一起执行，要么全都不执行\n要先定义后调用\n方法的定义和调用 无参数无返回值的方法 定义： public static void 方法名(){ 方法体; } 调用： 方法名(); 带参数无返回值的方法 定义： public static void 方法名(类型 参数1,类型 参数2，,...){ //形参 方法体; } 调用： 方法名(参数1,参数2); //实参 带参数带返回值的方法 定义： public static 返回值类型 方法名(类型 参数1,类型 参数2，,...){ //形参 方法体; return 返回值; } 调用： 直接调用 方法名(参数1,参数2); //实参 赋值调用 整数类型 变量名= 方法名（实参）; 输出调用 System.out.println(方法名(实参)); ","permalink":"https://wqnm1gb.github.io/posts/day04-%E6%95%B0%E7%BB%84%E5%92%8C%E6%96%B9%E6%B3%95/","summary":"\u003ch2 id=\"无限循环\"\u003e无限循环\u003c/h2\u003e\n\u003cp\u003e无限循环下边不能再写其他的代码了，因为执行不到了\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e//for格式的无限循环\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003efor\u003c/span\u003e\u003cspan class=\"p\"\u003e(;;){\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"c1\"\u003e//while格式的无限循环\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003ewhile\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kc\"\u003etrue\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"continue和break\"\u003econtinue和break\u003c/h2\u003e\n\u003cp\u003econtinue：跳过本次循环，继续执行下次循环\u003c/p\u003e\n\u003cp\u003ebreak：结束整个循环\u003c/p\u003e\n\u003ch2 id=\"random类\"\u003eRandom类\u003c/h2\u003e\n\u003cp\u003e使用步骤：\u003c/p\u003e","title":"Day04 数组和方法"},{"content":"if的注意点 1、在语句中，如果只有一句代码，那么大括号可以省略不写\nint a = 100; //这不算是一句代码，算是两句代码，一句是定义变量a，另一句是赋值 2、如果对一个布尔类型的变量进行判断，不要使用==号，直接把变量写在小括号中\nswitch语句 switch (表达式){ case 值1: //case后边的值只能是字面量，不能是变量 语句体1; break; case 值2: 语句体2; break; ... default: 语句体n+1; break; } default可以省略，语法不会有问题，但是不建议省略，default可以放在程序的任意位置\ncase穿透，语句体中没有写break导致的\n如果匹配上了，就会执行对应的语句体，如果此时发现了break，那么结束switch语句，如果没有发现break，那么程序就会继续执行下一个case语句，一直到遇到break或者右大括号为止\n如果多个case的语句体重复了，那么我们考虑用case穿透去简化代码\nif else一般是对范围的判断\nswitch 把有限个数据一一列举出来，让我们任选其一\n循环语句 100.fori 可以快速的写出循环100次的\nfor和while的区别 for循环中，控制循环的变量（变量i），归属于for循环的语法结构中，在for循环结束之后，就不能再次访问了（但是改写之后，可以改变这个规则）\nwhile循环中，控制循环的变量（变量i），不归属于while的循环结构中，在while循环结束之后，该变量还能继续访问\nfor循环一般知道循环的次数和范围\nwhile循环不知道次数和范围，但是知道结束条件\n","permalink":"https://wqnm1gb.github.io/posts/day03-%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/","summary":"\u003ch2 id=\"if的注意点\"\u003eif的注意点\u003c/h2\u003e\n\u003cp\u003e1、在语句中，如果只有一句代码，那么大括号可以省略不写\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e100\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"c1\"\u003e//这不算是一句代码，算是两句代码，一句是定义变量a，另一句是赋值\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e2、如果对一个布尔类型的变量进行判断，不要使用==号，直接把变量写在小括号中\u003c/p\u003e\n\u003ch2 id=\"switch语句\"\u003eswitch语句\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eswitch\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003e表达式\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"k\"\u003ecase\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e值1\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e         \u003c/span\u003e\u003cspan class=\"c1\"\u003e//case后边的值只能是字面量，不能是变量\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"n\"\u003e语句体1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003ebreak\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"k\"\u003ecase\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e值2\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"n\"\u003e语句体2\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003ebreak\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e...\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"k\"\u003edefault\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"n\"\u003e语句体n\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"n\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003ebreak\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003edefault可以省略，语法不会有问题，但是不建议省略，default可以放在程序的任意位置\u003c/p\u003e","title":"Day03 循环语句"},{"content":" 1、基本数据类型\n数据类型 关键字 整数 byte 1 short 2 int 4 long 8在数据值后边加一个L作为后缀，建议使用大写的L 浮点数 float 4数据值后边也需要加一个F作为后缀 double 8 字符 char 2 布尔 boolean 1 整数和小数取值范围大小关系：\n2、引用数据类型\n之后补充\n硬性要求：1、由数字，字母，下划线和美元符号($)组成 2、不能以数字开头 3、不能是关键字 4、区分大小写\n软性建议：\n小驼峰命名法：方法、变量\n1、标识符是一个单词的时候，全部小写\n2、标识符由多个单词组成的时候，第一个单词首字母小写，其他单词首字母大写\n大坨峰命名方法：类名\n1、标识符是一个单词的时候，首字母大写\n2、标识符由多个单词组成的时候，每个单词首字母大写\nproject（项目）\nmodule（模块）\npackage（包）\nclass（类）\n加，减，乘，除，取模\n在代码中，如果有小数参与运算，结果可能不精确\n整数参与计算，结果只能得到整数\n1.1小的会先提升为大的，在进行运算\n1.2byte，short和char三种数据类型在进行运算的时候，都会直接先提升为int，然后再进行运算\nbyte a = 10; byte b = 20; c = a + b;//此时的c是int类型 适用于规则1.2 取值范围\nbyte \u0026lt; short \u0026lt; int \u0026lt; long \u0026lt; float \u0026lt;double\n2、强制转换，取值范围大的变成取值范围小的\n要强制转换的是最终的结果\n如果我想把c定义为byte型\nbyte c = a + b //报错 byte c = (byte)a + b //报错，相当于强制转换a byte c = (byte)a + (byte)b //报错，相当于强制转换a和b，并不是转换最后的结果 byte c = (byte)(a + b) //正确 在+的过程中，只要有字符串参与，做的都会是拼接的操作\n连续+从左到右依次+\n+=，-=，*=，/=，%=底层都隐藏了一个强制类型转换\nshort s = 1; s + = 1; //等同于 s = (short)(s+1); 比如第一个不满足了就直接不满足，右边的语句就不会运行了\n|| 短路非 结果与|相同，但是有短路效果\n比如第一个满足了就全满足，右边的语句就不会运行了\n注意事项\n\u0026amp;|，无论左边是TRUE还是FALSE，右边都要执行\n\u0026amp;\u0026amp; || ，如果左边能确定表达式的结果，右边不执行\n关系表达式？表达式1:表达式2\n如果关系表达式是真，那么就使用表达式1，如果为假，那就使用表达式2\n使用的时候的方法是，max = a\u0026gt;b?a:b //把a，b中的最大值赋给max\noption+command+L 会自动格式化代码\n","permalink":"https://wqnm1gb.github.io/posts/day02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/","summary":"\u003c!-- raw HTML omitted --\u003e\n\u003cp\u003e1、基本数据类型\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e数据类型\u003c/th\u003e\n          \u003cth\u003e关键字\u003c/th\u003e\n          \u003cth\u003e\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e整数\u003c/td\u003e\n          \u003ctd\u003ebyte\u003c/td\u003e\n          \u003ctd\u003e1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c/td\u003e\n          \u003ctd\u003eshort\u003c/td\u003e\n          \u003ctd\u003e2\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c/td\u003e\n          \u003ctd\u003eint\u003c/td\u003e\n          \u003ctd\u003e4\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c/td\u003e\n          \u003ctd\u003elong\u003c/td\u003e\n          \u003ctd\u003e8\u003c!-- raw HTML omitted --\u003e在数据值后边加一个L作为后缀，建议使用大写的L\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e浮点数\u003c/td\u003e\n          \u003ctd\u003efloat\u003c/td\u003e\n          \u003ctd\u003e4\u003c!-- raw HTML omitted --\u003e数据值后边也需要加一个F作为后缀\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c/td\u003e\n          \u003ctd\u003edouble\u003c/td\u003e\n          \u003ctd\u003e8\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e字符\u003c/td\u003e\n          \u003ctd\u003echar\u003c/td\u003e\n          \u003ctd\u003e2\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e布尔\u003c/td\u003e\n          \u003ctd\u003eboolean\u003c/td\u003e\n          \u003ctd\u003e1\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e整数和小数取值范围大小关系：\u003c/p\u003e","title":"Day02 数据类型和运算符"},{"content":"cmd默认操作的是用户命名的文件夹（C:\\users\\用户名）\n盘符名称 + : 能够切换到这个盘符\ndir 查询该目录下的所有文件\nwindow下的文件分隔符是\\ 注意与Linux下的/ 不同\ncls 是清屏命令\nexit 是关闭窗口命令\njava目录 bin中存放了各种工具命令\nJDK java的开发工具 里边包含了 JVM+核心类库+开发工具\nJRE java的运行环境 里边包含了 JVM+核心类库+运行工具\n多行注释是 /* */\n文档注释是/** **/\nJava会先找到main语句，从main开始运行\njavac用于编译\njava用于运行\n类是Java最基本的组成单元\n空类型的null不能直接打印\n在打印的时候，把前边字符串的长度补齐到8，或者8的整数倍，最少补1个空格，最多补8个空格\n用处：打印类似表格数据的时候，让数据对齐\n2、变量名不允许被重复定义\n3、一条语句可以定义多个变量\n4、变量在使用之前一定要进行赋值\n5、变量的作用范围\n十进制：前边不加任何前缀\n八进制：代码中以0开头\n十六进制：代码中以0x开头\n","permalink":"https://wqnm1gb.github.io/posts/day01-java%E5%9F%BA%E7%A1%80/","summary":"\u003cp\u003ecmd默认操作的是用户命名的文件夹（C:\\users\\用户名）\u003c/p\u003e\n\u003cp\u003e盘符名称 + : 能够切换到这个盘符\u003c/p\u003e\n\u003cp\u003edir 查询该目录下的所有文件\u003c/p\u003e\n\u003cp\u003ewindow下的文件分隔符是\\ 注意与Linux下的/ 不同\u003c/p\u003e","title":"Day01 Java基础"},{"content":"Hello World！ ","permalink":"https://wqnm1gb.github.io/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","summary":"\u003ch1 id=\"hello-world\"\u003eHello World！\u003c/h1\u003e","title":"我的第一篇博客"},{"content":"MySQL的连接\n// 其中-h和-P是可选的，如果不指定，那么默认就是本机的3306端口 mysql [-h数据库服务器的IP地址 -P端口号] -u用户名 -p密码 MySQL数据模型 关系型数据库：建立在关系模型基础上，由多张相互连接的二维表组成的数据库。\n特点：\n• 使用表存储数据，格式统一，便于维护。\n• 使用SQL语言操作，标准统一，使用方便，可用于复杂查询。\n![](Day05 MySQL数据库.assets/1732496370686-7615238e-72a4-479d-adfd-d2c67467cfaf.png)\nSQL语句 SQL：一门操作关系型数据库的编程语言，定义操作所有关系型数据库的统一标准。\n分类：\n分类 全称 说明 DDL Data Definition Language 数据定义语言，用来定义数据库对象(数据库，表，字段) DML Data Manipulation Language 数据操作语言，用来对数据库表中的数据进行增删改 DQL Data Query Language 数据查询语言，用来查询数据库中表的记录 DCL Data Control Language 数据控制语言，用来创建数据库用户、控制数据库的访问权限 DDL-数据库 操作语法 -- 查询所有数据库 show databases; -- 查询当前数据库 select database(); -- 使用/切换数据库 use 数据库名; -- 创建数据库 create database [if not exists] 数据库名 [default charset utf8mb4]; -- 删除数据库 drop database [if exists] 数据库名; 上述语法中的database，也可以替换成 schema。如：create schema db01；MySQL8版本中，默认字符集为utf8mb4。\n在同一个数据库服务器中，数据库的名字不可以相同\nDDL-表结构 创建表的语法 create table tablename( 字段1 字段类型 [约束] [comment 字段1注释], ...... 字段2 字段类型 [约束] [comment 字段2注释] )[comment 表注释]; 约束：约束是作用于表中字段上的规则，用于限制存储在表中的数据。\n目的：保证数据库中数据的正确性、有效性和完整性。\n常见的约束 约束 描述 关键字 非空约束 限制该字段值不能为null not null 唯一约束 保证字段的所有数据都是唯一、不重复的 unique 主键约束 主键是一行数据的唯一标识，要求非空且唯一 primary key 默认约束 保存数据时，如果未指定该字段值，则采用默认值 default 外键约束 让两张表的数据建立连接，保证数据的一致性和完整性 foreign key 一张表中最多只能有一个主键，一个字段可以有多个约束，只需要在约束中用空格分开即可\n自动增长的关键字是auto_increment\n自动增长的主键指定了值是最大的，会从最大的值之后开始自动增长，避免从小的值开始增长遇到大的值之后重复\n数据类型 数值类型：\n类型 大小(byte) 有符号(SIGNED)范围 无符号(UNSIGNED)范围 描述 备注 tinyint 1 (-128，127) (0，255) 小整数值 smallint 2 (-32768，32767) (0，65535) 大整数值 mediumint 3 (-8388608，8388607) (0，16777215) 大整数值 int 4 (-2147483648，2147483647) (0，4294967295) 大整数值 bigint 8 (-2^63，2^63-1) (0，2^64-1) 极大整数值 float 4 (-3.402823466 E+38，3.402823466351 E+38) 0 和 (1.175494351 E-38，3.402823466 E+38) 单精度浮点数值 float(5,2)：5表示整个数字长度，2 表示小数位个数 double 8 (-1.7976931348623157 E+308，1.7976931348623157 E+308) 0 和 (2.2250738585072014 E-308，1.7976931348623157 E+308) 双精度浮点数值 double(5,2)：5表示整个数字长度，2 表示小数位个数 decimal 小数值(精度更高) decimal(5,2)：5表示整个数字长度，2 表示小数位个数 数值类型的选取原则: 在满足业务需求的前提下, 尽可能选择占用磁盘空间小的数据类型\n字符串类型：\n类型 大小 描述 char 0-255 bytes 定长字符串 varchar 0-65535 bytes 变长字符串 tinyblob 0-255 bytes 不超过255个字符的二进制数据 tinytext 0-255 bytes 短文本字符串 blob 0-65 535 bytes 二进制形式的长文本数据 text 0-65 535 bytes 长文本数据 mediumblob 0-16 777 215 bytes 二进制形式的中等长度文本数据 mediumtext 0-16 777 215 bytes 中等长度文本数据 longblob 0-4 294 967 295 bytes 二进制形式的极大文本数据 longtext 0-4 294 967 295 bytes 极大文本数据 char定长字符串，char(10) 存储A，也会占用10个空间，其他地方用空来占用\nblob存放二进制文件，音频视频等内容，但是一般用的比较少，一般用专门的文件存储系统来管理\ntext存放文本字符串\n校验最少字段（最少需要多少个字段），需要在前端进行校验，数据库能校验字段是不是超了\n日期类型：\n类型 大小****(byte) 范围 格式 描述 date 3 1000-01-01 至 9999-12-31 YYYY-MM-DD 日期值 time 3 -838:59:59 至 838:59:59 HH:MM:SS 时间值或持续时间 year 1 1901 至 2155 YYYY 年份值 datetime 8 1000-01-01 00:00:00 至 9999-12-31 23:59:59 YYYY-MM-DD HH:MM:SS 混合日期和时间值 timestamp 4 1970-01-01 00:00:01 至 2038-01-19 03:14:07 YYYY-MM-DD HH:MM:SS 混合日期和时间值，时间戳 timestamp存放到2038年为止，时间快到了，所以用的比较少\n-- 案例：设计员工表 create table emp( id int unsigned primary key auto_increment comment \u0026#39;id 主键\u0026#39;, username varchar(20) not null unique comment \u0026#39;用户名\u0026#39;, password varchar(32) default \u0026#39;123456\u0026#39; comment \u0026#39;密码\u0026#39;, name varchar(10) not null comment \u0026#39;姓名\u0026#39;, gender tinyint unsigned not null comment \u0026#39;性别 男：1 女：2\u0026#39;, phone char(11) not null unique comment \u0026#39;手机号码\u0026#39;, job tinyint unsigned comment \u0026#39;职位 1 班主任 2 讲师 3 学工主管 4 教研主管 5 咨询师\u0026#39;, salary int unsigned comment \u0026#39;薪资\u0026#39;, entry_date date comment \u0026#39;入职日期\u0026#39;, image varchar(255) comment \u0026#39;头像\u0026#39;, creat_time datetime comment \u0026#39;创建日期\u0026#39;, update_time datetime comment \u0026#39;更新日期\u0026#39; ) comment \u0026#39;员工表\u0026#39;; 表中一般都要有的基础字段\n基础字段（id，creat_time，update_time）\n密码一般设置成32字节是因为进行md5加密之后固定是32字节\n查询、修改、删除 show tables; -- 查询当前数据库的所有表 desc 表名; -- 查询表结构 show create table 表名; -- 查询建表语句 alter table 表名 add 字段名 类型(长度) [comment 注释] [约束]; -- 添加字段 alter table 表名 modify 字段名 新数据类型(长度); -- 修改字段类型 alter table 表名 change 旧字段名 新字段名 类型(长度) [comment 注释] [约束]; -- 修改字段名与字段类型 alter table 表名 drop column 字段名; -- 删除字段 alter table 表名 rename to 新表名; -- 修改表名 drop table [if exists] 表名; -- 删除表 删除之后，表中的数据也都会被删除 DML-对表中的数据记录进行增删改 insert语句 -- 指定字段添加数据 insert into 表名(字段名1, 字段名2) values (值1, 值2); -- 全部字段添加数据 insert into 表名 values (值1, 值2, ...); -- 批量添加数据（指定字段） insert into 表名 (字段名1, 字段名2) values (值1, 值2), (值1, 值2); -- 批量添加数据（全部字段） insert into 表名 values (值1, 值2, ...), (值1, 值2, ...); 主键如果会自增，在插入数据的时候可以给他一个null，这样在插入之后就会自增\n当前时间可以用自带的函数now()获取\n日期和字符串推荐用单引号括起来，但是使用双引号也是可以的\n• 插入数据时，指定的字段顺序需要与值的顺序是—对应的。\n• 字符串和日期型数据应该包含在引号中（单引号、双引号都可以）。\n• 插入的数据大小/长度，应该在字段的规定范围内。\nupdate语句 如果要更改多个字段，中间需要用,隔开，不是用的and\n-- 修改数据 update 表名 set 字段名1 = 值1 , 字段名2 = 值2 , .... [ where 条件 ] ; 修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表的所有数据\ndelete语句 -- 删除数据 delete from 表名 [where 条件]; DELETE 语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数据。\nDELETE 语句不能删除某一个字段的值（如果要操作，可以使用UPDATE，将该字段的值置为NULL），一次就要删一行的数据\nDQL-查询语句 完整的DQL语法：\n![](Day05 MySQL数据库.assets/1732669744154-b03c8b0b-8ba5-4005-9bda-1797c4a08bbd.png)\nDQL-基本查询 -- 查询多个字段 select 字段1,字段2,字段3 from 表名; -- 查询所有字段(通配符) select * from 表名; -- 为查询字段设置别名，as关键字可以省略 select 字段1 [as 别名1], 字段2 [as 别名2] from 表名; -- 去除重复记录 select distinct 字段列表 from 表名; 号代表查询所有字段，在实际开发中尽量少用（不直观、影响效率）。 把所有字段罗列出来的查询方法在项目中比较常用，因为效率比较高，*的话没那么常用\nas取别名的时候，有一种情况需要加引号，就是中间有空格，\u0026lsquo;姓 名\u0026rsquo;这种别名的时候需要加引号\nDQL-条件查询 -- 条件查询 select 字段列表 from 表名 where 条件列表 ; 比较运算符 功能 \u0026gt; 大于 \u0026gt;= 大于等于 \u0026laquo;/font\u0026gt; 小于 \u0026lt;= 小于等于 = 等于 \u0026lt;\u0026gt; 或 != 不等于 between \u0026hellip; and \u0026hellip; 在某个范围之内(含最小、最大值) in(\u0026hellip;) 在in之后的列表中的值，多选一 like 占位符 模糊匹配(_匹配单个字符, %匹配任意个字符0或者多个) is null 是null in(\u0026hellip;)多选一的关系，只要满足其中的一个，就是符合条件的\nbetween and 既包含最小值又包含最大值，and之前要写最小值，and之后写最大值\n%代表任意个字符，可以是0个也可以是多个\n逻辑运算符 功能 and 或 \u0026amp;\u0026amp; 并且 (多个条件同时成立) or 或 not 或 ! 非 , 不是 DQL-分组查询 聚合函数：将一列数据作为一个整体，进行纵向计算，所以里边的参数可以写的是列名\n函数 功能 count 统计数量 max 最大值 min 最小值 avg 平均值 sum 求和 所有的聚合函数**不参与null值**的统计\ncount(*)就是统计表中的总数据量\ncount(常量例如1) 表示的含义，就是说统计出来一条数据就会标识成为1，最后统计1的数量\n优先使用count(*)，底层做了优化，性能最高\n-- 分组查询 select 字段列表 from 表名 [where 条件列表] group by 分组字段名 [having 分组后过滤条件]; where与having的区别：\n1．执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤。\n2． 判断条件不同：where不能对聚合函数进行判断，而having可以。\n其他注意：\n1.分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义。\n注意：分组之后，select后的字段列表就不能随意再写了，能写的一般是分组字段+聚合函数\nwhere后不能接着聚合函数\n2.执行顺序：where \u0026gt; 聚合函数 \u0026gt;having。\nDQL-排序查询 -- 排序查询 select 字段列表 from 表名 [where 条件列表] [group by 分组字段名 having 分组后过滤条件] order by 排序字段 排序方式; 排序方式：升序（asc），降序（desc）；默认为升序asc，是可以不写的。\n如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序。\nDQL-分页查询 -- 排序查询 select 字段 from 表名 [where 条件] [group by 分组字段 having 过滤条件] [order by 排序字段] limit 起始索引,查询记录数; 说明：\n1.起始索引从0开始。\n2.分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT。\n3.如果起始索引为0，起始索引可以省略，直接简写为 limit 10。\n开发中传递进来的是页码\n起始索引 = （页码-1）*每页展示记录数\n","permalink":"https://wqnm1gb.github.io/posts/day05-mysql%E6%95%B0%E6%8D%AE%E5%BA%93/","summary":"\u003cp\u003eMySQL的连接\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-plain\" data-lang=\"plain\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e// 其中-h和-P是可选的，如果不指定，那么默认就是本机的3306端口\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003emysql [-h数据库服务器的IP地址 -P端口号] -u用户名 -p密码\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"mysql数据模型\"\u003eMySQL数据模型\u003c/h1\u003e\n\u003cp\u003e关系型数据库：建立在关系模型基础上，由多张相互连接的\u003c!-- raw HTML omitted --\u003e二维表\u003c!-- raw HTML omitted --\u003e组成的数据库。\u003c/p\u003e","title":""},{"content":"![](Day06 Java操作数据库.assets/1732677227599-0381eba1-2488-49b4-bc90-da0c210c5184.png)\nJDBC介绍 JDBC：（Java DataBase Connectivity），就是使用Java语言操作关系型数据库的一套API。\n![](Day06 Java操作数据库.assets/1732677291127-ec2b62db-0dd9-4bc3-975b-d5ecede913a0.png)\n![](Day06 Java操作数据库.assets/1732677303807-db1a055a-36a9-4140-a5d5-fa7476415b9a.png)\n本质：\n• sun公司官方定义的一套操作所有关系型数据库的规范，即接口。\n• 各个数据库厂商去实现这套接口，提供数据库驱动jar包。\n• 我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。\nJDBC入门程序 例子：更新数据库中的内容\n@Test public void testJdbc() throws Exception { // 1 注册驱动 这个是固定的 Class.forName(\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;); // 2 获取连接 String url = \u0026#34;jdbc:mysql://localhost:3306/web01\u0026#34;; String user = \u0026#34;root\u0026#34;; String password = \u0026#34;wsnbb1234\u0026#34;; Connection connection = DriverManager.getConnection(url, user, password); // 3 获取SQL语句执行对象 statement对象才能执行SQL语句 Statement statement = connection.createStatement(); // 4 执行SQL语句 这里边的i是用来收取影响的行数 int i =statement.executeUpdate(\u0026#34;update user set age = 25 where id = 1\u0026#34;); // 5 释放资源 statement.close(); connection.close(); } 注册驱动相当于告知应用程序是那一套jdbc的实现\nJDBC查询数据 需求：基于JDBC执行如下select语句，将查询结果封装到User对象中。\nSQL:select * from user where username = \u0026lsquo;daqiao\u0026rsquo;and password = \u0026lsquo;123456\u0026rsquo;\n执行查询语句之后会返回一个结果集对象：\nResultSet（结果集对象）：ResultSet rs = statement.executeQuery（）\nnext（）：将光标从当前位置向前移动一行，并判断当前行是否为有效行，返回值为boolean。 true：有效行，当前行有数据 false：无效行，当前行没有数据 getXxx（..）：获取数据，可以根据列的编号获取，也可以根据列名获取（推荐）。 while (resultSet.next()) { int id = resultSet.getInt(\u0026#34;id\u0026#34;); //...省略 } prepareStatement可以为占位符赋值的SQL语句执行对象\n占位符的起始是从1开始的\n@Test public void testQuery() throws Exception { // 获取连接 Connection conn = DriverManager.getConnection(\u0026#34;jdbc:mysql://localhost:3306/web01\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;wsnbb1234\u0026#34;); // 创建预编译的PreparedStatement对象 PreparedStatement pstmt = conn.prepareStatement(\u0026#34;SELECT * FROM user WHERE username = ? AND password = ?\u0026#34;); // 设置参数 pstmt.setString(1, \u0026#34;daqiao\u0026#34;); // 第一个问号对应的参数 pstmt.setString(2, \u0026#34;123456\u0026#34;); // 第二个问号对应的参数 // 执行查询 ResultSet rs = pstmt.executeQuery(); // 处理结果集 while (rs.next()) { int id = rs.getInt(\u0026#34;id\u0026#34;); String uName = rs.getString(\u0026#34;username\u0026#34;); String pwd = rs.getString(\u0026#34;password\u0026#34;); String name = rs.getString(\u0026#34;name\u0026#34;); int age = rs.getInt(\u0026#34;age\u0026#34;); System.out.println(\u0026#34;ID: \u0026#34; + id + \u0026#34;, Username: \u0026#34; + uName + \u0026#34;, Password: \u0026#34; + pwd + \u0026#34;, Name: \u0026#34; + name + \u0026#34;, Age: \u0026#34; + age); } // 关闭资源 rs.close(); pstmt.close(); conn.close(); } 预编译SQL 静态SQL（参数预编码）\nStatement statement = connection.createStatement(); int i = statement.executeUpdate(\u0026#34;update user set age = 25 where id = 1\u0026#34;); System.out.println(\u0026#34;SQL执行完毕, 影响的记录数为: \u0026#34; + i); 预编译SQL（参数动态传递）\nPreparedStatement pstmt = conn.prepareStatement(\u0026#34;SELECT * FROM user WHERE username = ? AND password = ?\u0026#34;); pstmt.setString(1, \u0026#34;daqiao\u0026#34;); pstmt.setString(2, \u0026#34;123456\u0026#34;); ResultSet resultSet = pstmt.executeQuery(); 优势 1、可以防止SQL注入，更安全\nSQL注入：通过控制输入来修改事先定义好的SQL语句，以达到执行代码对服务器进行攻击的方法。\n2、性能高\n![](Day06 Java操作数据库.assets/1732757223210-75979dc5-55c0-4caa-b258-b24206136703.png)\nMybatis Mybatis入门程序 配置连接信息\n#数据库访问的url地址 spring.datasource.url=jdbc:mysql://localhost:3306/web01 #数据库驱动类类名 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver #访问数据库-用户名 spring.datasource.username=root #访问数据库-密码 spring.datasource.password=wsnbb1234 编写Mybatis程序：编写Mybatis的持久层接口，定义SQL语句（注解）\n在创建出来的springboot工程中，在引导类所在包下，在创建一个包 mapper。\nUserMapper，这是一个持久层接口（Mybatis的持久层接口规范一般都叫 XxxMapper）。\nUserMapper接口的内容如下： 包下创建一个接口\nimport com.itheima.pojo.User; import org.apache.ibatis.annotations.Mapper; import org.apache.ibatis.annotations.Select; import java.util.List; @Mapper public interface UserMapper { /** * 查询全部 */ @Select(\u0026#34;select * from user\u0026#34;) public List\u0026lt;User\u0026gt; findAll(); } 注解说明：\n@Mapper注解：表示是mybatis中的Mapper接口 程序运行时，框架会自动生成接口的实现类对象（代理对象），并给交Spring的IOC容器管理\n@Select注解：代表的就是select查询，用于书写select查询语句 单元测试\n在创建出来的SpringBoot工程中，在src下的test目录下，已经自动帮我们创建好了测试类，并且在测试类上已经添加了注解 @SpringBootTest，代表该测试类已经与SpringBoot整合。\n该测试类在运行时，会自动通过引导类加载Spring的环境（IOC容器）。我们要测试那个bean对象，就可以直接通过@Autowired 注解直接将其注入进行，然后就可以测试了。\n这里一定要注意IOC容器的生效的地方，要想生效，还需要被组件扫描注解@ComponentScan扫描。\n该注解虽然没有显式配置，但是实际上已经包含在了启动类声明注解@SpringBootAppljcatjon 中，默认扫描的范围是启动类所在包及其子包。 @SpringBootTest class SpringbootMybatisQuickstartApplicationTests { @Autowired private UserMapper userMapper; @Test public void testFindAll(){ List\u0026lt;User\u0026gt; userList = userMapper.findAll(); for (User user : userList) { System.out.println(user); } } } 辅助配置-配置Mybatis的日志输出 默认情况下，在Mybatis中，SQL语句执行时，我们并看不到SQL语句的执行日志。加入如下配置，即可查看日志：\n#mybatis的配置\u000bmybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl JDBC vs Mybatis ![](Day06 Java操作数据库.assets/1732841446177-7ca42e21-ed2f-4a4e-9589-88812e46e40d.png)\nMybatis解决硬编码：把连接数据库的信息放置在单独的配置文件中，不用改java代码，改java代码需要重新编译，改配置文件不需要\nMybatis解决获取资源繁琐：自动会解析数据到对象中\nMybatis解决频繁连接，释放连接，资源浪费性能降低：用到了数据库连接池\n数据库连接池 数据库连接池是个容器，负责分配、管理数据库连接（Connection）。 它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个。 释放空闲时间超过最大空闲时间的连接，来避免因为没有释放连接而引起的数据库连接遗漏。（数据库连接池会检测客户端连接的空闲时间，如果空闲时间超过了规定的最大空闲时间，会让连接归还给数据库连接池，解决数据库连接遗漏的问题） 优势：\n资源重用 提升系统响应速度 避免数据库连接遗漏 ![](Day06 Java操作数据库.assets/1732843347805-8267c11a-4bd3-4f65-ab99-99658ff12b48.png) ![](Day06 Java操作数据库.assets/1732843364275-f9437458-33e4-4a19-81df-accbf68adb69.png)\n标准接口：DataSource\n官方（sun）提供的数据库连接池接口，由第三方组织实现此接口（一定要实现） 功能：获取连接 Connection getConnection（） throws SQLException； ![](Day06 Java操作数据库.assets/1732843501162-668384f1-3c64-4920-b832-b0aec3de3ee6.png)\n后两个是比较常用的\nDruid（德鲁伊）\nDruid连接池是阿里巴巴开源的数据库连接池项目 功能强大，性能优秀，是Java语言最好的数据库连接池之一 使用方法：\n在pro.xml中引入依赖\n\u0026lt;dependency\u0026gt; \u0026lt;!-- Druid连接池依赖 --\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;druid-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.19\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 在application.properties中配置数据库连接：\nspring.datasource.type=com.alibaba.druid.pool.DruidDataSource spring.datasource.druid.driver-class-name=com.mysql.cj.jdbc.Driver spring.datasource.druid.url=jdbc:mysql://localhost:3306/web spring.datasource.druid.username=root spring.datasource.druid.password=1234 Delete操作 Mapper接口：\n@Delete(\u0026#34;delete from user where id = #{id}\u0026#34;) public Integer deleteById(Integer id); DML语句执行完毕的返回值，表示该DML语句执行完毕影响的行数。\n里边的#{id}会用id来替换（名字要一样，并不是根据名字的，而是只有一个正好数目匹配上了）\n#{id}这个会被替换成? 符合预编译SQL的优势\n符号 说明 场景 优缺点 #{…} 占位符。执行时，会将#{…}替换为?，生成预编译SQL 参数值传递 安全、性能高 （推荐） ${…} 拼接符。直接将参数拼接在SQL语句中，存在SQL注入问题 表名、字段名动态设置时使用 不安全、性能低 ${\u0026hellip;}用的很少，是拼接的SQL\n@Delete(\u0026#34;delete from dept where id = #{id}\u0026#34;) @Select(\u0026#34;select id,name,score from ${tableName} order by ${sortField}\u0026#34;) Insert操作 Mapper接口：\n@Insert(\u0026#34;insert into user(username,password,name,age) values(#{username},#{password},#{name},#{age})\u0026#34;) public void insert(User user); 用$替换#可能会报错，原因是：将 \u0026lt;font style=\u0026quot;color:rgb(6, 6, 7);\u0026quot;\u0026gt;#{}\u0026lt;/font\u0026gt; 改为 \u0026lt;font style=\u0026quot;color:rgb(6, 6, 7);\u0026quot;\u0026gt;${}\u0026lt;/font\u0026gt; 后，MyBatis 不再使用预处理语句，而是直接将参数值拼接到 SQL 语句中，这可能会导致 SQL语法错误\n使用对象的方式插入，里边写的是对象的属性名而不是表中字段名\n主键是自增的，如果之前的号码使用过，即使是删除了（4，5），这些号码（4，5）还是不会重复使用，会从一个没用过的开始自增（6）\nUpdate操作 Mapper接口：\n@Update(\u0026#34;update user set username=#{username}, password=#{password}, name=#{name}, age=#{age} where id=#{id}\u0026#34;) public void update(User user); Select操作 Mapper接口：\n@Select(\u0026#34;select * from user where username=#{username} and password=#{password}\u0026#34;) public User findByUsernameAndPassword(@Param(\u0026#34;username\u0026#34;) String username, @Param(\u0026#34;password\u0026#34;) String password); 不止一个参数的时候，需要为形参取名字用@Param\n@Param注解的作用是为接口的方法形参起名字的\n#{}里写的是为Param为这个参数起的名字\n基于springboot官方骨架创建出来的项目在pom.xml里边都会有一个父工程，接口编译时会保留方法形参名， @Param注解可以省略\n**查询操作有返回值，一定要把返回值接收 **\nXML映射配置 在Mybatis中，既可以通过注解配置SQL语句，也可以通过XML配置文件配置SQL语句。\n默认规则：\nXML映射文件的名称与Mapper接口名称一致，并且将XML映射文件和Mapper接口放置在相同包下（同包同名）。 XML映射文件的namespace属性为Mapper接口全限定名一致。 XML映射文件中Sq1语句的id与Mapper 接口中的方法名一致，并保持返回类型一致。 ![](Day06 Java操作数据库.assets/1733100300040-60f8f3ac-a404-4a09-b1f2-5b9ac4377303-0190093.png)![](Day06 Java操作数据库.assets/1733100491981-0d071354-9a8d-4809-b599-300d5d616aae.png)\nxml中的id属性值是这个SQL语句的唯一标识，并且属性值要和方法名保持一致\nresources下的目录不能用.分隔，因为不是包，只是普通的目录需要用/分隔 编写xml文件中的映射文件，xml映射文件中的dtd约束，直接从mybatis官网复制即可; 或者直接AI生成\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;https://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;\u0026#34;\u0026gt; \u0026lt;/mapper\u0026gt; result type 指的是查询返回的单条语句往哪里进行封装，是单条，不是List集合，而是User对象\n二选一定义，要么基于注解，要么基于xml\n使用Mybatis的注解，主要是来完成一些简单的增删改查功能。如果需要实现复杂的SQL功能，建议使用XML来配置映射语句。\nSpringBoot配置文件 SpringBoot项目提供了多种属性配置方式（properties、yaml、yml）\n![](Day06 Java操作数据库.assets/1733101274503-88c11b89-3279-4ac1-ae26-77fcef871700.png)\n一般使用yml格式\nyml配置文件 格式：\n数值前边必须有空格，作为分隔符 使用缩进表示层级关系，缩进时，不允许使用Tab键，只能用空格（idea中会自动将Tab转换为空格） 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可 ＃ 表示注释，从这个字符一直到行尾，都会被解析器忽略 在yml格式的配置文件中，如果配置项的值是以0开头的，值需要使用\u0026rsquo;\u0026lsquo;引起来，因为以0开头在yml中表示8进制的数据。\n定义对象/Map集合：\nuser: name: 张三 age: 18 password: 123456 定义数组/List/Set集合：\nhobby: - java - game - sport spring: application: name: springboot-mybatis-quickstar datasource: type: com.alibaba.druid.pool.DruidDataSource url: jdbc:mysql://localhost:3306/web01 username: root password: wsnbb1234 mybatis: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl ","permalink":"https://wqnm1gb.github.io/posts/day06-java%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/","summary":"\u003cp\u003e![](Day06 Java操作数据库.assets/1732677227599-0381eba1-2488-49b4-bc90-da0c210c5184.png)\u003c/p\u003e","title":""},{"content":"个人学习博客\n","permalink":"https://wqnm1gb.github.io/about/","summary":"about","title":"关于"}]