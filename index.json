[{"content":"+++ title = \u0026#39;My First Post\u0026#39; date = 2024-01-14T07:07:07+01:00 draft = true +++ 创建文章都会有一个配置文件，里边的内容draft是草稿的意思，如果已经正式确定了，就可以吧draft改成false\n使用hugo -D 可以生成public文件夹，这里边的是静态页面资源，也就是网站打开的内容，我们的网站内容就在这里边\n同时我们也可以上传一个自动资源部署的文件，需要上传hugo的所有文件夹，然后另外新建一个仓库\n引用的图片路径有空格的时候，需要添加%20 需要用/image/路径\nhugo -server会打开hugo\n","permalink":"https://wqnm1gb.github.io/posts/hugo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","summary":"\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e+++\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003etitle\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"err\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"n\"\u003eMy\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eFirst\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ePost\u003c/span\u003e\u003cspan class=\"err\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003edate\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e2024\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"n\"\u003e01\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"n\"\u003e14T07\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"n\"\u003e07\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"n\"\u003e07\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"n\"\u003e01\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"n\"\u003e00\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003edraft\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kc\"\u003etrue\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"o\"\u003e+++\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e创建文章都会有一个配置文件，里边的内容draft是草稿的意思，如果已经正式确定了，就可以吧draft改成false\u003c/p\u003e\n\u003cp\u003e使用hugo -D 可以生成public文件夹，这里边的是静态页面资源，也就是网站打开的内容，我们的网站内容就在这里边\u003c/p\u003e","title":"Hugo个人博客"},{"content":"Vue Vue 是一款用于构建用户界面的渐进式的JavaScript框架。\nVue是一个框架，也是一个生态\n可以选几个模块来用，也可也全选来做整站开发\nVue工程化 模块化：项目划分若干模块，单独开发、维护，提高效率\n组件化：将页面的各个组成部分封装为一个一个的组件，提高复用\n规范化：提供标准统一的目录结构、编码规范、开发流程\n自动化：项目的构建、开发、测试、打包、部署\n工程化就指的是上边的都包含\n在企业级的前端项目开发中，把前端开发所需的工具、技术、流程、经验等进行规范化、标准化。\n统一规范 提高复用 便于维护\n环境准备 介绍：create-vue是Vue官方提供的最新的脚手架工具，用于快速生成一个工程化的Vue项目。\ncreate-vue提供了如下功能：\n统一的目录结构 本地调试 热部署 单元测试 集成打包上线 依赖环境：NodeJS\nNodeJS介绍 是一个免费、开源、跨平台的JavaScript 运行时环境，它让开发人员能够创建服务器、Web 应用、命令行工具和脚本。\n类似于Java的JRE，JDK\nNPM介绍 npm: Node Package Manager，是NodeJS的软件 包管理器。\n类似于Java的Maven，python的pip（猜测的）\nVue项目创建 创建一个工程化的Vue项目，执行命令：npm create vue@3.3.4\n遇到的问题\nsudo chown -R $(whoami):$(id -gn) ~/.npm 或者直接执行 sudo npm install vue@3.3.4\nVue项目安装依赖 上边的图片提示出了需要继续的操作：进入项目目录，执行命令安装当前项目的依赖：npm install\n创建项目以及安装依赖的过程，都是需要联网的。\n上边提示的Add的各项目的解释，初始项目全都不需要安装\nVue项目结构 package.json 类似于 pom.xml\nVue项目启动 执行命令：npm run dev，就可以启动Vue项目了。\n或者是在vs code 中运行项目\n访问项目：打开浏览器，在浏览器地址栏访问 http://1ocalhost:5173 就可以访问到Vue项目。\nVue项目开发流程 对main.js里边代码的理解 createApp(App).mount(\u0026#39;#app\u0026#39;) **\u0026lt;font style=\u0026quot;color:rgb(64, 64, 64);\u0026quot;\u0026gt;createApp(App)\u0026lt;/font\u0026gt;** \u0026lt;font style=\u0026quot;color:rgb(64, 64, 64);\u0026quot;\u0026gt;createApp\u0026lt;/font\u0026gt; 是 Vue 3 提供的一个函数，用于创建一个 Vue 应用实例。 \u0026lt;font style=\u0026quot;color:rgb(64, 64, 64);\u0026quot;\u0026gt;App\u0026lt;/font\u0026gt; 是你的根组件（通常是一个 Vue 单文件组件，比如 \u0026lt;font style=\u0026quot;color:rgb(64, 64, 64);\u0026quot;\u0026gt;App.vue\u0026lt;/font\u0026gt;）。 调用 \u0026lt;font style=\u0026quot;color:rgb(64, 64, 64);\u0026quot;\u0026gt;createApp(App)\u0026lt;/font\u0026gt; 会返回一个 Vue 应用实例。 **\u0026lt;font style=\u0026quot;color:rgb(64, 64, 64);\u0026quot;\u0026gt;.mount('#app')\u0026lt;/font\u0026gt;** \u0026lt;font style=\u0026quot;color:rgb(64, 64, 64);\u0026quot;\u0026gt;mount\u0026lt;/font\u0026gt; 是 Vue 应用实例的一个方法，用于将应用挂载到 DOM 中的一个元素上。 \u0026lt;font style=\u0026quot;color:rgb(64, 64, 64);\u0026quot;\u0026gt;#app\u0026lt;/font\u0026gt; 是一个 CSS 选择器，表示将应用挂载到 \u0026lt;font style=\u0026quot;color:rgb(64, 64, 64);\u0026quot;\u0026gt;id=\u0026quot;app\u0026quot;\u0026lt;/font\u0026gt; 的 DOM 元素上。 挂载后，Vue 会接管这个 DOM 元素，并将其作为应用的根容器。 DOM元素通俗的理解：HTML文件是一个房子的设计图，DOM 就是根据这张设计图建造出来的实际房子，每个房间、门、窗户、家具都对应 DOM 中的一个元素。\nimport { createApp } from \u0026#39;vue\u0026#39; **\u0026lt;font style=\u0026quot;color:rgb(64, 64, 64);\u0026quot;\u0026gt;import\u0026lt;/font\u0026gt;** ****语句 \u0026lt;font style=\u0026quot;color:rgb(64, 64, 64);\u0026quot;\u0026gt;import\u0026lt;/font\u0026gt; 是 JavaScript 的模块导入语法，用于从其他模块中导入功能。\n\u0026lt;font style=\u0026quot;color:rgb(64, 64, 64);\u0026quot;\u0026gt;{ createApp }\u0026lt;/font\u0026gt; 是解构赋值语法，表示从 \u0026lt;font style=\u0026quot;color:rgb(64, 64, 64);\u0026quot;\u0026gt;vue\u0026lt;/font\u0026gt; 模块中导入 \u0026lt;font style=\u0026quot;color:rgb(64, 64, 64);\u0026quot;\u0026gt;createApp\u0026lt;/font\u0026gt; 函数。\n\u0026lt;font style=\u0026quot;color:rgb(64, 64, 64);\u0026quot;\u0026gt;'vue'\u0026lt;/font\u0026gt; 是模块的名称，指向 Vue 3 的核心库。\n其中\u0026lt;font style=\u0026quot;color:rgb(222,120,2);\u0026quot;\u0026gt;*.vue\u0026lt;/font\u0026gt;是Vue项目中的组件文件，在Vue项目中也称为单文件组件（SFC，Single-File Components）。Vue 的单文件组件会将一个组件的逻辑 (JS)，模板 (HTML) 和样式 (CSS) 封装在同一个文件里（\u0026lt;font style=\u0026quot;color:rgb(222,120,2);\u0026quot;\u0026gt;*.vue\u0026lt;/font\u0026gt;） App.vue称为根组件\n这里边为什么要加scoped？只会影响当前元素\n为什么有setup？会进行预处理操作，可以用组合式API\nVue基于数据驱动视图展示的，我们不会把数据写死，要写一个函数来定义\n改造之后：\n{{ message }} 插值表达式 todo\n可以在浏览器中更改\nAPI风格 Vue的组件有两种不同的风格：组合式API 和 选项式API\n组合式API：是Vue3提供的一种基于函数的组件编写方式，通过使用函数来组织和复用组件的逻辑。它提供了一种更灵活、更可组合的方式来编写组件。\n选项式API \u0026lt;script\u0026gt; export default { data(){ //声明响应式对象 return { count: 0 } }, methods: { //声明方法，可以通过组件实例访问 increment: function(){ this.count++ ; } }, mounted(){ //声明钩子函数 console.log(\u0026#39;Vue mounted ...\u0026#39;); } } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;button @click=\u0026#34;increment\u0026#34;\u0026gt;count:{{ count }}\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; 选项式API：可以用包含多个选项的对象来描述组件的逻辑，如：data，methods,mounted等。选项定义的属性都会暴露在函数内部的this上，它会指向当前的组件实例。\n组合式API \u0026lt;script setup\u0026gt; import { ref,onMounted } from \u0026#39;vue\u0026#39;; const count = ref(0); //声明响应式变量 function increment(){ //声明函数 count.value++; } onMounted(()=\u0026gt;{ //声明钩子函数 console.log(\u0026#39;Vue Mounted ...\u0026#39;); }) \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;button @click=\u0026#34;increment\u0026#34;\u0026gt;count:{{ count }}\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; 在组合式API中没有this，函数的名字前边都多加了一个on\n组合式API：是Vue3提供的一种基于函数的组件编写方式，通过使用函数来组织和复用组件的逻辑。它提供了一种更灵活、更可组合的方式来编写组件。\n如何引入APIDemo.vue\n在Vue中的组合式API使用时，是没有this对象的，this对象是undefined。\n工程化（复杂的）推荐组合式API\n案例：把vue代码改成组合式API async就是来声明一个异步方法，await是用来等待异步任务执行，这两个关键字必须同时出现\nElement Plus Element：是饿了么团队研发的，基于 Vue3，面向设计师和开发者的组件库。\n组件：组成网页的部件，例如 超链接、按钮、图片、表格、表单、分页条等等。\n快速入门 准备工作 每个项目一开始都需要做的工作\n创建vue项目 参照官方文档，安装Element Plus组件库（在当前工程的目录下）：npm install element-plus@2.4.4 \u0026ndash;save main.js中引入Element Plus组件库（参照官方文档） // main.ts import { createApp } from \u0026#39;vue\u0026#39; import ElementPlus from \u0026#39;element-plus\u0026#39; import \u0026#39;element-plus/dist/index.css\u0026#39; import App from \u0026#39;./App.vue\u0026#39; const app = createApp(App) app.use(ElementPlus) app.mount(\u0026#39;#app\u0026#39;) 制作组件 访问Element官方文档，复制组件代码，调整\n加上\u0026ndash;save，会把依赖信息保存到package.json中\nconst app = createApp（App）创建vue的应用实例\napp.use（ElementPlus） 调用use函数表示使用组件库\n常见组件 表格组件 \u0026lt;div class=\u0026#34;mb-4\u0026#34;\u0026gt; \u0026lt;el-table :data=\u0026#34;tableData\u0026#34; border style=\u0026#34;width: 80%\u0026#34;\u0026gt; \u0026lt;el-table-column prop=\u0026#34;date\u0026#34; label=\u0026#34;生日\u0026#34; width=\u0026#34;130\u0026#34; align=\u0026#34;center\u0026#34; /\u0026gt; \u0026lt;el-table-column prop=\u0026#34;name\u0026#34; label=\u0026#34;姓名\u0026#34; width=\u0026#34;130\u0026#34; align=\u0026#34;center\u0026#34; /\u0026gt; \u0026lt;el-table-column prop=\u0026#34;address\u0026#34; label=\u0026#34;住址\u0026#34; align=\u0026#34;center\u0026#34; /\u0026gt; \u0026lt;/el-table\u0026gt; \u0026lt;/div\u0026gt; Table表格组件，属性说明：\ndata: 主要定义table组件的数据模型 prop: 定义列的数据应该绑定data中定义的具体的数据模型 label: 定义列的标题 width: 定义列的宽度 分页条组件 把ElementPlus里边的元素设置成中文\n在main.js里边添加以下代码\nimport zhCn from \u0026#39;element-plus/dist/locale/zh-cn.mjs\u0026#39; app.use(ElementPlus, {locale: zhCn}) const currentPage4 = ref(4) const pageSize4 = ref(100) const handleSizeChange = (number) =\u0026gt; { console.log(`${val} items per page`) } const handleCurrentChange = (number) =\u0026gt; { console.log(`current page: ${val}`) } \u0026lt;div class=\u0026#34;mb-4\u0026#34;\u0026gt; \u0026lt;el-pagination v-model:current-page=\u0026#34;currentPage4\u0026#34; v-model:page-size=\u0026#34;pageSize4\u0026#34; :page-sizes=\u0026#34;[10, 20, 30, 40]\u0026#34; :size=\u0026#34;size\u0026#34; :disabled=\u0026#34;disabled\u0026#34; :background=\u0026#34;background\u0026#34; layout=\u0026#34;total, sizes, prev, pager, next, jumper\u0026#34; :total=\u0026#34;400\u0026#34; @size-change=\u0026#34;handleSizeChange\u0026#34; @current-change=\u0026#34;handleCurrentChange\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; background: 添加北京颜色，也就是上图蓝色背景色效果。 layout: 分页工具条的布局，其具体值包含sizes, prev, pager, next, jumper, total 这些值 total: 数据的总数量 size-change ： pageSize 改变时会触发 current-change ：currentPage 改变时会触发 Dialog对话框组件 Dialog对话框组件使用的关键点，就是控制其显示与隐藏。 通过 v-model 给定的boolean值，来控制Dialog的显示与隐藏\nreactive声明是一个响应式数据，这个数据类型是对象，也可以用ref声明\nvalue-format绑定数据格式，也就是最终提交数据的格式\n表单组件 Form 表单：由输入框、选择器、单选框、多选框等控件组成，用以收集、校验、提交数据。\n\u0026lt;el-form-item label=\u0026#34;出生日期\u0026#34;\u0026gt; \u0026lt;el-date-picker v-model=\u0026#34;formInline.date\u0026#34; type=\u0026#34;date\u0026#34; placeholder=\u0026#34;请选择时间\u0026#34; value-format=\u0026#34;YYYY-MM-DD\u0026#34; clearable/\u0026gt; \u0026lt;/el-form-item\u0026gt; 需要把对格式的控制写在date-picker这个里边\n控制台的输出就是正常的了\nContainer布局容器 给出了经典的布局样式\nLayout布局 通过基础的 24 分栏，迅速简便地创建布局\n案例 出现的问题，定义的ref变量的名字和获取的不同，出现了bug\n接下来分析一下代码便于之后的理解：\n\u0026lt;script setup\u0026gt; import axios from \u0026#39;axios\u0026#39; import { ref,onMounted } from \u0026#39;vue\u0026#39; // Form表单 const searchEmp = ref({ name: \u0026#39;\u0026#39;, gender: \u0026#39;\u0026#39;, job: \u0026#39;\u0026#39;, }) const tableData = ref([]) const search = async () =\u0026gt; { const result = await axios.get(`https://web-server.itheima.net/emps/list?name=${searchEmp.value.name}\u0026amp;gender=${searchEmp.value.gender}\u0026amp;job=${searchEmp.value.job}`) console.log(result.data.data) tableData.value=result.data.data } const clear = () =\u0026gt; { searchEmp.value={name:\u0026#39;\u0026#39;,gender:\u0026#39;\u0026#39;,job:\u0026#39;\u0026#39;} search(); } onMounted(() =\u0026gt; { search(); }) \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;!-- 表单 --\u0026gt; \u0026lt;el-form :inline=\u0026#34;true\u0026#34; :model=\u0026#34;searchEmp\u0026#34; class=\u0026#34;demo-form-inline\u0026#34;\u0026gt; \u0026lt;el-form-item label=\u0026#34;姓名\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;searchEmp.name\u0026#34; placeholder=\u0026#34;请输入姓名\u0026#34; clearable /\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;性别\u0026#34;\u0026gt; \u0026lt;el-select v-model=\u0026#34;searchEmp.gender\u0026#34; placeholder=\u0026#34;请选择\u0026#34; clearable\u0026gt; \u0026lt;el-option label=\u0026#34;男\u0026#34; value=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;el-option label=\u0026#34;女\u0026#34; value=\u0026#34;2\u0026#34; /\u0026gt; \u0026lt;/el-select\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;职位\u0026#34;\u0026gt; \u0026lt;el-select v-model=\u0026#34;searchEmp.job\u0026#34; placeholder=\u0026#34;请选择\u0026#34; clearable\u0026gt; \u0026lt;el-option label=\u0026#34;班主任\u0026#34; value=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;el-option label=\u0026#34;讲师\u0026#34; value=\u0026#34;2\u0026#34; /\u0026gt; \u0026lt;el-option label=\u0026#34;咨询师\u0026#34; value=\u0026#34;3\u0026#34; /\u0026gt; \u0026lt;/el-select\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; @click=\u0026#34;search\u0026#34;\u0026gt;查询\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;info\u0026#34; @click=\u0026#34;clear\u0026#34;\u0026gt;清空\u0026lt;/el-button\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;/el-form\u0026gt; \u0026lt;br\u0026gt; \u0026lt;!-- 表格 --\u0026gt; \u0026lt;el-table :data=\u0026#34;tableData\u0026#34; border style=\u0026#34;width: 100%; \u0026#34;\u0026gt; \u0026lt;el-table-column prop=\u0026#34;id\u0026#34; label=\u0026#34;ID\u0026#34; width=\u0026#34;80\u0026#34; align=\u0026#34;center\u0026#34; /\u0026gt; \u0026lt;el-table-column prop=\u0026#34;name\u0026#34; label=\u0026#34;姓名\u0026#34; width=\u0026#34;100\u0026#34; align=\u0026#34;center\u0026#34; /\u0026gt; \u0026lt;el-table-column label=\u0026#34;头像\u0026#34; width=\u0026#34;120\u0026#34; align=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;template #default=\u0026#34;scope\u0026#34;\u0026gt; \u0026lt;img :src=\u0026#34;scope.row.image\u0026#34; width=\u0026#34;70\u0026#34;\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;gender\u0026#34; label=\u0026#34;性别\u0026#34; width=\u0026#34;120\u0026#34; align=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;template #default=\u0026#34;scope\u0026#34;\u0026gt; \u0026lt;!-- 插值表达式里边可以用三元运算符 --\u0026gt; {{ scope.row.gender == 1 ? \u0026#39;男\u0026#39; : \u0026#39;女\u0026#39; }} \u0026lt;/template\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column label=\u0026#34;职位\u0026#34; width=\u0026#34;180\u0026#34; align=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;template #default=\u0026#34;scope\u0026#34;\u0026gt; \u0026lt;span v-if=\u0026#34;scope.row.job == 1\u0026#34;\u0026gt;班主任\u0026lt;/span\u0026gt; \u0026lt;span v-else-if=\u0026#34;scope.row.job == 2\u0026#34;\u0026gt;讲师\u0026lt;/span\u0026gt; \u0026lt;span v-else-if=\u0026#34;scope.row.job == 3\u0026#34;\u0026gt;咨询师\u0026lt;/span\u0026gt; \u0026lt;span v-else\u0026gt;其他\u0026lt;/span\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;entrydate\u0026#34; label=\u0026#34;入职日期\u0026#34; width=\u0026#34;180\u0026#34; align=\u0026#34;center\u0026#34; /\u0026gt; \u0026lt;el-table-column prop=\u0026#34;updatetime\u0026#34; label=\u0026#34;更新时间\u0026#34; align=\u0026#34;center\u0026#34; /\u0026gt; \u0026lt;/el-table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style scoped\u0026gt; #center { width: 70%; margin: auto; margin-top: 100px; } \u0026lt;/style\u0026gt; 通过scope可以拿到这一行的数据，进而拿到值\n","permalink":"https://wqnm1gb.github.io/posts/day15%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/","summary":"\u003ch1 id=\"vue\"\u003eVue\u003c/h1\u003e\n\u003cp\u003eVue 是一款用于构建用户界面的渐进式的JavaScript框架。\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/Day15%e5%89%8d%e7%ab%af%e5%bc%80%e5%8f%91.assets/1736298344715-9f650ce4-d600-4c62-8c7f-b81da3737a53.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003eVue是一个框架，也是一个生态\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/Day15%e5%89%8d%e7%ab%af%e5%bc%80%e5%8f%91.assets/1736298392083-fb9929a1-8955-4d3a-b289-66b994c9a712.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e可以选几个模块来用，也可也全选来做整站开发\u003c/p\u003e\n\u003ch1 id=\"vue工程化\"\u003eVue工程化\u003c/h1\u003e\n\u003cp\u003e模块化：项目划分若干模块，单独开发、维护，提高效率\u003c/p\u003e","title":"Day15 前端开发"},{"content":"前后端开发模式 整体布局 一个vue项目，首先是从main.js开始的\n@代表的是在src目录下查找\nContainer布局容器 ：外层容器。\n：顶栏容器。\n：侧边栏容器。\n：王要区域容器。\n：底栏容器。\nlayout：布局的意思\n当不包含header和footer的时候，就会左右展示，包含的时候就会上下展示\n左侧菜单栏 实现效果：\nVueRouter Vue Router: Vue的官方路由。为Vue提供富有表现力、可配置的、方便的路由。\nVue中的路由，主要定义的是路径与组件之间的对应关系。\n组成：\nRouter实例：路由实例，基于createRouter函数创建，维护了应用的路由信息。 ：路由链接组件，浏览器会解析成＜a\u0026gt;。 ：动态视图组件，用来渲染展示与路由路径对应的组件。 基础路由配置 **1). 在 **\u0026lt;font style=\u0026quot;color:rgb(46,161,33);\u0026quot;\u0026gt;views/layout/index.vue\u0026lt;/font\u0026gt;** 中，调整代码，具体调整位置如下： **\n在左侧菜单栏的 \u0026lt;font style=\u0026quot;color:rgb(46,161,33);\u0026quot;\u0026gt;\u0026lt;el-menu\u0026gt;\u0026lt;/font\u0026gt; 标签上添加 \u0026lt;font style=\u0026quot;color:rgb(46,161,33);\u0026quot;\u0026gt;router\u0026lt;/font\u0026gt;属性，添加router会默认开启router并且以index作为路径跳转，这会让 Element Plus 的 \u0026lt;font style=\u0026quot;color:rgb(46,161,33);\u0026quot;\u0026gt;\u0026lt;el-menu\u0026gt;\u0026lt;/font\u0026gt; 组件自动根据路由来激活对应的菜单项。 使用 \u0026lt;font style=\u0026quot;color:rgb(46,161,33);\u0026quot;\u0026gt;\u0026lt;router-view\u0026gt;\u0026lt;/font\u0026gt; 组件来渲染根据路由动态变化的内容。 确保每个 \u0026lt;font style=\u0026quot;color:rgb(46,161,33);\u0026quot;\u0026gt;\u0026lt;el-menu-item\u0026gt;\u0026lt;/font\u0026gt; 的 \u0026lt;font style=\u0026quot;color:rgb(46,161,33);\u0026quot;\u0026gt;index\u0026lt;/font\u0026gt;属性值与你想要导航到的路径相匹配。 2). 在 router/index.js 中配置请求路径与组件之间的关系。\nimport { createRouter, createWebHistory} from \u0026#39;vue-router\u0026#39;; import IndexView from \u0026#39;@/views/index/index.vue\u0026#39;; import ClazzView from \u0026#39;@/views/clazz/index.vue\u0026#39;; import StuView from \u0026#39;@/views/stu/index.vue\u0026#39;; import DeptView from \u0026#39;@/views/dept/index.vue\u0026#39;; import EmpView from \u0026#39;@/views/emp/index.vue\u0026#39;; import EmpReportView from \u0026#39;@/views/report/emp/index.vue\u0026#39;; import StuReportView from \u0026#39;@/views/report/stu/index.vue\u0026#39;; import LogView from \u0026#39;@/views/log/index.vue\u0026#39;; import LoginView from \u0026#39;@/views/login/index.vue\u0026#39;; const routes = [ { path: \u0026#39;/index\u0026#39;, component: IndexView }, { path: \u0026#39;/clazz\u0026#39;, component: ClazzView }, { path: \u0026#39;/stu\u0026#39;, component: StuView }, { path: \u0026#39;/dept\u0026#39;, component: DeptView }, { path: \u0026#39;/emp\u0026#39;, component: EmpView }, { path: \u0026#39;/report/emp\u0026#39;, component: EmpReportView }, { path: \u0026#39;/report/stu\u0026#39;, component: StuReportView }, { path: \u0026#39;/log\u0026#39;, component: LogView }, { path: \u0026#39;/login\u0026#39;, component: LoginView }, ]; const router = createRouter({ history: createWebHistory(), routes, }); export default router; 配置路由的时候，path代表的是路径，name代表的是路由的名字，component代表的是组件的名字\n想要在右侧main位置展示组件，需要在main的位置（右侧核心展示区域）添加router-view\n如果path是/ 代表的是路径从/开始，并且匹配不到其他的（/login)路径\nredict 重定向\n完善路由配置 这里遇到的一个问题：layout路径写错了，导致一直无法展示出来\n之所以要优化是因为我们访问 /login 路径，会发现，登录页面是在layout页面中嵌套展示的，这肯定是不合适的。\n解决方法：\n把App.vue这个入口vue展示的是路由展示组件，然后这时候会发现，layout布局没办法展示了，这时候需要用到嵌套路由，用/login 和 / 匹配不同的路径，除了/login之外都会用匹配到/ 这时候到/ 可以用嵌套路由\nimport { createRouter, createWebHistory } from \u0026#39;vue-router\u0026#39; import IndexView from \u0026#39;@/views/index/index.vue\u0026#39; import ClazzView from \u0026#39;@/views/clazz/index.vue\u0026#39; import StuView from \u0026#39;@/views/stu/index.vue\u0026#39; import DeptView from \u0026#39;@/views/dept/index.vue\u0026#39; import EmpView from \u0026#39;@/views/emp/index.vue\u0026#39; import EmpReportView from \u0026#39;@/views/report/emp/index.vue\u0026#39; import StuReportView from \u0026#39;@/views/report/stu/index.vue\u0026#39; import LogView from \u0026#39;@/views/log/index.vue\u0026#39; import LoginView from \u0026#39;@/views/login/index.vue\u0026#39; import LayoutView from \u0026#39;@/views/layout/index.vue\u0026#39; const router = createRouter({ history: createWebHistory(import.meta.env.BASE_URL), routes: [ { path: \u0026#39;/\u0026#39;, component: LayoutView, children: [ { path: \u0026#39;/index\u0026#39;, component: IndexView }, { path: \u0026#39;/clazz\u0026#39;, component: ClazzView }, { path: \u0026#39;/stu\u0026#39;, component: StuView }, { path: \u0026#39;/dept\u0026#39;, component: DeptView }, { path: \u0026#39;/emp\u0026#39;, component: EmpView }, { path: \u0026#39;/empReport\u0026#39;, component: EmpReportView }, { path: \u0026#39;/stuReport\u0026#39;, component: StuReportView }, { path: \u0026#39;/log\u0026#39;, component: LogView }, ] }, { path: \u0026#39;/login\u0026#39;, component: LoginView } ] }) export default router JS中隐式类型转换，0转换成FALSE，其他数字都是TRUE，\u0026lsquo;\u0026lsquo;空字符串是FALSE，其他都是TRUE，null和undefined是FALSE\naxios是什么 \u0026lt;font style=\u0026quot;color:rgb(64, 64, 64);\u0026quot;\u0026gt;axios\u0026lt;/font\u0026gt; 是一个基于 Promise 的 HTTP 客户端，用于浏览器和 Node.js 环境中发送 HTTP 请求。它是前端开发中最常用的网络请求库之一，具有以下特点：\n1. 主要特点 基于 Promise：支持异步操作，可以使用 \u0026lt;font style=\u0026quot;color:rgb(64, 64, 64);\u0026quot;\u0026gt;async/await\u0026lt;/font\u0026gt; 或 \u0026lt;font style=\u0026quot;color:rgb(64, 64, 64);\u0026quot;\u0026gt;.then()\u0026lt;/font\u0026gt; 处理请求结果。异步操作是指在程序执行过程中，某些操作不会立即完成，而是需要等待一段时间才能得到结果。在这段时间内，程序可以继续执行其他任务，而不需要阻塞等待。 跨平台：支持浏览器和 Node.js 环境。 拦截器：支持请求和响应的拦截，方便统一处理请求或响应。 自动转换数据：自动将请求和响应数据转换为 JSON 格式。 取消请求：支持取消请求的功能。 并发请求：支持同时发送多个请求。 export default request的意义是，让别的地方能导入进来，所以需要把request导出去\n如果箭头函数里边只有一个return语句，那么可以把return省略，同时也把{}省略\n","permalink":"https://wqnm1gb.github.io/posts/day16%E5%89%8D%E7%AB%AFweb%E5%AE%9E%E6%88%98/","summary":"\u003ch1 id=\"前后端开发模式\"\u003e前后端开发模式\u003c/h1\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/Day16%e5%89%8d%e7%ab%afWeb%e5%ae%9e%e6%88%98.assets/1737338561934-862cfbc3-41b6-42bf-b956-029a05e70197-20250224210317351.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003ch1 id=\"整体布局\"\u003e整体布局\u003c/h1\u003e\n\u003cp\u003e一个vue项目，首先是从main.js开始的\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/Day16%e5%89%8d%e7%ab%afWeb%e5%ae%9e%e6%88%98.assets/1737338801330-0204132c-6b60-4b48-bde1-9e20047c4626.png\" alt=\"\"  /\u003e\n\u003cimg loading=\"lazy\" src=\"/images/Day16%e5%89%8d%e7%ab%afWeb%e5%ae%9e%e6%88%98.assets/1737338816071-9f93e2ba-e801-4172-8b0a-f4c499f4a7db.png\" alt=\"\"  /\u003e\n@代表的是在src目录下查找\u003c/p\u003e\n\u003ch2 id=\"container布局容器\"\u003eContainer布局容器\u003c/h2\u003e\n\u003cp\u003e\u003c!-- raw HTML omitted --\u003e：外层容器。\u003c/p\u003e\n\u003cp\u003e\u003c!-- raw HTML omitted --\u003e：顶栏容器。\u003c/p\u003e\n\u003cp\u003e\u003c!-- raw HTML omitted --\u003e：侧边栏容器。\u003c/p\u003e","title":"Day16 前端Web实战"},{"content":"SpringBoot原理 配置优先级 虽然springboot支持多种格式配置文件，但是在项目开发时，推荐统一使用一种格式的配置 （yml是主流）\nSpringBoot 除了支持配置文件属性配置，还支持Java系统属性和命令行参数的方式进行属性配置。\n打包成jar包之后如何指定配置\nSpringboot项目进行打包时，需要引入插件** spring-boot-maven-plugin**（基于官网骨架创建项目，会自动添加该插件）\n配置属性中，命令行属性的优先级是最高的，其次是java系统属性，其次是application.prope，其次是application.yml，最后是application.yaml\n外部配置项的优先级是优于内部配置文件的\nBean管理 Bean作用域 Spring支持五种作用域，后三种在web环境才生效：\n作用域 说明 singleton 容器内同 名称的 bean 只有一个实例（单例）（默认） prototype 每次使用该 bean 时会创建新的实例（非单例/多例） request 每个请求范围内会创建新的实例（web环境中，了解） session 每个会话范围内会创建新的实例（web环境中，了解） application 每个应用范围内会创建新的实例（web环境中，了解） 没有为bean指定类名，默认是类名首字母小写\n单例的bean默认是在项目启动时，就创建，然后会将bean对象存入IOC容器\n@Lazy可以延迟实例化，第一次使用的时候实例化\n// 注意要加SpringBootTest注解，用于在测试环境中加载 Spring 应用上下文 @SpringBootTest public class ScopeTest { @Autowired private ApplicationContext applicationContext; // 获取IOC容器对象 @Test public void testScope(){ for (int i = 0; i \u0026lt; 100; i++) { DeptController deptController = applicationContext.getBean(DeptController.class); System.out.println(deptController); } } } 作用域设置成了 prototype 所以运行的时候产生的DeptController对象是不一样的\n第三方Bean 如果要管理的bean对象来自于第三方（不是自定义的），是无法用@Component 及衍生注解声明bean的，就需要用到 @Bean注解。\n若要管理的第三方bean对象，建议对这些bean进行集中分类配置（推荐），可以通过@Configuration注解声明一个配置类。\n有两种声明方法，一个是放在启动类中，一个是集中分类配置\n如果第三方bean需要依赖其它bean对象，直接在bean定义方法中设置形参即可，容器会根据类型自动装配。如果声明的方法的参数中调用的对象，没有在IOC容器中，那么就会报错\n@Configuration 这个注解记得要加！\n@Configuration public class OSSconfig { @Bean // 黄色的这个必须在IOC容器中，相当于省略了@Autowired public AliyunOSSOperator aliyunOSSOperator(AliyunOSSProperties aliyunOSSProperties){ return new AliyunOSSOperator(aliyunOSSProperties); } } 通过@Bean注解的name或value属性可以声明bean的名称，如果不指定，默认bean的名称就是方法名。\nSpringBoot原理 起步依赖的原理是Maven依赖传递\n一旦声明了@ComponentScan这个注解，默认的扫描范围（启动类所在包及其子包）就不再生效了，需要添加上原来扫描的包\n自动配置 SpringBoot的自动配置就是当spring项目启动后，一些配置类、bean对象就自动存入到了IOC容器中，不需要我们手动去声明，从而简化了开发，省去了繁琐的配置操作。\n比如说谷歌的这Gson类，可以把数据转化成Json格式，我们并没有手动引入，但是aliyun的一个依赖中引入，所以我们也可以调用\n@Test public void testGson(){ System.out.println(gson.toJson(Result.success(\u0026#34;hello,world!\u0026#34;))); } 运行结果：\n实现方案1：@Conponent+@ConponentScan 想要在@ComponentScan中被扫描到，需要在pom.xml中引入依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;itheima-utils\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 手动配置扫描范围，具有使用繁琐，性能低的缺点\n@ComponentScan({\u0026#34;com.example\u0026#34;,\u0026#34;com.zzzzyj\u0026#34;}) @SpringBootApplication public class SpringbootAopQuickstartApplication { public static void main(String[] args) { SpringApplication.run(SpringbootAopQuickstartApplication.class, args); } } 实现方案2：@Import类导入 @Import导入。@Import导入的类会被Spring加载到IOC容器中，导入形式主要有以下几种：\n导入普通类 导入配置类 导入 ImportSelector 接口实现类 返回一个数组，可以里边添加很多类 实现selectImport方法 public class MyImportSelector implements ImportSelector { public String[] selectImports(AnnotationMetadata importingClassMetadata) { return new String[]{\u0026#34;com.example.HeaderConfig\u0026#34;}; } } @EnableXxxx注解，封装@Import注解（方便 优雅） // 导入普通类或者配置类 @Import(HeaderConfig.class) // 导入 ImportSelector 接口实现类 @Import(MyImportSelector.class) // @EnableXxxx注解，封装@Import注解 @EnableHeaderConfig 自动配置-源码跟踪 @SpringBootApplication public class SpringbootAopQuickstartApplication { public static void main(String[] args) { SpringApplication.run(SpringbootAopQuickstartApplication.class, args); } } @SpringBootApplication\n该注解标识在SpringBoot工程引导类上，是SpringBoot中最最最重要的注解。该注解由三个部分组成：\n@SpringBootConfiguration：该注解与 @Configuration 注解作用相同，用来声明当前也是一个配置类。启动类也是一个配置类，所以可以声明第三方，底层封装了@Configuration @ComponentScan：组件扫描，默认扫描当前引导类所在包及其子包。 @EnableAutoConfiguration：SpringBoot实现自动化配置的核心注解。 自动配置的原理，可以看https://heuqqdmbyk.feishu.cn/wiki/P8fNwBnSRiA6wWksjExcUZ4YnFe里边的飞书云文档\n这里还是分析一下\n点进去，里边出了元注解还有另外三个注解，接下来一个一个分析\n**@SpringBootConfiguration**\n也就是里边关键的就两个\n@Configuration 这个上边讲过了，这就是一个说明这是个集中配置类的注解\n@Indexed 这个是用来加速启动的，不需要关心\n**@ComponentScan**\n@ComponentScan 注解是用来进行组件扫描的，扫描启动类所在的包及其子包下所有被@Component及其衍生注解声明的类。\nSpringBoot启动类，之所以具备扫描包功能，就是因为包含了@ComponentScan注解\n**@EnableAutoConfiguration**** 自动配置核心注解**\n里边包含了这些：\n使用@Import注解，导入了实现ImportSelector接口的实现类。\nAutoConfigurationImportSelector类是ImportSelector接口的实现类。\n里边重写了ImportSelector中的selectImports()方法\n我们现在来分析一下这个方法\nselectImports()方法底层调用getAutoConfigurationEntry()方法，获取可自动配置的配置类信息集合\n所以说我们来分析一下getAutoConfigurationEntry()方法\ngetAutoConfigurationEntry()方法通过调用getCandidateConfigurations(annotationMetadata, attributes)方法获取在配置文件中配置的所有自动配置类的集合\n再来分析一下getCandidateConfigurations()这个方法\ngetCandidateConfigurations方法的功能：\n获取所有基于 \u0026lt;font style=\u0026quot;color:rgb(222,120,2);\u0026quot;\u0026gt;META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports\u0026lt;/font\u0026gt;文件中配置类的集合\n\u0026lt;font style=\u0026quot;color:rgb(222,120,2);\u0026quot;\u0026gt;META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports\u0026lt;/font\u0026gt;文件这两个文件在哪里呢？\n通常在引入的起步依赖中，都有包含以上文件\n在前面演示自动配置的时候，我们直接在测试类当中注入了一个叫gson的bean对象，进行JSON格式转换。虽然我们没有配置bean对象，但是我们是可以直接注入使用的。原因就是因为在自动配置类当中做了自动配置。到底是在哪个自动配置类当中做的自动配置呢？我们通过搜索来查询一下。\n打开上面的第三方依赖中提供的 \u0026lt;font style=\u0026quot;color:rgb(222,120,2);\u0026quot;\u0026gt;GsonAutoConfiguration\u0026lt;/font\u0026gt;类（双击shift实现）\n打开@AutoConfiguration\n原理就是在配置类中定义一个@Bean标识的方法，而Spring会自动调用配置类中使用@Bean标识的方法，并把方法的返回值注册到IOC容器中。\n小结\n@SpringBootConfiguration\n- **声明当前类是一个配置类** @ComponentScan\n- **进行组件扫描（SpringBoot中默认扫描的是启动类所在的当前包及其子包）** @EnableAutoConfiguration\n- **封装了@Import注解（Import注解中指定了一个ImportSelector接口的实现类）** - 在实现类重写的selectImports()方法，读取当前项目下所有依赖jar包中`\u0026lt;font style=\u0026quot;color:rgb(222,120,2);\u0026quot;\u0026gt;META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports\u0026lt;/font\u0026gt;`两个文件里面定义的配置类（配置类中定义了@Bean注解标识的方法）。 当SpringBoot程序启动时，就会加载配置文件当中所定义的配置类，并将这些配置类信息(类的全限定名)封装到String类型的数组中，最终通过@Import注解将这些配置类全部加载到Spring的IOC容器中，交给IOC容器管理。\n在 \u0026lt;font style=\u0026quot;color:rgb(46,161,33);\u0026quot;\u0026gt;META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports\u0026lt;/font\u0026gt; 文件中定义的配置类非常多，而且每个配置类中又可以定义很多的bean，那这些bean都会注册到Spring的IOC容器中吗？\n答案：并不是。 在声明bean对象时，上面有加一个以 \u0026lt;font style=\u0026quot;color:rgb(46,161,33);\u0026quot;\u0026gt;@Conditional\u0026lt;/font\u0026gt; 开头的注解，这种注解的作用就是按照条件进行装配，只有满足条件之后，才会将bean注册到Spring的IOC容器中（下面会详细来讲解）\n@Conditional 作用：按照一定的条件进行判断，在满足给定条件后才会注册对应的bean对象到Spring的IOC容器中。\n位置：方法、类\n@Conditional本身是一个父注解，派生出大量的子注解：\n@ConditionalOnClass：判断环境中有对应字节码文件，才注册bean到IOC容器。 @ConditionalOnMissingBean：判断环境中没有对应的bean（类型或名称），才注册bean到IOC容器。 @ConditionalOnProperty：判断配置文件中有对应属性和值，才注册bean到IOC容器。 笔记文档中有详细的代码判断。\n自定义starter 场景：在实际开发中，经常会定义一些公共组件，提供给各个项目团队使用。而在SpringBoot的项目中，一般会将这些公共组件封装为SpringBoot的starter（包含了起步依赖和自动配置的功能）。\nstarter就是一个一个的依赖\n需求：自定义aliyun-oss-spring-boot-starter，完成阿里云OSS操作工具类 Aliyunossoperator 的自动配置。 目标：引入起步依赖引入之后，要想使用阿里云OSS，注入 AliyunOSSOperator 直接使用即可。 步骤： 创建aliyun-oss-spring-boot-starter模块 创建aliyun-oss-spring-boot-autoconfigure模块，在starter中引入该模块 在aliyun-oss-spring-boot-autoconfigure模块中的定义自动配置功能，并定义自动配置文件 META-INF/spring/xxxx.imports 下边详细分析一下自定义starter的实现步骤\n首先定义两个模块，其中starter模块只需要保留pom.xml文件，里边引用autoconfigure，代码等功能的实现都在autoconfigure模块中\n接下来分析一下autoconfigure模块\n其中后两个类是用来实现文件上传功能的，但是里边的@Component注解没有用了，在SpringBoot项目中，并不会去扫描com.aliyun.oss这个包，不扫描这个包那类上的注解也就失去了作用。\n就可以删除里边的Component和Autowired注解，同时需要按照 starter 的定义规范，定义一个自动配置类，在自动配置类中声明bean。\npackage com.aliyun.oss; import org.springframework.boot.context.properties.EnableConfigurationProperties; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration @EnableConfigurationProperties(AliyunOSSProperties.class) public class AliyunOSSAutoConfiguration { @Bean public AliyunOSSOperator aliyunOSSOperator(AliyunOSSProperties aliyunOSSProperties) { return new AliyunOSSOperator(aliyunOSSProperties); } } 之前思考的问题，为什么不能new一个AliyunOSSProperties，是因为他没有在IOC容器中，不能new一个，找不到这个对象，所以需要传进来，那么会问，怎么传，不也要在IOC容器中才能传递吗，所以我需要@EnableConfigurationProperties(AliyunOSSProperties.class) 这个注解里边包括了@Import注解，可以直接导入数据\n文件里边是全类名\ncom.aliyun.oss.AliyunOSSAutoConfiguration 思考的一个问题\n为什么在本地配置的yml文件是可行的\n其实这个问题很简单，因为我们引入了IOC，相当于是把之前写的那些类也就是放在了本地运行，所以在本地配置就可以了。\nMaven高级 分模块设计与开发 如果全都写在一个模块里，不便于维护，难以复用\n分模块设计示例图：\n将一个大项目拆分成若干个子模块，方便项目的管理维护、扩展，也方便模块间的相互引用，资源共享。\n分模块设计的策略 策略一：按照功能模块拆分，比如：公共组件、商品模块、搜索模块、购物车模块、订单模块等。 策略二：按层拆分，比如：公共组件、实体类、控制层、业务层、数据访问层。 策略三：按照功能模块 + 层拆分。 实战 分模块开发需要先针对模块功能进行设计，再进行编码。不会先将工程开发完毕，然后进行拆分。\n创建项目后，需要检查jdk的版本是否正确，还有就是Maven的环境是否正确\n拆分之后，因为原来的项目中有引入SpringBoot所以里边的Lombok没有指定版本，但是拆分pojo的时候，并不需要引入SpringBoot所以需要指定版本\n在Maven的控制面板里边可以看到之前的版本号\n还用到了，这个是Spring的核心包，只需要引入Spring的核心包就行\n核心包就叫做spring-boot-start\n原项目还需要引入pojo\n继承与聚合 提出的原因是：\n如果多个模块都要引用同一个依赖，每个模块都写会很复杂，所以抽取成为父模块\n概念：继承描述的是两个工程间的关系，与java中的继承相似，子工程可以继承父工程中的配置信息，常见于依赖关系的继承。\n作用：简化依赖配置、统一管理依赖\n实现：\u0026hellip;\nmaven和java一样不支持多继承，但支持多重继承\n继承关系实现 创建maven模块tlias-parent，该工程为父工程，设置打包方式pom（默认jar）。 在子工程的pom.xml文件中，配置继承关系。 在父工程中配置各个工程共有的依赖（子工程会自动继承父工程的依赖）。 **jar：**普通模块打包，SR ngoot项目基本都是jar包（内嵌tomcat运行）\n**war：**普通web程序打包，需要部署在外部的tomcat服务器中运行\n**pom：**父工程或聚合工程，该模块不写代码，仅进行依赖管理\n父工程需要配置相对路径，如果自闭合，就是不配置相对路径的话，会先从本地仓库中寻找，如果没有，再从中央仓库中寻找\n在子工程中，配置了继承关系之后，坐标中的groupId是可以省略的，因为会自动继承父工程的。\nrelativePath指定父工程的pom文件的相对位置（如果不指定，将从本地仓库/远程仓库查找）。\n若父子工程都配置了同一个依赖的不同版本，以子工程的为准。\n配置的时候从当前项目开始，找到xml文件\n不是公共的依赖，不建议在父工程中引入，会耗费资源\n版本锁定 在maven中，可以在父工程的pom文件中通过 来统一管理依赖版本，注意这里边还需要标签\n属性配置 解决了什么问题：\n因为实际的项目中会有很多的如果需要一个一个查找会很麻烦，一个会占用很多行，所以直接在中定义版本号\n名字需要保持一致\n聚合 聚合\n将多个模块组织成一个整体，同时进行项目的构建。\n聚合工程\n一个不具有业务功能的“空”工程（有且仅有一个pom文件）\n作用\n快速构建项目（无需根据依赖关系手动构建，直接在聚合工程上构建即可）\n实现\nmaven中可以通过设置当前聚合工程所包含的子模块名称\n\u0026lt;!--聚合--\u0026gt; \u0026lt;modules\u0026gt; \u0026lt;module\u0026gt;../tlias-pojo\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;../tlias-utils\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;../tlias-web-management\u0026lt;/module\u0026gt; \u0026lt;/modules\u0026gt; 聚合工程中所包含的模块，在构建时，会自动根据模块间的依赖关系设置构建顺序，与聚合工程中模块的配置书写位置无关。\nmaven中继承与聚合的区别\n联系：继承与聚合都属于设计型模块，打包方式都为pom，常将两种关系制作到同一个pom文件中\n区别：\n继承用于简化依赖配置、统一管埋依赖版本，是在子工程中配置继承关系 聚合用于快速构建项目，是在父工程（聚合工程）中配置聚合的模块 私服 私服是一种特殊的远程仓库，它是架设在局域网内的仓库服务，用来代理位于外部的中央仓库，用于解决团队内部的资源共享与资源同步问题。\n私服在企业项目开发中，一个项目/公司，只需要一台即可（无需我们自己搭建，会使用即可）。\n依赖查找顺序：\n本地仓库 -\u0026gt; 私服 -\u0026gt; 中央仓库\n资源的上传与下载\n项目版本：\nRELEASE（发行版本）：功能趋于稳定、当前更新停止，可以用于发行的版本，存储在私服中的RELEASE仓库中。\nSNAPSHOT（快照版本）：功能不稳定、尚处于开发中的版本，即快照版本，存储在私服的SNAPSHOT仓库中。\n步骤：\n1、设置私服的访问用户名/密码（settings.xmL中的servers中配置）\n2、IDEA的maven工程的pom文件中配置上传（发布）地址\n3、设置私服依赖下载的仓库组地址（settings.xml中的mirrors、profiles中配置）\nWeb后端开发总结 阿里云OSS - 对象存储的解决方案\nJWT - 会话跟踪的解决方案\nSpringMVC 是Spring框架的一部分\n","permalink":"https://wqnm1gb.github.io/posts/day14spring-%E5%8E%9F%E7%90%86/","summary":"\u003ch1 id=\"springboot原理\"\u003eSpringBoot原理\u003c/h1\u003e\n\u003ch2 id=\"配置优先级\"\u003e配置优先级\u003c/h2\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735439988115-b6256d2b-42e0-498c-bf99-d470cad28ad5.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e虽然springboot支持多种格式配置文件，但是在项目开发时，推荐统一使用一种格式的配置 （yml是主流）\u003c/p\u003e\n\u003cp\u003eSpringBoot 除了支持配置文件属性配置，还支持\u003cstrong\u003eJava系统属性和命令行参数\u003c/strong\u003e的方式进行属性配置。\u003c/p\u003e","title":"Day14 Spring-原理"},{"content":"什么是AOP？ **AOP：**Aspect Oriented Programming（面向切面编程、面向方面编程），可简单理解为就是面向特定方法编程。\n**场景：**案例中部分业务方法运行较慢，定位执行耗时较长的接口，此时需要统计每一个业务方法的执行耗时。\n优势：\n减少重复代码（用计算运行时间的代码示例，不需要每个方法里边都写检测时间逻辑） 代码无侵入（不需要改变原来的方法的代码） 提高开发效率（不需要修改一个一个方法） 维护方便（直接注释掉AOP的方法，就可以进行维护） AOP是一种思想，而在Spring框架中对这种思根进行的实现，那我们要学习的就是Spring AOP。\nAOP基础 AOP快速入门 需求：统计所有业务层方法的执行耗时。\n步骤：\n1、导入依赖：在pom.xml中引入AOP的依赖\n\u0026lt;!-- AOP起步依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-aop\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 父工程用了Spring框架，所以不需要指定版本\n2、编写AOP程序：针对于特定的方法根据业务需要进行编程\n@Component @Slf4j @Aspect // 当前类是切面类 public class RecordTimeAspect { // 还得记得配置生效的范围 @Around(\u0026#34;execution(* com.itheima.service.impl.*.*(..))\u0026#34;) public Object recordTime(ProceedingJoinPoint pjp) throws Throwable { // 1、记录方法的开始时间 long begin = System.currentTimeMillis(); // 2、执行目标方法 执行方法需要有ProceedingJoinPoint这个类，调用proceed方法 Object result = pjp.proceed(); // 3、记录方法执行时长 long end = System.currentTimeMillis(); // pjp.getSignature()可以获得执行方法的名字 log.info(\u0026#34;{}方法执行耗时{}ms\u0026#34;,pjp.getSignature(),end - begin); return result; } } AOP中的核心概念 **连接点：**JoinPoint，可以被AOP控制的方法（暗含方法执行时的相关信息） 通知：Advice，指那些重复的逻辑，也就是共性功能（最终体现为一个方法） 切入点：PointCut，匹配连接点的条件，通知仅会在切入点方法执行时被应用 **切面：**Aspect，描述通知与切入点的对应关系（通知＋切入点） **目标对象：**Target，通知所应用的对象 连接点：可以被AOP控制的方法\n切入点：实际被AOP控制的方法\n切入点一定是连接点，但是连接点不一定是切入点\nAOP的执行流程 AOP是基于动态代理技术，为目标对象生成一个代理对象，然后实际调用的时候是调用的代理对象\nAOP进阶 通知类型 根据通知方法执行时机的不同，将通知类型分为以下常见的五类：\n@Around：环绕通知，此注解标注的通知方法在目标方法前、后都被执行 @Around环绕通知需要自己调用 ProceedingJoinPoint.proceed()来让原始方法执行，其他通知不需要考虑目标方法执行\n@Around环绕通知方法的返回值，必须指定为Object，来接收原始方法的返回值\n@Before：前置通知，此注解标注的通知方法在目标方法前被执行 @After：后置通知，此注解标注的通知方法在目标方法后被执行，无论是否有异常都会执行 @AfterReturning： 返回后通知，此注解标注的通知方法在目标方法后被执行，有异常不会执行 @AfterThrowdng：异常后通知，此注解标注的通知方法发生异常后执行 @PointCut注解\n该注解的作用是将公共的切点表达式抽取出来，需要用到时引用该切点表达式即可。\n@Aspect @Component @Slf4j public class DemoAspect { // 定义一个pt函数，都可以调用pt来获得切入点 @Pointcut(\u0026#34;execution(* com.itheima.service.impl.*.*(..))\u0026#34;) public void pt(){} // 前置通知 @Before(\u0026#34;pt()\u0026#34;) public void before(){ log.info(\u0026#34;before....\u0026#34;); } // 后置通知 @After(\u0026#34;pt()\u0026#34;) public void after(){ log.info(\u0026#34;after....\u0026#34;); } // 环绕通知 @Around(\u0026#34;pt()\u0026#34;) public Object around(ProceedingJoinPoint pjp) throws Throwable { log.info(\u0026#34;around before....\u0026#34;); Object result = pjp.proceed(); log.info(\u0026#34;around after....\u0026#34;); return result; } // 返回后通知 @AfterReturning(\u0026#34;pt()\u0026#34;) public void afterReturning(){ log.info(\u0026#34;afterReturning....\u0026#34;); } // 异常后通知 @AfterThrowing(\u0026#34;pt()\u0026#34;) public void afterThrowing(){ log.info(\u0026#34;afterThrowing....\u0026#34;); } } 通知顺序 当有多个切面的切入点都匹配到了目标方法，目标方法运行时，多个通知方法都会被执行。\n执行顺序：\n不同切面类中，默认按照切面类的类名字母排序：\n目标方法前的通知方法：字母排名靠前的先执行 目标方法后的通知方法：字母排名靠前的后执行 用 @Order（数字）加在切面类上来控制顺序\n目标方法前的通知方法：数字小的先执行 目标方法后的通知方法：数字小的后执行 切入点表达式 介绍：描述切入点方法的一种表达式。\n作用：用来决定项目中的哪些方法需要加入通知。\n可以匹配到接口，会匹配所有接口的实现类方法，可以基于接口来匹配\n常见形式：\nexecution（\u0026hellip;.）：根据方法的签名来匹配 @annotation（\u0026hellip;.）：根据注解匹配 切入点表达式-execution @Before(\u0026#34;execution(void com.itheima.service.impl.DeptServiceImpl.delete(java.lang.Integer))\u0026#34;) @Before(\u0026#34;execution(* com.itheima.service.impl.*.*(..) )\u0026#34;) 语法：\nexecution(访问修饰符? 返回值 包名.类名.?方法名(方法参数) throws 异常?)\n其中带？的表示可以省略的部分\n访问修饰符：可省略（比如：public、protected） 包名，类名：可省略（不建议省略） throws 异常：可省略（注意是方法上声明抛出的异常，不是实际抛出的异常） 可以使用通配符描述切入点\n*：单个独立的任意符号，可以通配任意返回值、包名、类名、方法名、任意类型的一个参数，也可以通配包、类、方法名的一部分\nexecution(* com.*.service.*.update*(*)) ..：多个连续的任意符号，可以通配任意层级的包，或任意类型、任意个数的参数\nexecution(* com.itheima..DeptService.*(..)) 根据业务需要，可以使用且（\u0026amp;\u0026amp;）、或（II）、非（！）来组合比较复杂的切入点表达式。\n可以使用逻辑运算符来匹配\n切入点表达式-Annotation @Before(\u0026#34;@annotation(com.itheima.anno.LogOperation)\u0026#34;) // 这里边写的是定义的注解的全类名 public void before(){ log.info(\u0026#34;MyAspect4 -\u0026gt; before ...\u0026#34;); } // 在需要使用切入点的地方添加自定义的注解 @Override @LogOperation public void save(Dept dept) { dept.setCreateTime(LocalDateTime.now()); dept.setUpdateTime(LocalDateTime.now()); deptMapper.save(dept); } 如果execution切入点表达式方便描述指定的方法，就使用execution表达式\n否则，就使用@annotation切入点表达式\n连接点 在Spring中用JoinPoint抽象了连接点，用它可以获得方法执行时的相关信息，如目标类名、方法名、方法参数等。\n对于 @Around 通知，获取连接点信息只能使用 ProceedingJoinPoint（这个是JoinPoint的子类）\n对于其它四种通知，获取连接点信息只能使用 JoinPoint，它是 ProceedingJoinPoint 的父类型\n@Before(\u0026#34;execution(* com.itheima.service.impl.*.*(..))\u0026#34;) public void before(JoinPoint joinPoint){ // 获取目标类名 String className = joinPoint.getTarget().getClass().getName(); log.info(\u0026#34;目标类名：{}\u0026#34;,className); // 获取目标方法签名 Signature signature = joinPoint.getSignature(); log.info(\u0026#34;方法签名：{}\u0026#34;,signature); // 获取目标方法名 String methodName = joinPoint.getSignature().getName(); log.info(\u0026#34;目标方法名：{}\u0026#34;,methodName); // 获取参数 Object[] args = joinPoint.getArgs(); log.info(\u0026#34;参数：{}\u0026#34;, Arrays.toString(args)); } 运行结果：\nAOP案例 将案例中增、删、改相关接口的操作日志记录到数据库表中\n日志信息包含：操作人、操作时间、执行方法的全类名、执行方法名、方法运行时参数、返回值、方法执行时长\n采用哪种通知类型？ @Around环绕通知\n切入点表达式该怎么写？\n由于增、删、改 方法名我们定义的比较规范，分别为save、delete、update\n用execution比较复杂\n@Around(\u0026#34;execution(* com.itheima.controller.*.save(..)) ||\u0026#34; + \u0026#34;execution(* com.itheima.controller.*.delete(..)) ||\u0026#34; + \u0026#34;execution(* com.itheima.controller.*.update(..))\u0026#34;) 用annotation比较方便\n@Around(\u0026#34;@annotation(com.itheima.anno.Log)\u0026#34;) @Around(\u0026#34;@annotation(com.zzzzyj.anno.Log)\u0026#34;) public Object around(ProceedingJoinPoint joinPoint) throws Throwable { // 记录开始时间 long startTime = System.currentTimeMillis(); // 执行方法 Object result = joinPoint.proceed(); // 当前时间 long endTime = System.currentTimeMillis(); // 耗时 long costTime = endTime - startTime; // 构建日志对象 OperateLog operateLog = new OperateLog(); operateLog.setOperateEmpId(getCurrentUserId()); // 需要实现 getCurrentUserId 方法 operateLog.setOperateTime(LocalDateTime.now()); operateLog.setClassName(joinPoint.getTarget().getClass().getName()); operateLog.setMethodName(joinPoint.getSignature().getName()); operateLog.setMethodParams(Arrays.toString(joinPoint.getArgs())); operateLog.setReturnValue(result.toString()); operateLog.setCostTime(costTime); log.info(\u0026#34;日志信息{}\u0026#34;,operateLog); // 插入日志 operateLogMapper.insert(operateLog); return result; } // 示例方法，获取当前用户ID private int getCurrentUserId() { // 这里应该根据实际情况从认证信息中获取当前登录用户的ID return 1; // 示例返回值 } 获取当前用户ID没有实现\n获取当前用户ID 思考一下：用户ID存在哪里，其实是存在了jwt令牌里边，通过服务器构造的jwt令牌，里边有着ID和用户名信息\n1、员工登录成功后，哪里存储的有当前登录员工的信息？\n给客户端浏览器下发的jwt令牌中\n**2、如何从jwt令牌中获取到当前登录的员工信息？ **\n获取请求头中传递的jwt令牌，并解析\n**3. TokenFilter中已经解析了令牌的信息，如何将其传递给AOP程序、Controller、Service呢？ **ThreadLocal\n在令牌校验过滤器TokenFilter中获取了jwt令牌，并对其进行解析获取当了当前登录员工的ID，如何将这个ID传递给AOP程序、Controller、Service中呢？\nThreadLocal ThreadLocal并不是一个Thread，而是Thread的局部变量。\nThreadLocal为每个线程提供一份单独的存储空间，具有线程隔离的效果，不同的线程之间不会相互干扰。\nThreadLocal常用方法：（一共只有3个方法）\n• public void set （T value） 设置当前线程的线程局部变量的值\n• public T get（） 返回当前线程所对应的线程局部变量的值\n• public void remove（） 移除当前线程的线程局部变量\npublic class ThreadLocalTest { // 泛型指定往本地存储空间存储的是什么类型的数据 public static ThreadLocal\u0026lt;String\u0026gt; local = new ThreadLocal\u0026lt;\u0026gt;(); public static void main(String[] args) { local.set(\u0026#34;Main Message\u0026#34;); System.out.println(local.get()); new Thread(() -\u0026gt; { local.set(\u0026#34;Thread Message\u0026#34;); System.out.println(local.get()); }).start(); local.remove(); System.out.println(local.get()); } } 哪个线程存的只能哪个线程取，哪个线程删\n一次请求对应一个线程\n具体操作步骤：\n定义ThreadLocal操作的工具类，用于操作当前登录员工ID。 public class CurrentHolder { private static final ThreadLocal\u0026lt;Integer\u0026gt; CURRENT_LOCAL = new ThreadLocal\u0026lt;\u0026gt;(); public static void setCurrentId(Integer employeeId) { CURRENT_LOCAL.set(employeeId); } public static Integer getCurrentId() { return CURRENT_LOCAL.get(); } public static void remove() { CURRENT_LOCAL.remove(); } } 里边就是定义了一个静态变量ThreadLocal\n在TokenFilter中，解析完当前登录员工ID，将其存入ThreadLocal（用完之后需将其删除）。 在AOP程序中，从ThreadLocal中获取当前登录员工的ID。 用完删除这个逻辑的困惑分析 困惑产生的原因：为什么里边没有调用Aop的方法，却需要在放行之后把他删除，其实对于Filter过滤器，他的执行步骤是这样的：\n注意这两个问题，还会回到Filter中，所以在放行之后的逻辑就是用来执行清楚内容的，放行之后不是直接执行清楚操作，而是进去了Controller层\n那么我用Interceptor为什么同样的操作却不行呢\n原因：\nInterceptor里边有三个函数可以重写，我一直写在preHandle中，当然不行，他永远只是会在放行前执行，即使使用了try-finally代码块，还是不可以\n但是如果我用postHandle函数处理的话，就可以成功，因为的执行时间相当于在放行回来后\n代码如下：\n验证token的时候，将jwt令牌的id信息存在ThreadLocal中\nClaims claims = JwtUtils.parseJWT(token); String id = claims.get(\u0026#34;id\u0026#34;).toString(); CurrentHolder.setCurrentId(Integer.valueOf(id)); 在Interceptor中进行删除\n@Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { CurrentHolder.remove(); } 在Filter中进行删除\nlog.info(\u0026#34;令牌通过校验，放行\u0026#34;); filterChain.doFilter(servletRequest,servletResponse); CurrentHolder.remove(); 作业里边的日志记录遇到的bug\n这个bug的原因是用了@Controller而没有用@RestController这个注解，导致会递归访问/log/log/page这个路径\n@Controller：这是一个通用的注解，用于定义一个Spring MVC控制器。它不会提供任何额外的功能，只是告诉Spring框架这个类是一个控制器。 @RestController：这是一个特定于返回值的注解，它是@Controller和@ResponseBody的组合。这意味着任何在@RestController注解的类中定义的方法都会自动应用@ResponseBody注解，这会导致Spring框架将方法的返回值写入HTTP响应体中，而不是返回一个视图。 **\n**在Spring MVC中，@Controller和@RestController注解都用于定义控制器，但它们在处理请求路径时的行为有所不同。当你使用@Controller注解时，Spring MVC会尝试使用视图解析器来解析路径，这意味着如果你的路径中包含斜杠（/），Spring MVC可能会将其解释为视图的路径，而不是URL的一部分。这就是为什么当你使用@Controller注解并访问/log/page路径时，Spring MVC会尝试寻找/log/log/page的原因，因为它将/log解释为视图的前缀，然后继续寻找/log/page作为视图名称。\n相比之下，@RestController注解是@Controller和@ResponseBody的组合，它通常用于创建RESTful风格的Web服务。当使用@RestController时，Spring MVC不会尝试使用视图解析器来解析路径，因为@ResponseBody注解告诉Spring MVC直接将方法的返回值写入HTTP响应体中，而不是返回一个视图名称。因此，当你使用@RestController注解并访问/log/page路径时，Spring MVC会直接将请求映射到对应的处理方法，而不会尝试进一步解析视图路径。\n总结来说，@Controller注解可能会引起Spring MVC对路径的视图解析，而@RestController注解则避免了这一行为，直接将返回值作为响应体返回，这就是为什么在使用@Controller时会出现路径继续寻找的问题，而在@RestController中不会出现。\n","permalink":"https://wqnm1gb.github.io/posts/day13spring-aop/","summary":"\u003ch1 id=\"什么是aop\"\u003e什么是AOP？\u003c/h1\u003e\n\u003cp\u003e**AOP：**Aspect Oriented Programming（面向\u003c!-- raw HTML omitted --\u003e切面\u003c!-- raw HTML omitted --\u003e编程、面向方面编程），可简单理解为就是面向特定方法编程。\u003c/p\u003e","title":"Day13 Spring-AOP"},{"content":"登录功能 Controller层 // 接收登录信息 @PostMapping(\u0026#34;/login\u0026#34;) public Result login(@RequestBody Emp emp) { log.info(\u0026#34;员工登录：{}\u0026#34;, emp); LoginInfo loginInfo = empService.login(emp); if (loginInfo != null) { return Result.success(); } else { return Result.error(\u0026#34;用户名或密码错误\u0026#34;); } } 返回的信息中有token，最好重新定一个专门用来返回的类，不要直接使用Emp\nService层 public LoginInfo login(Emp emp) { // 1、查询用户密码信息 Emp e = empMapper.selectUsernameAndPassword(emp); log.info(\u0026#34;登录信息{}\u0026#34;,e); // 2、检查信息是否匹配，并且创建一个LoginInfo对象，因为里边的token信息是不会在数据库中查询到的， // 需要在Service层进行补全 if (e != null){ return new LoginInfo(e.getId(),e.getUsername(),e.getName(),e.getPassword(),\u0026#34;\u0026#34;); }else { // 3、返回结果 return null; } } Mapper层取的方法的名字可以不用和业务挂钩，直接见名知义即可\nSQL语句太简单了，就不复制过来了。\n登录校验功能 因为刚刚设置的登录功能其实是假的，因为我们可以直接绕过，并没有进行认证，就像是安全里边说的登录绕过\n登录认证的思路如下：\n因为定义的接口很多，不可能每个里边都加一个验证功能，所以加一个统一拦截的功能，这个想法很细节\n登录标记：用户登录成功之后，在后续的每一次请求中，都可以获取到该标记。【会话技术】\n统一拦截：过滤器Filter、拦截器Interceptor\n会话技术 会话：用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以包含多次请求和响应。\n会话跟踪：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间共享数据（课上举的是验证码的例子，首先客户端请求服务器响应验证码，然后登录之后，服务器响应的是新的登录请求，但是这次登录请求需要与上一次的验证码的响应进行比对，看看验证码是否输入正确）。\n会话跟踪方案：\n客户端会话跟踪技术：Cookie 服务端会话跟踪技术：Session 令牌技术 Cookie技术 优点：HTTP协议中支持的技术\nhttp支持cookie，在请求数据中包含了请求头Cookie，在响应数据中包含了响应头Set-Cookie\n在同一次会话的多次请求之间共享数据，只需要把需要共享的数据放在Cookie中\n缺点：\n移动端APP无法使用Cookie（安卓和iOS不支持） 不安全，用户可以自己禁用Cookie Cookie不能跨域（如下图所示）访问前端服务器的时候可以有Cookie，但是请求后端数据的时候，Cookie就失效了 Sessions技术 优点：存储在服务端，安全\n缺点：\n服务器集群环境下无法直接使用Session Cookie的缺点 Nginx可以做负载均衡服务器，不同的服务器没有存sessions，所以分布式的环境不适用\n访问s1，会有响应set-cookie\n访问s2，会有Cookie数据返回\n令牌技术 令牌技术是现在的主流技术\n优点：\n支持PC端、移动端 解决集群环境下的认证问题 减轻服务器端存储压力 缺点：需要自己实现\nJWT令牌 全称：JSON web Token （https://jwt.io/）\n定义了一种简洁的、自包含的格式，用于在通信双方以json数据格式安全的传输信息。\n组成：\n第一部分：Header（头），记录令牌类型、签名算法等。例如｛\u0026ldquo;alg\u0026rdquo;：\u0026ldquo;HS256\u0026rdquo;，\u0026ldquo;type\u0026rdquo;：\u0026ldquo;JWT\u0026rdquo;｝ 第二部分：Payload（有效载荷），携带一些自定义信息、默认信息等。例如：｛\u0026ldquo;id\u0026rdquo;：\u0026ldquo;1\u0026rdquo;，“username\u0026quot;：\u0026ldquo;Tom\u0026rdquo;｝ 第三部分：Signature（签名），防止Token被篡改、确保安全性。将header、payload融入，并加入指定秘钥，通过指定签名算法计算而来。 = 是base64编码中的补位符号\n签名不是 base64编码，而是基于一定的加密规则加密出来的字符串\n令牌的长度不是固定的\n生成令牌 // 生成的令牌：\u0026#34;eyJhbGciOiJIUzI1NiJ9.eyJpZCI6NSwidXNlcm5hbWUiOiJhZG1pbiIsImV4cCI6MTczNDkyNDYyNX0.qJbvnksEHOmoE-OvNDuOUVjuCG0y4EDa1Ad_jDfhYs8\u0026#34; @Test public void testJwtGenerate() { Map\u0026lt;String, Object\u0026gt; dataMap = new HashMap\u0026lt;\u0026gt;(); dataMap.put(\u0026#34;id\u0026#34;,5); dataMap.put(\u0026#34;username\u0026#34;,\u0026#34;admin\u0026#34;); String jwt = Jwts.builder(). // 生成一个jwt令牌 signWith(SignatureAlgorithm.HS256, \u0026#34;enp6enlq\u0026#34;). // 设置签名算法和密钥 addClaims(dataMap). // 设置自定义数据 setExpiration(new Date(System.currentTimeMillis() + 3600 * 1000)). // 设置过期时间，先获取现在的时间戳，再添加3600毫秒的1000倍就是一个小时 compact(); // 生成jwt令牌 System.out.println(jwt); } 解析令牌 @Test public void testJwtParse() { String token = \u0026#34;eyJhbGciOiJIUzI1NiJ9.eyJpZCI6NSwidXNlcm5hbWUiOiJhZG1pbiIsImV4cCI6MTczNDkyNDY4Nn0._nJwP9_V7Z6vaTC_nWeubmaF9W58QXHtLdOtrKuGkG0\u0026#34;; Claims claims = Jwts.parser(). setSigningKey(\u0026#34;enp6enlq\u0026#34;). parseClaimsJws(token). // 这里是s不是t 导致了错误的原因 getBody(); System.out.println(claims); } **parseClaimsJwt**方法： 这个方法适用于解析未签名的JWT。它不验证JWT的签名，只是简单地解析JWT字符串并返回一个包含载荷（Payload）的Claims对象。因此，如果你的JWT没有签名，或者你不需要验证签名，可以使用这个方法。 代码示例：Jwts.parser().parseClaimsJwt(jwt).getBody(); **parseClaimsJws**方法： 这个方法用于解析已签名的JWT。它会验证JWT的结构和签名，确保JWT是有效的。如果签名验证失败，会抛出异常。这个方法返回一个Jws\u0026lt;Claims\u0026gt;对象，其中包含了JWT的头部（Header）、载荷（Payload）和签名（Signature）。 代码示例：Jwts.parser().parseClaimsJws(token).getBody(); 令牌被篡改或者令牌过期，都会报错\nJWT校验时使用的签名秘钥，必须和生成JWT令牌时使用的秘钥是配套的\n登录成功后-生成令牌 分析：令牌是怎么来的？\n是第一次登录成功的时候，从服务器生成一个令牌传回来给客户端的，然后客户端会一直保存着\n1、定义JWT令牌操作工具类。（基于AI）\n2、登录完成后，调用工具类生成JWT令牌，并返回。\n过滤器-Filter 概念：Filter过滤器，是Javaweb三大组件（Servlet、Filter、Listener）之一。（现在只有Filter还有人用）\n过滤器可以把对资源的请求拦截下来，从而实现一些特殊的功能。\n过滤器一般完成一些通用的操作，比如：登录校验、统一编码处理、敏感字符处理等。\nFilter是在servlet下的包\n使用步骤 定义Filter：定义一个类，实现 Filter 接口，并实现其所有方法。 配置Filter：Filter类上加@WebFilter注解，配置拦截路径。引导类上加 @ServletComponentScan 开启Servlet组件支持。 @Slf4j @WebFilter public class DemoFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { log.info(\u0026#34;init方法执行了...\u0026#34;); } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { log.info(\u0026#34;doFilter方法执行了...\u0026#34;); filterChain.doFilter(servletRequest,servletResponse); } @Override public void destroy() { log.info(\u0026#34;destroy方法执行了...\u0026#34;); } } filterChain中只包含了一个方法，就是doFilter方法，用于放行\n思考：\n所有的请求，拦截到了之后，都需要校验令牌吗？有一个例外，登录请求，或者注册请求 拦截到请求后，什么情况下才可以放行，执行业务操作？有令牌，且令牌校验通过（合法）；否则都返回未登录错误结果 令牌校验Filter-流程 获取请求url。 判断请求url中是否包含login，如果包含，说明是登录操作，放行。 获取请求头中的令牌（token）。 判断令牌是否存在，如果不存在，响应401。 解析token，如果解析失败，响应401。 放行。 代码实现：\n@Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { // 1、获取请求路径 // 1.1 先把Request对象转换为HttpServletRequest对象 HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; String requestURI = request.getRequestURI(); // 2、判断是否包含登录请求 if (requestURI.contains(\u0026#34;login\u0026#34;)){ log.info(\u0026#34;登录请求，放行\u0026#34;); // 放行 filterChain.doFilter(servletRequest,servletResponse); return; } // 3、不是登录请求，就判断是否携带token String token = request.getHeader(\u0026#34;token\u0026#34;); if (token==null || token.isEmpty()){ log.info(\u0026#34;请求头中不存在token，响应401...\u0026#34;); // 4、没有携带token，就响应401 response.setStatus(HttpServletResponse.SC_UNAUTHORIZED); return; } // 5、携带了token，解析token try { JwtUtils.parseJWT(token); } catch (Exception e) { log.info(\u0026#34;令牌未通过校验，响应401\u0026#34;); response.setStatus(HttpServletResponse.SC_UNAUTHORIZED); return; } // 6、解析成功，放行 log.info(\u0026#34;令牌通过校验，放行\u0026#34;); filterChain.doFilter(servletRequest,servletResponse); } 思考：\n记得要加@WebFilter(urlPatterns = \u0026quot;/*\u0026quot;) 注解，要不然不会生效，这个注解可以指定拦截的路径，注意一个服务器里的过滤器不要冲突了\n这个代码想要实现需要逻辑比较清晰，前边的需要把对象转换成HttpServletRequest不要忘记了，本质上就是HttpServletRequest\nHttpServletResponse.SC_UNAUTHORIZED 这个的值就是401\nFilter执行流程 问题1：放行后访问对应资源，资源访问完成后，还会回到Filter中吗？会\n问题2：如果回到Filter中，是重新执行还是执行放行后的逻辑呢？执行放行后逻辑\nFilter拦截路径 根据@WebFilter里边的urlPatterns的值不同，可以拦截不同的路径\n拦截路径 urlPatterns值 含义 拦截具体路径 /login 只有访问 /login 路径时，才会被拦截 目录拦截 /emps/* 访问/emps下的所有资源，都会被拦截 拦截所有 /* 访问所有资源，都会被拦截 Filter过滤器链 介绍：一个web应用中，可以配置多个过滤器，这多个过滤器就形成了一个过滤器链。\n顺序：注解配置的Filter，优先级是按照过滤器类名（字符串）的自然排序。\n执行序号已经在图上的编号中标出来了\n拦截器-Interceptor 概念：是一种动态拦截方法调用的机制，类似于过滤器。Spring框架中提供的，主要用来动态拦截控制器方法的执行。\n作用：拦截请求，在指定的方法调用前后，根据业务需要执行预先设定的代码。\nInterceptor快速入门 拦截器是Spring提供的，需要加上@Component交给IOC容器管理\n拦截器实现的步骤：\n1、定义拦截器\n@Component @Slf4j public class DemoInterceptor implements HandlerInterceptor { // 目标方法执行前，返回TRUE放行请求，返回FALSE拦截请求 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { log.info(\u0026#34;preHandle ....\u0026#34;); return true; } // 目标方法执行后 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { log.info(\u0026#34;postHandle ....\u0026#34;); } // 视图渲染完毕后 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { log.info(\u0026#34;afterCompletion ....\u0026#34;); } } 注意有加上Component注解，加入到ioc容器中\n2、注册拦截器，定义配置类实现WebMv\n@Configuration public class WebConfig implements WebMvcConfigurer { @Autowired private DemoInterceptor demoInterceptor; // 注册自定义拦截器对象 @Override public void addInterceptors(InterceptorRegistry registry) { // 设置拦截器拦截的路径 registry.addInterceptor(demoInterceptor).addPathPatterns(\u0026#34;/**\u0026#34;); } } 在拦截器中拦截所有用的是/**\n令牌校验-拦截器 里边的逻辑和Filter一样，只需要控制返回值即可\n拦截器的放行只需要通过return的值来控制\n拦截器-拦截路径 可以在配置中配置可以放行的路径，这样就不需要判断\n@Override public void addInterceptors(InterceptorRegistry registry) { // 设置拦截器拦截的路径 registry.addInterceptor(tokenInterceptor) .addPathPatterns(\u0026#34;/**\u0026#34;) .excludePathPatterns(\u0026#34;/login\u0026#34;); } 拦截路径 含义 举例 /* 一级路径 能匹配/depts，/emps，/login，不能匹配 /depts/1 /** 任意级路径 能匹配/depts，/depts/1，/depts/1/2 /depts/* /depts下的一级路径 能匹配/depts/1，不能匹配/depts/1/2，/depts /depts/** /depts下的任意级路径 能匹配/depts，/depts/1，/depts/1/2，不能匹配/emps/1 拦截器-执行流程 拦截器是Spring提供的技术，他只会拦截对于Spring的请求，而过滤器是Servlet规范中提供的技术，所以他的拦截权限更高，可以拦截所有资源\nFilter 与 Interceptor 区别：\n接口规范不同：过滤器需要实现Filter接口，而拦截器需要实现HandlerInterceptor接口。 拦截范围不同：过滤器Filter会拦截所有的资源，而Interceptor只会拦截Spring环境中的资源。 ","permalink":"https://wqnm1gb.github.io/posts/day12%E5%90%8E%E7%AB%AFweb%E5%AE%9E%E6%88%98%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81/","summary":"\u003ch1 id=\"登录功能\"\u003e登录功能\u003c/h1\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/Day12%e5%90%8e%e7%ab%afWeb%e5%ae%9e%e6%88%98%ef%bc%88%e7%99%bb%e5%bd%95%e8%ae%a4%e8%af%81%ef%bc%89.assets/1734842185377-afcbdfcd-b857-4293-bfd7-949c29c1c2d8.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"controller层\"\u003eController层\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"c1\"\u003e//    接收登录信息\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nd\"\u003e@PostMapping\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;/login\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eResult\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003elogin\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nd\"\u003e@RequestBody\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eEmp\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eemp\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"n\"\u003elog\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003einfo\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;员工登录：{}\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eemp\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"n\"\u003eLoginInfo\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eloginInfo\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eempService\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003elogin\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eemp\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eloginInfo\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e!=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kc\"\u003enull\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e            \u003c/span\u003e\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eResult\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003esuccess\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eelse\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e            \u003c/span\u003e\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eResult\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003eerror\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;用户名或密码错误\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e返回的信息中有token，最好重新定一个专门用来返回的类，不要直接使用Emp\u003c/p\u003e","title":"Day12 后端Web实战（登录认证）"},{"content":"Controller层接收参数的时候需不需要加@RequestBody？\n如果是接受的Json格式的数据，那么需要加，如果是接受GET的参数，即使是接受到类里，也可以不用加\n注意看分页查询的时候返回的结果啊，还有个Total参数，所以一定需要定义一个单独的对象接受PageResult\nMybatis 在xml中\u0026gt;是合法的 \u0026lt;是非法的，需要改成\u0026lt;\n前端请求的信息，服务器响应回来的可以不一定和接口文档的响应信息一模一样，可以有些多的字段，且字段值为null\n如何在插入数据的时候有可选字段，在values后采用if标签\n\u0026lt;insert id=\u0026#34;add\u0026#34;\u0026gt; insert into clazz(name, room, begin_date, end_date, master_id, subject,create_time,update_time) values ( #{name}, #{room}, #{beginDate}, #{endDate}, \u0026lt;if test=\u0026#34;masterId!=null\u0026#34;\u0026gt; #{masterId}, \u0026lt;/if\u0026gt; #{subject}, #{createTime}, #{updateTime} ); \u0026lt;/insert\u0026gt; 思考一下，这样子是错误的，因为要求有这么多个参数，你不能少了，而且masterId在数据库中定义的本来就是可以为null所以不需要这个if标签即可\n如果前端传来的是Json格式的数据，请务必记得用@RequestBody注解标注后接收！！！\n自定义异常可以这么定义\npublic class ClazzNotNullException extends RuntimeException{ public ClazzNotNullException() { super(); } public ClazzNotNullException(String message) { super(message); } } 也不一定需要构造器，如果没有构造器的话，会默认调用父类的无参构造器，这时候就不能传递错误信息\n专门定义的全局异常处理器\n@ExceptionHandler public Result HandlerClazzNotNullException(ClazzNotNullException e){ log.error(\u0026#34;出错了\u0026#34;,e); return Result.error(\u0026#34;对不起, 该班级下有学生, 不能直接删除\u0026#34;); } 当需要多表联合查询的时候，请务必注意是不是需要取别名，因为定义的类，通过SQL语句可能接受不到这个变量！\n请注意：update 标签中的动态语句，改变每一个变量后边需要加逗号啊！！\n\u0026lt;update id=\u0026#34;updateById\u0026#34;\u0026gt; update student \u0026lt;set\u0026gt; \u0026lt;if test=\u0026#34;name!= null and name != \u0026#39;\u0026#39;\u0026#34;\u0026gt; name = #{name}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;no!= null and no != \u0026#39;\u0026#39;\u0026#34;\u0026gt; no = #{no}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;gender!= null\u0026#34;\u0026gt; gender = #{gender}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;phone!= null and phone != \u0026#39;\u0026#39;\u0026#34;\u0026gt; phone = #{phone}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;degree!= null\u0026#34;\u0026gt; degree = #{degree}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;idCard!= null and idCard != \u0026#39;\u0026#39;\u0026#34;\u0026gt; id_card = #{idCard}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;isCollege!= null\u0026#34;\u0026gt; is_college = #{isCollege}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;address!= null and address != \u0026#39;\u0026#39;\u0026#34;\u0026gt; address = #{address}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;graduationDate!= null\u0026#34;\u0026gt; graduation_date = #{graduationDate}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;clazzId!= null\u0026#34;\u0026gt; clazz_id = #{clazzId}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;violationCount!= null\u0026#34;\u0026gt; violation_count = #{violationCount}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;violationScore!= null\u0026#34;\u0026gt; violation_score = #{violationScore}, \u0026lt;/if\u0026gt; update_time = #{updateTime} \u0026lt;/set\u0026gt; where id = #{id} \u0026lt;/update\u0026gt; 批量删除数据，需要用标签\n如果通过路径参数传递了多个参数，需要这么接受\n@PostMapping(\u0026#34;/{id}/{score}\u0026#34;) public Result violation(@PathVariable Integer id,@PathVariable Short score){ } 突然发现的一个问题\nselect count(*) count,dept_id from dept d left join emp e on d.id = e.dept_id where d.id=11 group by dept_id; 这个语句会把我在emp中表里边部门为null的人也统计上\n原因是什么呢，是左表连接\n分析一下左表连接\nselect 字段列表 from 表1 left [outer] join 表2 on 连接条件 \u0026hellip;;\n这里的左表是表1，也就是说，表1里边的所有数据都会保留，即使右表没有对应的数据，也会显示为null，所以说上边写的把部门为null的人统计上是错的，因为只是右表没有人，所以显示为null，这里最好用右表连接或者内连接，或者换个逻辑，因为已经知道id的值了，根本不需要连接查询，直接在emp表里边找就好了\n","permalink":"https://wqnm1gb.github.io/posts/day11%E5%90%8E%E7%AB%AFweb%E5%AE%9E%E6%88%98%E7%8F%AD%E7%BA%A7%E5%AD%A6%E5%91%98/","summary":"\u003cp\u003e\u003cstrong\u003eController层接收参数的时候需不需要加@RequestBody？\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e如果是接受的Json格式的数据，那么需要加，如果是接受GET的参数，即使是接受到类里，也可以不用加\u003c/p\u003e","title":"Day11 后端Web实战（班级学员）"},{"content":"删除员工 删除员工基本信息的时候，也要删除员工的工作经历\n各层的职责 Controller层 接收请求参数：DELETE /emps?ids=1,2,3\n方式1：通过数组来接收 @DeleteMapping public Result delete(Integer[] ids){ // 通过数组的方式接收参数 log.info(\u0026#34;要删除的id是{}\u0026#34;, Arrays.toString(ids)); return Result.success(); } 方式2：通过集合来接收 @DeleteMapping public Result delete(@RequestParam List\u0026lt;Integer\u0026gt; ids){ // 通过数组的方式接收参数 log.info(\u0026#34;要删除的id是{}\u0026#34;,ids); return Result.success(); } 如果想让前端传过来的参数保存到像list这样比较复杂的类型中，需要加上@RequestParam修饰\n一般会封装到list集合中，方便进行开发\n记得要指定分隔符啊！！！\nService层 @Transactional(rollbackFor = Exception.class) @Override public void deleteByIds(List\u0026lt;Integer\u0026gt; ids) { // 删除员工基本信息 empMapper.deleteByIds(ids); // 删除员工工作经历 empExprMapper.deleteByEmpIds(ids); } 事物控制，一定要全部执行完\nMapper层 删除工作经历\n\u0026lt;delete id=\u0026#34;deleteByEmpIds\u0026#34;\u0026gt; delete from emp_expr where emp_id in \u0026lt;foreach collection=\u0026#34;empIds\u0026#34; item=\u0026#34;empId\u0026#34; separator=\u0026#34;,\u0026#34; open=\u0026#34;(\u0026#34; close=\u0026#34;)\u0026#34;\u0026gt; #{empId} \u0026lt;/foreach\u0026gt; \u0026lt;/delete\u0026gt; collection：指定遍历的集合名字\nitem：遍历出来的对象的名字\nseparator：分隔符\nopen：开始前需要的符号\nclose：结束后需要的符号\n删除工作基本信息\n\u0026lt;delete id=\u0026#34;deleteByIds\u0026#34;\u0026gt; delete from emp where id in \u0026lt;foreach collection=\u0026#34;ids\u0026#34; item=\u0026#34;id\u0026#34; separator=\u0026#34;,\u0026#34; open=\u0026#34;(\u0026#34; close=\u0026#34;)\u0026#34;\u0026gt; #{id} \u0026lt;/foreach\u0026gt; \u0026lt;/delete\u0026gt; 修改员工 查询回显 三层架构 Controller层 @GetMapping(\u0026#34;/{id}\u0026#34;) public Result getById(@PathVariable Integer id){ log.info(\u0026#34;想要查询的id是{}\u0026#34;,id); Emp emp = empService.getById(id); return Result.success(emp); } 注意这里传递的是路径参数，必须要用@PathVariable参数指定，但是里边的value值可以省略，如果接受参数和定义的参数名字一样的话\nService层 @Override public Emp getById(Integer id) { Emp emp = empMapper.getById(id); return emp; } 没啥好说的，就是很普通的调用Mapper层\nMapper层 \u0026lt;resultMap id=\u0026#34;findId\u0026#34; type=\u0026#34;com.zzzzyj.pojo.Emp\u0026#34; \u0026gt; \u0026lt;id column=\u0026#34;id\u0026#34; property=\u0026#34;id\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;username\u0026#34; property=\u0026#34;username\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;password\u0026#34; property=\u0026#34;password\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;name\u0026#34; property=\u0026#34;name\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;gender\u0026#34; property=\u0026#34;gender\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;phone\u0026#34; property=\u0026#34;phone\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;job\u0026#34; property=\u0026#34;job\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;salary\u0026#34; property=\u0026#34;salary\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;image\u0026#34; property=\u0026#34;image\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;entry_date\u0026#34; property=\u0026#34;entryDate\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;dept_id\u0026#34; property=\u0026#34;deptId\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;create_time\u0026#34; property=\u0026#34;createTime\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;update_time\u0026#34; property=\u0026#34;updateTime\u0026#34;/\u0026gt; \u0026lt;collection property=\u0026#34;exprList\u0026#34; ofType=\u0026#34;com.zzzzyj.pojo.EmpExpr\u0026#34;\u0026gt; \u0026lt;id column=\u0026#34;ee_id\u0026#34; property=\u0026#34;id\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;ee_emp_id\u0026#34; property=\u0026#34;empId\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;ee_begin\u0026#34; property=\u0026#34;begin\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;ee_end\u0026#34; property=\u0026#34;end\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;ee_company\u0026#34; property=\u0026#34;company\u0026#34;/\u0026gt; \u0026lt;result column=\u0026#34;ee_job\u0026#34; property=\u0026#34;job\u0026#34;/\u0026gt; \u0026lt;/collection\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;!-- 查询员工信息回显--\u0026gt; \u0026lt;select id=\u0026#34;getById\u0026#34; resultMap=\u0026#34;findId\u0026#34;\u0026gt; select e.*,ee.id ee_id,ee.emp_id ee_emp_id , ee.begin ee_begin , ee.end ee_end , ee.company ee_company , ee.job ee_job from emp e left join emp_expr ee on e.id = ee.emp_id where e.id = #{id}; \u0026lt;/select\u0026gt; Mybatis中封装查询结果，什么时候用 resultType，什么时候用resul Map？\n• 如果查询返回的字段名与实体的属性名可以直接对应上，用resultType。\n• 如果查询返回的字段名与实体的属性名对应不上，或实体属性比较复杂，可以通过resultMap手\n动封装。\n主键用来封装，其他的普通类型用封装\ncolum表示要查询的字段，property表示要封装到的地方\n封装集合的标签是\n修改数据 Controller层 @PutMapping public Result updateById(@RequestBody Emp emp){ log.info(\u0026#34;修改的员工数据是{}\u0026#34;,emp); empService.updateById(emp); return Result.success(); } 这里没什么特殊的，就是普通的调用Service层，但是注意，由于传来的JSON格式的数据，接收的时候请加上@RequestBody\nService层 @Override public void updateById(Emp emp) { // 更新员工基本信息 emp.setUpdateTime(LocalDateTime.now()); empMapper.updateById(emp); // 更新员工工作经历信息 // 1、先删除之前的信息 empExprMapper.deleteByEmpIds(Arrays.asList(emp.getId())); List\u0026lt;EmpExpr\u0026gt; exprList = emp.getExprList(); if(!CollectionUtils.isEmpty(exprList)){ // 如果不是空的，需要赋值给empId for (EmpExpr empExpr : exprList) { empExpr.setEmpId(emp.getId()); } // 2、更新新增的工作经历信息 empExprMapper.insertBatch(exprList); } } 这里注意，要怎么更新工作经历信息呢，修改工作经历的最好方法是先删再加，就是先把数据都删了，在根据输入的数据增加，因为给出的数据可能会不定的改变，注意增加工作经历的时候，传过来的JSON的数据，是没有员工Id信息的，所以需要先判断员工工作经历是否为空，如果不为空，需要为员工id赋值\n这里需要注意的点：删除可以所以有人都删除，但是增加一定要确保有工作经历再添加！\nMapper层 \u0026lt;!-- 更新员工信息--\u0026gt; \u0026lt;update id=\u0026#34;updateById\u0026#34;\u0026gt; update emp set username = #{username} , password = #{password},name = #{name}, gender= #{gender},phone = #{phone}, job=#{job},salary=#{salary},image=#{image}, entry_date=#{entryDate},dept_id=#{deptId},update_time=#{updateTime} where id = #{id}; \u0026lt;/update\u0026gt; 没啥好讲的，就是普通的update语句，记得update的格式 update 表名 set 字段名=新的值 where 修改的条件\n还有一个思考：之前想的如果我不改密码，是不是密码传递过去会为空值，事实上不是这样的，如果不改动的话，由于信息是查询过来的，所以是不会改变的，只有改变前端更改的值，才会记录到新的Emp中，如果没有更改就是之前的值，但是还是更建议用动态SQL\n动态SQL\n\u0026lt;update id=\u0026#34;updateById\u0026#34;\u0026gt; update emp \u0026lt;set\u0026gt; \u0026lt;if test=\u0026#34;username != null and username!= \u0026#39;\u0026#39;\u0026#34;\u0026gt;username = #{username},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;password != null and password!= \u0026#39;\u0026#39;\u0026#34;\u0026gt;password = #{password},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;name != null and name!= \u0026#39;\u0026#39;\u0026#34;\u0026gt;name = #{name},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;gender != null\u0026#34;\u0026gt;gender = #{gender},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;phone != null and phone != \u0026#39;\u0026#39;\u0026#34;\u0026gt;phone = #{phone},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;job != null\u0026#34;\u0026gt;job = #{job},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;salary != null\u0026#34;\u0026gt;salary = #{salary},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;image != null and image != \u0026#39;\u0026#39;\u0026#34;\u0026gt;image = #{image},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;entryDate != null\u0026#34;\u0026gt;entry_date = #{entryDate},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;deptId != null\u0026#34;\u0026gt;dept_id = #{deptId},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;updateTime != null\u0026#34;\u0026gt;update_time = #{updateTime},\u0026lt;/if\u0026gt; \u0026lt;/set\u0026gt; where id = #{id} \u0026lt;/update\u0026gt; Mybatis中的标签，会自动生成set关键字，而且会自动删除掉更新后多余的,\n异常处理 如果项目出现异常，会一层一层往调用他的层抛出\n方式1：try-catch 代码臃肿，不推荐\n方式2：全局异常处理器 全局异常处理器的两个注解\n1、类上的@RestControllerAdvice=@ControllerAdvice + @ResponseBody\n2、方法上的@ExceptionHandler\n一般异常处理会放在一个单独的包中\n寻找异常的匹配是从下往上找，找到第一个匹配的类\n@ExceptionHandler public Result HandlerException(Exception e){ log.error(\u0026#34;出错了\u0026#34;,e); return Result.error(\u0026#34;服务器故障，请稍后再试\u0026#34;); } @ExceptionHandler public Result HandlerDuplicateKeyException(DuplicateKeyException e){ log.error(\u0026#34;出错了\u0026#34;,e); String msg = e.getMessage(); int duplicateEntry = msg.indexOf(\u0026#34;Duplicate entry\u0026#34;); String substring = msg.substring(duplicateEntry); String[] s = substring.split(\u0026#34; \u0026#34;); return Result.error(s[2]+\u0026#34;已存在\u0026#34;); } 员工信息统计 职位统计 用的是Echarts图表\n首先根据接口文档发现需要传输的数据是 所以可以传递两个list集合回去\n不指定list的类型就是可以传递所有的类型，但是不够安全\n三层的职责 Controller层 @GetMapping(\u0026#34;/empJobData\u0026#34;) public Result getEmpJobData(){ log.info(\u0026#34;统计各个员工数量\u0026#34;); JobOption jobOption = reportService.getEmpJobData(); return Result.success(jobOption); } 没啥好说的，就是简单的调用了Service层\nService层 @Override public JobOption getEmpJobData() { List\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; mapList = empMapper.countJob(); // 这里拿到的流是一个一个的Map集合 List\u0026lt;Object\u0026gt; jobList = mapList.stream().map(datamap -\u0026gt; datamap.get(\u0026#34;pos\u0026#34;)).toList(); List\u0026lt;Object\u0026gt; dataList = mapList.stream().map(datamap -\u0026gt; datamap.get(\u0026#34;count\u0026#34;)).toList(); JobOption jobOption = new JobOption(jobList, dataList); return jobOption; } 这里分析一下：\n通过Mapper层拿到的是什么数据？\n定义了List\u0026lt;Map\u0026lt;String,Object\u0026raquo;这个数据类型\n得到的mapList集合是：\n一共有6个list集合元素，每个list集合里边包括了两个Map集合，这就是为什么第二个Map需要用Object的原因\n通过Stream流获取的jobList是 jobData是类似的，注意领会Stream中map操作，其实就是对LIst里边的元素进行操作，List里边是啥呀，是map所以可以对map的key取出value\nMapper层 \u0026lt;!-- 查询员工数量--\u0026gt; \u0026lt;select id=\u0026#34;countJob\u0026#34; resultType=\u0026#34;java.util.Map\u0026#34;\u0026gt; select (case when job = 1 then \u0026#39;班主任\u0026#39; when job = 2 then \u0026#39;讲师\u0026#39; when job = 3 then \u0026#39;学工主管\u0026#39; when job = 4 then \u0026#39;教研主管\u0026#39; when job = 5 then \u0026#39;咨询师\u0026#39; else \u0026#39;其他\u0026#39; end) pos, count(*) count from emp group by job order by count; \u0026lt;/select\u0026gt; 用到MySQL中的case函数\n第一种形式（只用于等值匹配）：\ncase 表达式 when val1 then result1 when val2 then result2 \u0026hellip;.. else \u0026hellip; end\n把val的值变成result值\n第二种形式：\ncase when 表达式1 then result1 when 表达式2 then result2 \u0026hellip;.. else \u0026hellip; end\n性别统计 性别统计和统计职位没有太大的区别\nController层 @GetMapping(\u0026#34;/empGenderData\u0026#34;) public Result getEmpGenderData(){ log.info(\u0026#34;统计员工性别数量\u0026#34;); return Result.success(reportService.getEmpGenderData()); } Service层 @Override public List\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; getEmpGenderData() { List\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; mapList = empMapper.countGender(); return mapList; } 这里因为需要传递的数据是：\n所以直接传递回去一个List\u0026lt;Map\u0026lt;\u0026gt;\u0026lt;\u0026raquo;就行，不需要额外的定义一个实体类\nMapper层 \u0026lt;!-- 统计性别数量--\u0026gt; \u0026lt;select id=\u0026#34;countGender\u0026#34; resultType=\u0026#34;java.util.Map\u0026#34;\u0026gt; select (if(gender=1,\u0026#39;男性员工\u0026#39;,\u0026#39;女性员工\u0026#39;)) \u0026#39;name\u0026#39; , count(*) \u0026#39;value\u0026#39; from emp group by gender; \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; MySQL中的if函数\n只有两种条件时\nif(条件, true_value, false_value)\n","permalink":"https://wqnm1gb.github.io/posts/day10%E5%90%8E%E7%AB%AFweb%E5%AE%9E%E6%88%98%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86/","summary":"\u003ch1 id=\"删除员工\"\u003e删除员工\u003c/h1\u003e\n\u003cp\u003e删除员工基本信息的时候，也要删除员工的\u003cstrong\u003e工作经历\u003c/strong\u003e\u003c/p\u003e\n\u003ch2 id=\"各层的职责\"\u003e各层的职责\u003c/h2\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/Day10%e5%90%8e%e7%ab%afWeb%e5%ae%9e%e6%88%98%ef%bc%88%e5%91%98%e5%b7%a5%e7%ae%a1%e7%90%86%ef%bc%89.assets/1734397133960-7907666e-107f-466c-83b7-767b1af6e49c.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"controller层\"\u003eController层\u003c/h2\u003e\n\u003cp\u003e接收请求参数：DELETE /emps?ids=1,2,3\u003c/p\u003e\n\u003ch3 id=\"方式1通过数组来接收\"\u003e方式1：通过数组来接收\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nd\"\u003e@DeleteMapping\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eResult\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003edelete\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eInteger\u003c/span\u003e\u003cspan class=\"o\"\u003e[]\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eids\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"c1\"\u003e// 通过数组的方式接收参数\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"n\"\u003elog\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003einfo\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;要删除的id是{}\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eArrays\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003etoString\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eids\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eResult\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003esuccess\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"方式2通过集合来接收\"\u003e方式2：通过集合来接收\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nd\"\u003e@DeleteMapping\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eResult\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003edelete\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nd\"\u003e@RequestParam\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eList\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eInteger\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eids\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"c1\"\u003e// 通过数组的方式接收参数\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"n\"\u003elog\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003einfo\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;要删除的id是{}\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003eids\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eResult\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003esuccess\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e如果想让前端传过来的参数保存到像list这样比较复杂的类型中，需要加上@RequestParam修饰\u003c/p\u003e","title":"Day10 后端Web实战（员工管理）"},{"content":"新增员工 Controller层 @PostMapping public Result add(@RequestBody Emp emp){ // RequestBody用于接收Json格式的数据 log.info(\u0026#34;新增的员工数据是{}\u0026#34;,emp); empService.add(emp); return Result.success(); } Controller层只负责接收前端传来的Json格式的信息，接收之后把信息发给Service层进行进一步的操作，这层中不需要分隔出基本员工信息和员工工作经历\nService层 @Override public void add(Emp emp) { // 因为有两张表，一个是员工工作经历，一个是员工信息，要保存到两张表中 // 1、保存员工信息 // 设置更新时间字段 emp.setCreateTime(LocalDateTime.now()); emp.setUpdateTime(LocalDateTime.now()); empMapper.insert(emp); // 2、保存员工工作经历，可以没有工作经历，所以需要判断 List\u0026lt;EmpExpr\u0026gt; exprlist = emp.getExprList(); if(!CollectionUtils.isEmpty(exprlist)){ // 遍历集合，为empId赋值 exprlist.forEach(expr-\u0026gt;expr.setEmpId(emp.getId())); empExprMapper.insertBatch(exprlist); } } Service层需要向Mapper层发送两个请求，一个需要保存员工的信息，另一个需要保存员工的工作经历，保存工作经历的时候需要判断员工是否有工作经历，如果没有工作经历可以不保存\n保存工作经历的时候需要存储员工的id，这个id是插入了员工才有的，所以需要在Mapper层获取插入后的员工的id后才可以先给对象中的id赋值，然后插入到员工工作经历表中，用的是@Options(useGeneratedKeys = true,keyProperty = \u0026ldquo;id\u0026rdquo;)\n进行获取，其中第一个参数指定获取主键，第二个参数指定赋值到的地方\n这里遇到的bug，无法获取主键id，我把SQL语句写到xml文件中了，重新写到Mapper文件中就恢复正常，应该是注解的定义出了问题\nMapper层 // 第一个参数是表示获取主键，第二个参数是给参数赋值到类中的id中 @Options(useGeneratedKeys = true,keyProperty = \u0026#34;id\u0026#34;) @Insert(\u0026#34; insert into emp(username,password,name,gender,phone,job,salary,image,entry_date,dept_id,create_time,update_time)\u0026#34; + \u0026#34; values(#{username},#{password},#{name},#{gender},#{phone},#{job},#{salary},#{image},#{entryDate},#{deptId},#{createTime},#{updateTime})\u0026#34;) void insert(Emp emp); @Mapper public interface EmpExprMapper { void insertBatch(List\u0026lt;EmpExpr\u0026gt; exprList); } 使用foreach语句 \u0026lt;mapper namespace=\u0026#34;com.zzzzyj.mapper.EmpExprMapper\u0026#34;\u0026gt; \u0026lt;insert id=\u0026#34;insertBatch\u0026#34;\u0026gt; insert into emp_expr(emp_id, begin, end, company, job) values \u0026lt;foreach collection=\u0026#34;exprList\u0026#34; item=\u0026#34;expr\u0026#34; separator=\u0026#34;,\u0026#34;\u0026gt; (#{expr.empId},#{expr.begin},#{expr.end},#{expr.company},#{expr.job}) \u0026lt;/foreach\u0026gt; \u0026lt;/insert\u0026gt; \u0026lt;/mapper\u0026gt; 属性说明：foreach可以用来批量保存数据，如果有数据会继续添加，如果没有就不添加\ncollection： 集合名称\nitem： 集合遍历出来的元素/项\nseparator：每一次遍历使用的分隔符\nopen：遍历开始前拼接的片段\nclose：遍历结束后拼接的片段\n事物 概念：事务 是一组操作的集合，它是一个不可分割的工作单位。事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作 要么同时成功，要么同时失败。\n默认MySQL的事务是自动提交的，也就是说，当执行一条DML语句，MySQL会立即隐式的提交事务。\n-- 开启事务 start transaction; / begin; -- 1. 保存员工基本信息insert into emp values (39, \u0026#39;Tom\u0026#39;, \u0026#39;123456\u0026#39;, \u0026#39;汤姆\u0026#39;, 1, \u0026#39;13300001111\u0026#39;, 1, 4000, \u0026#39;1.jpg\u0026#39;, \u0026#39;2023-11-01\u0026#39;, 1, now(), now()); -- 2. 保存员工的工作经历信息insert into emp_expr(emp_id, begin, end, company, job) values (39,\u0026#39;2019-01-01\u0026#39;, \u0026#39;2020-01-01\u0026#39;, \u0026#39;百度\u0026#39;, \u0026#39;开发\u0026#39;), (39,\u0026#39;2020-01-10\u0026#39;, \u0026#39;2022-02-01\u0026#39;, \u0026#39;阿里\u0026#39;, \u0026#39;架构\u0026#39;); -- 提交事务(全部成功) / 回滚事务(有一个失败) commit; / rollback; 事务的隔离性：为什么在表的显示中看不到事物执行没提交的数据，在select语句中却可以看到，因为事物的隔离性\n如何控制事务？\n• 开启事务：start transaction/begin；\n• 提交事务：commit；（全部成功）\n• 回滚事务：rollback；（只要有一项失败）\nSpring事物管理 注解：@Transactional\n默认是出现运行时异常RuntimeException才会回滚\n作用：将当前方法交给spring进行事务管理，方法执行前，开启事务；成功执行完毕，提交事务；出现异常，回滚事务\n位置：业务（service）层的方法上、类上、接口上\n@Transactional方法加在类上，表示类中的所有方法都需要进行事务控制，加在接口上，所有实现类都需要进行事务控制，推荐加在方法上，只对方法进行事务控制。\n这个方法要对数据库进行多次的增删改，如果是一次就没必要加，一次失败就失败了\n配置特定类的日志级别为debug，那么就能看到事物的执行\n事物进阶-rollbackFor rollbackFor属性，可以控制什么异常需要回滚，默认只有运行时异常会回滚\n@Transactional(rollbackFor = {Exception.class}) 这个的意思是所有的异常都需要回滚\n事务进阶-propagation rollbackFor和propagation都是@transactional的属性\npropagation属性控制的是-当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行事务控制\n一个事物里边调用了另一个事物\n属性值 含义 REQUIRED 【默认值】需要事务，有则加入，无则创建新事务 REQUIRES_NEW 需要新事务，无论有无，总是创建新事务 SUPPORTS 支持事务，有则加入，无则在无事务状态中运行 NOT_SUPPORTED 不支持事务，在无事务状态下运行,如果当前存在已有事务,则挂起当前事务 MANDATORY 必须有事务，否则抛异常 NEVER 必须没事务，否则抛异常 . . . 事物的四大特性（ACID） **原子性：**事务是不可分割的最小单元，要么全部成功，要么全部失败\n**一致性：**事务完成时，必须使所有的数据都保持一致状态\n**隔离性：**数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行\n**持久性：**事务一旦提交或回滚，它对数据库中的数据的改变就是永久的\n——、\n文件上传 **文件上传：**是指将本地图片、视频、音频等文件上传到服务器，供其他用户浏览或下载的过程。\n文件上传在项目中应用非常广泛，我们经常发微博、发微信朋友圈都用到了文件上传功能。\n这里边的文件需要用MultipartFile类型的参数接收，这个类型是Spring框架提供的，上传的文件只会是临时文件，因为没有定义接收到的地方，并且一定要有enctype这个属性，要不然无法上传文件内容\n上传文件到本地 @PostMapping(\u0026#34;/upload\u0026#34;) public Result upload(String name, Integer age, MultipartFile file) throws IOException { log.info(\u0026#34;接收参数{},{},{}\u0026#34;, name, age, file); // 获取文件扩展名 String originalFilename = file.getOriginalFilename(); // substring截取，给定一个索引就是从这个索引之后的都截取，最后一个.的索引 String extension = originalFilename.substring(originalFilename.lastIndexOf(\u0026#34;.\u0026#34;)); // 组合成一个新的名字 String fileName = UUID.randomUUID().toString() + extension; // 保存文件 file.transferTo(new File(\u0026#34;/Users/lengshao/Desktop/study/开发学习/java-web/day09-后端开发（员工管理）/上传的文件/\u0026#34;+fileName)); return Result.success(); } 用uuid不会重复\n调用file.transferTo()可以存储文件\n默认只能接受1MB的大小，可以在yml中进行修改\n最大请求大小（包括所有文件和表单数据）\nservlet: multipart: # 最大上传文件限制 max-file-size: 10MB # 最大请求文件（包括所有文件和表单数据） max-request-size: 100MB 阿里云OSS 阿里云对象存储OSS （Object Storage Service），是一款海量、安全、低成本、高可靠的云存储服务。使用OSS，您可以通过网络随时存储和调用包括文本、图片、音频和视频等在内的各种文件。\n第三方服务使用的通用思路 SDK: Software Development Kit 的缩写，软件开发工具包，包括辅助软件开发的依赖（jar包)、代码示例等，都可以叫做SDK。\n阿里云oss-使用步骤 Bucket：存储空间是用户用于存储对象（Object，就是文件）的容器，所有的对象都必须隶属于某个存储空间。\nbucket相当于是一个存储空间，上传的内容要存到bucket里边\npublic class Demo { public static void main(String[] args) throws Exception { // Endpoint以华东1（杭州）为例，其它Region请按实际情况填写。 String endpoint = \u0026#34;https://oss-cn-beijing.aliyuncs.com\u0026#34;; // 从环境变量中获取访问凭证。运行本代码示例之前，请确保已设置环境变量OSS_ACCESS_KEY_ID和OSS_ACCESS_KEY_SECRET。 EnvironmentVariableCredentialsProvider credentialsProvider = CredentialsProviderFactory.newEnvironmentVariableCredentialsProvider(); // 填写Bucket名称，例如examplebucket。 String bucketName = \u0026#34;java-web-study01\u0026#34;; // 填写Object完整路径，例如exampledir/exampleobject.txt。Object完整路径中不能包含Bucket名称。 String objectName = \u0026#34;1.txt\u0026#34;; // 填写Bucket所在地域。以华东1（杭州）为例，Region填写为cn-hangzhou。 String region = \u0026#34;cn-beijing\u0026#34;; // 创建OSSClient实例。 ClientBuilderConfiguration clientBuilderConfiguration = new ClientBuilderConfiguration(); clientBuilderConfiguration.setSignatureVersion(SignVersion.V4); OSS ossClient = OSSClientBuilder.create() .endpoint(endpoint) .credentialsProvider(credentialsProvider) .clientConfiguration(clientBuilderConfiguration) .region(region) .build(); try { File file = new File(\u0026#34;/Users/lengshao/Desktop/study/开发学习/java-web/day09-后端开发（员工管理）/04. 文件上传/中国梦.txt\u0026#34;); byte[] content = Files.readAllBytes(file.toPath()); ossClient.putObject(bucketName, objectName, new ByteArrayInputStream(content)); } catch (OSSException oe) { System.out.println(\u0026#34;Caught an OSSException, which means your request made it to OSS, \u0026#34; + \u0026#34;but was rejected with an error response for some reason.\u0026#34;); System.out.println(\u0026#34;Error Message:\u0026#34; + oe.getErrorMessage()); System.out.println(\u0026#34;Error Code:\u0026#34; + oe.getErrorCode()); System.out.println(\u0026#34;Request ID:\u0026#34; + oe.getRequestId()); System.out.println(\u0026#34;Host ID:\u0026#34; + oe.getHostId()); } catch (ClientException ce) { System.out.println(\u0026#34;Caught an ClientException, which means the client encountered \u0026#34; + \u0026#34;a serious internal problem while trying to communicate with OSS, \u0026#34; + \u0026#34;such as not being able to access the network.\u0026#34;); System.out.println(\u0026#34;Error Message:\u0026#34; + ce.getMessage()); } finally { if (ossClient != null) { ossClient.shutdown(); } } } } 案例集成 用value属性赋值，导包导的是Spring中的，不是Lombok的，可以拿到yml配置文件中的值\n优化1:参数化配置 指将一些需要灵活变化的参数，配置在配置文件中，然后通过@Value注解来注入外部配置的属性。 @Value(\u0026quot;${key}\u0026quot;)\n使用@Value注解注入配置文件的配置项，如果配置项多，注入繁琐，不便于维护管理 和 复用。\n优化2:@ConfigurationProperties 再定义一个工具类，这个类用来存放配置参数，用@ConfigurationProperties修饰来获取yml配置中的数据，prefix的意思是前缀的意思\n1．注入外部配置文件中的配置项的两种方式？\n@Value：一个属性一个属性的注入 @ConfigurationProperties： 批量将多个属性注入到bean对象中 2. 两种方式各自的使用场景？\n如果属性较少，建议@value注入即可 如果属性较多，考虑复用，建议使用@ConfigurationProperties ","permalink":"https://wqnm1gb.github.io/posts/day09%E5%90%8E%E7%AB%AFweb%E5%AE%9E%E6%88%98%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86/","summary":"\u003ch1 id=\"新增员工\"\u003e新增员工\u003c/h1\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/Day09%e5%90%8e%e7%ab%afWeb%e5%ae%9e%e6%88%98%ef%bc%88%e5%91%98%e5%b7%a5%e7%ae%a1%e7%90%86%ef%bc%89.assets/1734051333476-6c2aeeae-d132-4863-84b7-12863c88958b.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003ch2 id=\"controller层\"\u003eController层\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nd\"\u003e@PostMapping\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eResult\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nf\"\u003eadd\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nd\"\u003e@RequestBody\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eEmp\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eemp\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"c1\"\u003e// RequestBody用于接收Json格式的数据\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"n\"\u003elog\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003einfo\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;新增的员工数据是{}\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003eemp\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"n\"\u003eempService\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003eadd\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eemp\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eResult\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003esuccess\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eController层只负责接收前端传来的Json格式的信息，接收之后把信息发给Service层进行进一步的操作，这层中不需要分隔出基本员工信息和员工工作经历\u003c/p\u003e","title":"Day09 后端Web实战（员工管理）"},{"content":"多表关系 项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结构。由于业务之间相互关联，所以各个表结构之间也存在着各种联系。\n多表关系分为三种： 一对一（多对一） 一对一 多对多 一对多 一对多的关系，只需要在多的一方增加一个字段，关联一的主键即可\n现象：部门数据可以直接删除，然而还有部分员工归属于该部门下，此时就出现了数据的不完整、不一致问题\n原因：目前上述的两张表，在数据库层面，并未建立关联，所以是无法保证数据的一致性和完整性的\n解决方案：外键约束\n创建表的时候增加外键约束：\n-- 创建表时指定 create table 表名( 字段名 数据类型, ... [constraint] [外键名称] foreign key (外键字段名) references 主表 (字段名)\t); 创建表后，修改表增加外键约束\n-- 建完表后，添加外键 alter table 表名 add constraint 外键名称 foreign key (外键字段名) references 主表(字段名); 物理外键：\n概念：使用 foreign key 定义外键关联另外一张表。\n缺点：\n影响增、删、改的效率（需要检查外键关系） 仅用于单节点数据库，不适用与分布式、集群场景 容易引发数据库的死锁问题，消耗性能 逻辑外键：\n概念：在业务层逻辑中，解决外键关联\n通过逻辑外键，就可以很方便的解决上述问题\n现在的项目中，基本不用物理外键了\n一对一 案例：用户 与 身份证信息 的关系\n关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他字段放在另一张表中，以提升操作效率\n实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE）\n一对一的外键可以加在任意一方\n多对多 案例：学生 与 课程的关系\n关系：一个学生可以选修多门课程，一门课程也可以供多个学生选择\n实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键\n案例 员工工作经历属于附表信息，他的createtime和updatetime是跟随主表（员工表）走的，所以可以不用这两个字段，但是id必须有的\n多表查询 多表查询：指从多张表中查询数据\n笛卡尔积：所有组合的结果\n要根据条件，消除无效的笛卡尔积\n查询的分类：\n连接查询 内连接：相当于查询A、B交集部分数据（内连接，查询到的是两个表的交集的信息）\n外连接\n- 左外连接：查询\u0026lt;font style=\u0026quot;background-color:#FBDE28;\u0026quot;\u0026gt;左表\u0026lt;/font\u0026gt;所有数据（包括两张表交集部分数据） - 右外连接：查询\u0026lt;font style=\u0026quot;background-color:#FBDE28;\u0026quot;\u0026gt;右表\u0026lt;/font\u0026gt;所有数据（包括两张表交集部分数据） 子查询 内连接 内连接查询的是两张表交集部分的数据。具体语法为：\n-- 1.隐式内连接 (常见) select 字段列表 from 表1 , 表2 where 连接条件 ...; -- 2.显式内连接 select 字段列表 from 表1 [inner] join 表2 on 连接条件 ... ; -- 1.给表起别名,来简化书写 select 字段列表 from 表1 [as] 别名1, 表2 [as] 别名2 where 条件 ...; inner（可以省略） join表示的是显式内连接，on表示的是联查的条件\n一旦为了表起别名，就不能用表名了，必须得用别名\n外连接 外连接分为左外连接和右外连接。具体语法为：\n-- 1.左外连接 (常见) select 字段列表 from 表1 left [outer] join 表2 on 连接条件 ...; -- 2.右外连接 select 字段列表 from 表1 right [outer] join 表2 on 连接条件 ...; 左外连接会包含左表的所有数据（用的比较多），右外连接会包含右表的所有数据\n左外连接和右外连接可以互相替换的\n对于外连接，常用的是左外连接，因为右外连接的SQL也可以改造成为左外连接（两张表调换个顺序）。\n子查询 介绍：SQL语句中嵌套select语句，称为嵌套查询，又称子查询。\n形式：select * from t1 where column1 = （select columnl from t2 ..）；\n说明：子查询外部的语句可以是insert / update / delete / select 的任何一个，最常见的是 select。\n分类：\n标量子查询：子查询返回的结果为单个值 列子查询：子查询返回的结果为一列 行子查询：子查询返回的结果为一行 select * from emp where (salary,job) = (select salary,job from emp where name = \u0026#34;李忠\u0026#34;); 注意这种写法，同时判断两个值相同，可以不写两个select语句（性能差），可以直接写一个括号来表示\n表子查询：子查询返回的结果多行多列 子查询的要点是，先对需求做拆分，明确具体的步骤，然后再逐步编写SQL语句。\n注意在SQL中出现的中文，请使用\u0026rsquo;\u0026lsquo;包裹，不要使用\u0026quot;\u0026quot;\n一个表中的所有信息，可以是e.*\n员工列表查询 准备工作 1．准备数据库表emp、emp_expr\n2．准备实体类 Emp、EmpExpr\n3． 准备三层架构的基本代码结构：EmpController、EmpService/EmpServiceImpl、EmpMapper\n分页查询 limit 需要跟着两个参数 起始索引和每页展示记录数，起始索引从0开始\n需要专门定义一个分页结果的封装类来接收数据，一个用来封装总记录数，一个给定数据，在类上定义一个泛型，可以把这个泛型传递到定义的实例对象上\n原始方式 Controller层 // 这里只需要通过调用Service层来获取参数 @GetMapping public Result page(@RequestParam(defaultValue = \u0026#34;1\u0026#34;) Integer page, @RequestParam(defaultValue = \u0026#34;10\u0026#34;) Integer pageSize){ log.info(\u0026#34;请求的参数{}{}\u0026#34;,page,pageSize); PageResult\u0026lt;Emp\u0026gt; pageResult = empService.page(page,pageSize); return Result.success(pageResult); } 注意，如果要指定不传入的时候的默认参数，需要使用的是**@RequestParam(defaultValue = \u0026ldquo;1\u0026rdquo;)这个参数，这是SpringBoot框架提供的**\nService层 public PageResult\u0026lt;Emp\u0026gt; page(Integer page, Integer pageSize) { Long total = empMapper.count(); Integer start = (page-1)*pageSize; List\u0026lt;Emp\u0026gt; list = empMapper.list(start,pageSize); PageResult\u0026lt;Emp\u0026gt; pageResult = new PageResult\u0026lt;\u0026gt;(total,list); return pageResult; } 注意page和start的换算，需要(page-1)*pageSize\nMapper层 @Mapper public interface EmpMapper { /** * 查询总共记录数 */ @Select(\u0026#34;select count(*) from emp e left join dept d on e.dept_id = d.id\u0026#34;) public Long count(); /** * 查询结果列表 */ @Select(\u0026#34;select e.*,d.name deptName from emp e left join dept d on e.dept_id = d.id limit #{start},#{size}\u0026#34;) public List\u0026lt;Emp\u0026gt; list(Integer start,Integer size); } PageHelper方法 Service层 @Override public PageResult\u0026lt;Emp\u0026gt; page(Integer page, Integer pageSize) { //1、设置分页参数 PageHelper.startPage(page,pageSize); // 2、调用Mapper方法 List\u0026lt;Emp\u0026gt; list = empMapper.list(); //3、解析结果并封装 Page\u0026lt;Emp\u0026gt; p = (Page\u0026lt;Emp\u0026gt;) list; return new PageResult\u0026lt;\u0026gt;(p.getTotal(),p.getResult()); } 第一步是设置参数，给PageHelper设置参数之后，执行的SQL语句才能返回正确的结果\n第二步是接收结果，通过调用Mapper层的函数实现接收结果\n第三步是解析结果，因为Page继承了List，所以可以用强转为Page，利用了多态，最后再调用Page里的方法，返回相应的参数\n为什么要强转为Page格式？\n因为直接输出list集合不可以，里边包括的数据不只有查询到的数据，还有其他的相关信息，所以需要强转为Page格式，通过里边的函数输出想要的信息\nPageHelper的实现机制 PageHelper会拦截SQL语句，会对这个SQL语句进行改造\n注意事项\n1、SQL语句结尾不要加分号（；），会导致拼接错误，实际上的改造就是拼接上了limit语句，如果加上了分号，就会拼接错误\n2、PageHelper只会对紧跟在其后的第一条SQL语句进行分页处理\n分页条件查询 @DateTimeFormat注解指定前端传递的日期格式\n@DateTimeFormat(pattern = \u0026ldquo;yyyy-MM-dd\u0026rdquo;) 用LocalDateTime来接收时间参数\n？不能出现在\u0026rsquo;\u0026lsquo;之内，不然会被认为是字符串的一部分，对应于Mybatis中是在\u0026rsquo;\u0026lsquo;之内，不能使用#{}，可以使用${}进行拼接，但是这种方法性能不好，所以更推荐采用concat函数，是MySQL中提供的字符串拼接函数\nxml需要同包同名\n@RequestParam注解的使用场景？\n• @RequestParam 接收请求参数，参数名不一致时\n• @RequestParam 设置请求参数的默认值\n@DateTimeFormat的使用场景？\n• 用于接收日期时间类型的参数，指定日期格式\n• @DateTimeFormat（pattern=\u0026ldquo;yyyy-MM-dd\u0026rdquo;）\n程序优化之把传递的参数指定一个对象接收 如果controller方法的参数较多，且未来可能继续增加，这会使得方法签名变得复杂难以维护，此时可以考虑将多个请求参数封装为一个对象。\n请求参数：/emps?name=张\u0026amp;gender=1\u0026amp;begin=2007-09-01\u0026amp;end=2022-09-01\u0026amp;page=1\u0026amp;pagesize=10\n@Data public class EmpQueryParam { private Integer page = 1; private Integer pageSize = 10; private String name; private Integer gender; @DateTimeFormat(pattern = \u0026#34;yyyy-MM-dd\u0026#34;) private LocalDate begin; @DateTimeFormat(pattern = \u0026#34;yyyy-MM-dd\u0026#34;) private LocalDate end; } 注意：\n参数名一定要和对象的成员变量名相同，如果有赋初值的需要，可以直接在对象里写上他的初始值\n如果是传进来一个对象，SQL语句会自动去找对象里边的同名参数\n如果请求参数少，可以在Controller方法中定义一个一个的形参接收\n如果请求参数多，可以在Controller方法中定义一个对象接收\n程序优化之动态SQL \u0026lt;mapper namespace=\u0026#34;com.zzzzyj.mapper.EmpMapper\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;list\u0026#34; resultType=\u0026#34;com.zzzzyj.pojo.Emp\u0026#34;\u0026gt; select e.*,d.name from emp e left join dept d on e.dept_id = d.id \u0026lt;where\u0026gt; -- 字符串要确定不是空串也不是null \u0026lt;if test=\u0026#34;name != null and name != \u0026#39;\u0026#39;\u0026#34;\u0026gt; e.name like concat(\u0026#39;%\u0026#39;,#{name},\u0026#39;%\u0026#39;) \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;gender != null\u0026#34;\u0026gt; and e.gender = #{gender} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;begin != null and end != null\u0026#34;\u0026gt; and e.entry_date between #{begin} and #{end} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; order by update_time desc \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 随着用户的输入或外部条件的变化而变化的SQL语句，我们称为 动态SQL。\n：判断条件是否成立，如果条件为true，则拼接SQL。\n：根据查询条件，来生成where关键字，并会自动去除条件前面多余的and或or。请注意，并不能删除and或者or，一定得要有and或or\n这里遇到的bug，怎么查都查不出来，重写了xml文件中的sql语句\n","permalink":"https://wqnm1gb.github.io/posts/day08%E5%90%8E%E7%AB%AFweb%E5%AE%9E%E6%88%98%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86/","summary":"\u003ch1 id=\"多表关系\"\u003e多表关系\u003c/h1\u003e\n\u003cp\u003e项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结构。由于业务之间相互关联，所以各个表结构之间也存在着各种联系。\u003c/p\u003e","title":"Day08 后端Web实战（员工管理）"},{"content":"开发规范 前后端分离开发 具体的开发流程\n前端开发的服务部署在Nginx服务器上边，后端开发的服务部署在Tomcat服务器上边\nRest风格 REST （REpresentational state Transfer），表述性状态转换，它是一种软件架构风格。\nREST风格url 请求方式 含义 http://localhost:8080/users/1 GET 查询id为1的用户 http://localhost:8080/users/1 DELETE 删除id为1的用户 http://localhost:8080/users POST 新增用户 http://localhost:8080/users PUT 修改用户 URL定位资源\nHTTP****动词描述操作\n简洁、规范、优雅\n1．REST是风格，是约定方式，约定不是规定，可以打破。\n描述功能模块通常使用复数形式（加s），表示此类资源，而非单个资源。如：users、books\u0026hellip; APIFOX 介绍：Apifox是一款集成了Api文档、Api调试、Api Mock、Api测试的一体化协作平台。\n作用：接口文档管理、接口请求测试、Mock服务。\n在Mybatis框架中，持久层的名字不叫做dao叫做Mapper\n工程搭建 创建SpringBoot工程，并引入web开发起步依赖、mybatis、mysqL驱动、lombok。 创建数据库表dept，并在application.ymL中配置数据库的基本信息。 准备基础代码结构，并引入实体类Dept及统一的响应结果封装类 Result。 空项目的准备：\n创建一个空项目 检查Maven的路径 改项目的字符集编码 部门查询功能 Controller层 // 使用RestController注解会把返回的对象转换成json格式给到页面 @RestController public class DeptController { @Autowired private DeptService deptService; @GetMapping(\u0026#34;/depts\u0026#34;) public Result list(){ List\u0026lt;Dept\u0026gt; depts= deptService.findAll(); return Result.success(depts); } } 使用GetMapping可以限定只能用Get方式进行请求\nGET方式：@GetMapping POST方式：@PostMapping PUT方式：@PutMapping DELETE方式：@DeleteMapping 另一种方式限定用Get请求：\n@RequestMapping(value=\u0026quot;/depts\u0026quot;,method=RequestMothod.GET)\n405请求用的方法不允许，比如说只允许使用GET请求，但是却用了POST\nService层 // @Service注解是加在实现类上边的，不是加在接口上 @Service public class DeptServiceImpl implements DeptService { @Autowired private DeptMapper deptMapper; @Override public List\u0026lt;Dept\u0026gt; findAll() { return deptMapper.findAll(); } } Mapper层 @Mapper public interface DeptMapper { // 查询结果的返回值会自动到List集合中，规则是实体类的属性名和数据库查询返回的字段名需要一致 @Select(\u0026#34;select id, name, create_time, update_time from dept;\u0026#34;) List\u0026lt;Dept\u0026gt; findAll(); } 数据封装 实体类属性名 和 数据库表查询返回的字段名一致，mybatis会自动封装。\n如果实体类属性名 和 数据库表查询返回的字段名不一致，不能自动封装。\n方式1：手动结果封装 通过 @Results及@Result号 进行手动结果映射。\n@Results({ @Result(column =\u0026#34;create_time\u0026#34; ,property =\u0026#34;createTime\u0026#34; ), @Result(column = \u0026#34;update_time\u0026#34;,property = \u0026#34;updateTime\u0026#34;) }) 方式2：起别名 @Select(\u0026#34;select id, name, create_time createTime, update_time updateTime from dept;\u0026#34;) 方式3：开启驼峰命名开关（推荐） （要求：xxx_abc-\u0026gt;xxxAbc）\nmybatis: configuration: map-underscore-to-camel-case: true 前后端联调测试 前端工程请求服务器的地址为http://localhost:90/api/depts，是如何访问到后端的tomcat服务器的？\n因为使用了反向代理\n反向代理是一种网络架构，通过代理服务器为后端的服务器做代理，客户端的请求直接请求代理服务器，然后转发给后端的服务器。（安全、灵活、负载均衡）\n前端不会直接知道后端服务器的ip地址，可以保证一定的安全性，后端如果新增了服务器，前端也不需要知道，变得更加的灵活，而且多个后端服务器可以负载均衡，可以发来一次请求，就让一个不同的后端服务器进行处理\nnginx中的配置文件 1.location：用于定义匹配路径匹配的规则。\n2.^~ /api/：表示精确匹配，即只匹配以/api/开头的路径。\n3.rewrite：该指令用于重写匹配到的路径。\n4.proxy_pass：该指令用于代理转发，它将匹配到的请求转发给位于后端的指令服务器。\n删除部门 Controller层 方式一：通过原始的 HttpServletRequest 对象获取请求参数 @DeleteMapping(\u0026#34;/depts\u0026#34;) public Result delete(HttpServletRequest request){ String idStr=request.getParameter(\u0026#34;id\u0026#34;); // 把String字符串转换为int类型 int id = Integer.parseInt(idStr); System.out.println(\u0026#34;要删除的id是\u0026#34;+id); return Result.success(); } 繁琐，手动类型转换\n方式二：通过Spring提供的@RequestParam注解，将请求参数绑定给方法形参 @DeleteMapping(\u0026#34;/depts\u0026#34;) public Result delete(@RequestParam(\u0026#34;id\u0026#34;) Integer deptId){ System.out.println(\u0026#34;根据ID删除部门: \u0026#34; + deptId); return Result.success(); } @RequestParam注解required属性默认为true，代表该参数必须传递，如果不传递将报错。如果参数可选，可以将属性设置为false。\n方式三：如果请求参数名与形参变量名相同，直接定义方法形参即可接收。（省略@RequestParam，推荐使用） @DeleteMapping(\u0026#34;/depts\u0026#34;) public Result delete(Integer id){ System.out.println(\u0026#34;根据ID删除部门: \u0026#34; + id); return Result.success(); } 新增部门 由于有creat_time和update_time两个属性没有补全，需要在Service层进行补全\n新增操作需要的数据是从POST请求传过去的\nController层 接收json格式的请求参数：POST /depts ｛\u0026ldquo;name\u0026rdquo;：\u0026ldquo;教研部\u0026rdquo;｝\nJSON格式的参数，通常会使用一个实体对象进行接收。\n规则：JSON数据的键名与方法形参对象的属性名相同，并需要使用@RequestBody注解标识。\n@RequestBody可以将一个Json格式的请求数据直接封装到对象当中\n@PostMapping(\u0026#34;/depts\u0026#34;) public Result add(@RequestBody Dept dept){ deptService.add(dept); System.out.println(dept); return Result.success(); } Service层 @Override public void add(Dept dept) { dept.setCreateTime(LocalDateTime.now()); dept.setUpdateTime(LocalDateTime.now()); deptMapper.add(dept); } 给时间这个属性赋值，调用库LocalDateTime\nMapper层 @Insert(\u0026#34;insert into dept(name, create_time, update_time) values(#{name}, #{createTime}, #{updateTime})\u0026#34;) void add(Dept dept); 修改部门 修改部门有两个操作，一般修改操作都会有两个操作：1、查询回显 2、修改数据\n查询回显 接收的参数是路径参数，需要用/depts/{id} 来接收\nController层 @GetMapping(\u0026#34;/depts/{id}\u0026#34;) public Result getById(@PathVariable(\u0026#34;id\u0026#34;) Integer id){ System.out.println(\u0026#34;想要查询的id是\u0026#34;+id); Dept dept=deptService.getById(id); return Result.success(dept); } 路径参数接收\n\u0026lt;font style=\u0026quot;color:rgb(216,57,49);\u0026quot;\u0026gt;/depts/1\u0026lt;/font\u0026gt;，\u0026lt;font style=\u0026quot;color:rgb(216,57,49);\u0026quot;\u0026gt;/depts/2\u0026lt;/font\u0026gt; 这种在url中传递的参数，我们称之为路径参数。 那么如何接收这样的路径参数呢 ？\n路径参数：通过请求URL直接传递参数，使用{…}来标识该路径参数，需要使用 **\u0026lt;font style=\u0026quot;color:rgb(46,161,33);\u0026quot;\u0026gt;@PathVariable\u0026lt;/font\u0026gt;**获取路径参数。\n注意需要使用注解@PathVariable，如果要赋值的参数和接收的参数名字一样可以简写\n如果路径参数名与controller方法形参名称一致，\u0026lt;font style=\u0026quot;color:rgb(46,161,33);\u0026quot;\u0026gt;@PathVariable\u0026lt;/font\u0026gt;注解的value属性是可以省略的。\n@GetMapping(\u0026#34;/depts/{id}\u0026#34;) public Result getById(@PathVariable Integer id) 在url中是否可以携带多个路径参数呢，如：/depts/1/0\n答：可以，接收方式如下\n修改数据 用的是PUT请求（一般用于更新或者修改数据）\n@PutMapping(\u0026#34;/depts\u0026#34;) public Result update(@RequestBody Dept dept){ deptService.update(dept); System.out.println(\u0026#34;需要更新的部门是\u0026#34;+dept); return Result.success(); } @RequestMapping 每一个请求都包括了(\u0026quot;/depts\u0026quot;)\n可以把这个整体抽象到类的上边\n一个完整的请求路径，应该是类上的 @RequestMapping 的value属性 + 方法上的 @RequestMapping的value属性。\n日志技术 Slf4j提供的是一套日志操作的接口，最终底层执行的还是Log4j或者Logback的底层日志框架\nLogback快速入门 准备工作：引入logback的依赖（springboot项目中该依赖已传递）、配置文件logback.xml。\n记录日志：定义日志记录对象Logger，记录日志。\n步骤 1、准备工作：引入logback的依赖（springboot中无需引入，在springboot中已经传递了此依赖）\n2、引入配置文件logback.xml\n3、记录入职：定义日志记录对象Logger：\npublic class LogTest { //定义日志记录对象 private static final Logger log = LoggerFactory.getLogger(LogTest.class); @Test public void testLog(){ log.debug(\u0026#34;开始计算...\u0026#34;); int sum = 0; int[] nums = {1, 5, 3, 2, 1, 4, 5, 4, 6, 7, 4, 34, 2, 23}; for (int i = 0; i \u0026lt; nums.length; i++) { sum += nums[i]; } log.info(\u0026#34;计算结果为: \u0026#34;+sum); log.debug(\u0026#34;结束计算...\u0026#34;); } } 配置文件详解 配置文件名：logback.xml\n该配置文件是对Logback日志框架输出的日志进行控制的，可以来配置输出的格式、位置及日志开关等。\n常用的两种输出日志的位置：控制台、系统文件\n\u0026lt;!-- 控制台输出 --\u0026gt; \u0026lt;appender name=\u0026#34;STDOUT\u0026#34; class=\u0026#34;ch.qos.logback.core.ConsoleAppender\u0026#34;\u0026gt;...\u0026lt;/appender\u0026gt; \u0026lt;!-- 系统文件输出 --\u0026gt; \u0026lt;appender name=\u0026#34;FILE\u0026#34; class=\u0026#34;ch.qos.logback.core.rolling.RollingFileAppender\u0026#34;\u0026gt;...\u0026lt;/appender\u0026gt; 开启日志或者关闭日志\n\u0026lt;root level=\u0026#34;ALL\u0026#34;\u0026gt; \u0026lt;appender-ref ref=\u0026#34;STDOUT\u0026#34; /\u0026gt; \u0026lt;appender-ref ref=\u0026#34;FILE\u0026#34; /\u0026gt; \u0026lt;/root\u0026gt; level=ALL指定输出所有的日志\nlevel=OFF指定关闭所有的日志输出（不用指定大小写）\n如果给的值是一个日志级别，那么只会输出这个日志级别及以上的日志信息\nLogback日志级别 日志级别指的是日志信息的类型，日志都会分级别，常见的日志级别如下（级别由低到高）：\n日志级别 说明 记录方式 trace 追踪，记录程序运行轨迹 【使用很少】 log.trace(\u0026quot;\u0026hellip;\u0026quot;) debug 调试，记录程序调试过程中的信息，实际应用中一般将其视为最低级别 【使用较多】 log.debug(\u0026quot;\u0026hellip;\u0026quot;) info 记录一般信息，描述程序运行的关键事件，如：网络连接、io操作 【使用较多】 log.info(\u0026quot;\u0026hellip;\u0026quot;) warn 警告信息，记录潜在有害的情况 【使用较多】 log.warn(\u0026quot;\u0026hellip;\u0026quot;) error 错误信息 【使用较多】 log.error(\u0026quot;\u0026hellip;\u0026quot;) 可以在配置文件中，灵活的控制输出那些类型的日志。\n\u0026lt;root level=\u0026#34;info\u0026#34;\u0026gt; \u0026lt;appender-ref ref=\u0026#34;STDOUT\u0026#34; /\u0026gt; \u0026lt;appender-ref ref=\u0026#34;FILE\u0026#34; /\u0026gt; \u0026lt;/root\u0026gt; 有Lombok后直接用注释@Sfl4j 就会生成一个日志对象\n在logback中提供了简化方式，如果输出的字符串里边的参数很多，需要用加号拼接很麻烦，可以使用{}占位符，调用info方法的时候，有多少个占位符，传递多少个参数，会自动替换，就可以避免字符串的拼接\n简化了这个代码：这个代码只有类的字节码文件需要改变\nprivate static final Logger log = LoggerFactory.getLogger(LogTest.class);\n\u0026lt;!--格式化输出：%d 表示日期，%thread 表示线程名，%-5level表示级别从左显示5个字符宽度，%msg表示日志消息，%n表示换行符 --\u0026gt; \u0026lt;pattern\u0026gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50}-%msg%n\u0026lt;/pattern\u0026gt; SSS是需要显示毫秒，logger{50}是最多显示50个字符，如果超过了50个字符，会自动简写\n","permalink":"https://wqnm1gb.github.io/posts/day07%E5%90%8E%E7%AB%AFweb%E5%AE%9E%E6%88%98%E9%83%A8%E9%97%A8%E7%AE%A1%E7%90%86/","summary":"\u003ch1 id=\"开发规范\"\u003e开发规范\u003c/h1\u003e\n\u003ch2 id=\"前后端分离开发\"\u003e前后端分离开发\u003c/h2\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/Day07%e5%90%8e%e7%ab%afWeb%e5%ae%9e%e6%88%98%ef%bc%88%e9%83%a8%e9%97%a8%e7%ae%a1%e7%90%86%ef%bc%89.assets/1733106041883-ae50ca98-077f-4fca-8d85-f63a67e1b6e3.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e具体的开发流程\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/Day07%e5%90%8e%e7%ab%afWeb%e5%ae%9e%e6%88%98%ef%bc%88%e9%83%a8%e9%97%a8%e7%ae%a1%e7%90%86%ef%bc%89.assets/1733106103374-a306fb38-330f-4082-8f06-c4285c961d85.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e前端开发的服务部署在Nginx服务器上边，后端开发的服务部署在Tomcat服务器上边\u003c/p\u003e\n\u003ch2 id=\"rest风格\"\u003eRest风格\u003c/h2\u003e\n\u003cp\u003eREST （REpresentational state Transfer），表述性状态转换，它是一种软件架构风格。\u003c/p\u003e","title":"Day07 后端Web实战（部门管理）"},{"content":" JDBC介绍 JDBC：（Java DataBase Connectivity），就是使用Java语言操作关系型数据库的一套API。\n本质：\n• sun公司官方定义的一套操作所有关系型数据库的规范，即接口。\n• 各个数据库厂商去实现这套接口，提供数据库驱动jar包。\n• 我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。\nJDBC入门程序 例子：更新数据库中的内容\n@Test public void testJdbc() throws Exception { // 1 注册驱动 这个是固定的 Class.forName(\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;); // 2 获取连接 String url = \u0026#34;jdbc:mysql://localhost:3306/web01\u0026#34;; String user = \u0026#34;root\u0026#34;; String password = \u0026#34;wsnbb1234\u0026#34;; Connection connection = DriverManager.getConnection(url, user, password); // 3 获取SQL语句执行对象 statement对象才能执行SQL语句 Statement statement = connection.createStatement(); // 4 执行SQL语句 这里边的i是用来收取影响的行数 int i =statement.executeUpdate(\u0026#34;update user set age = 25 where id = 1\u0026#34;); // 5 释放资源 statement.close(); connection.close(); } 注册驱动相当于告知应用程序是那一套jdbc的实现\nJDBC查询数据 需求：基于JDBC执行如下select语句，将查询结果封装到User对象中。\nSQL:select * from user where username = \u0026lsquo;daqiao\u0026rsquo;and password = \u0026lsquo;123456\u0026rsquo;\n执行查询语句之后会返回一个结果集对象：\nResultSet（结果集对象）：ResultSet rs = statement.executeQuery（）\nnext（）：将光标从当前位置向前移动一行，并判断当前行是否为有效行，返回值为boolean。 true：有效行，当前行有数据 false：无效行，当前行没有数据 getXxx（..）：获取数据，可以根据列的编号获取，也可以根据列名获取（推荐）。 while (resultSet.next()) { int id = resultSet.getInt(\u0026#34;id\u0026#34;); //...省略 } prepareStatement可以为占位符赋值的SQL语句执行对象\n占位符的起始是从1开始的\n@Test public void testQuery() throws Exception { // 获取连接 Connection conn = DriverManager.getConnection(\u0026#34;jdbc:mysql://localhost:3306/web01\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;wsnbb1234\u0026#34;); // 创建预编译的PreparedStatement对象 PreparedStatement pstmt = conn.prepareStatement(\u0026#34;SELECT * FROM user WHERE username = ? AND password = ?\u0026#34;); // 设置参数 pstmt.setString(1, \u0026#34;daqiao\u0026#34;); // 第一个问号对应的参数 pstmt.setString(2, \u0026#34;123456\u0026#34;); // 第二个问号对应的参数 // 执行查询 ResultSet rs = pstmt.executeQuery(); // 处理结果集 while (rs.next()) { int id = rs.getInt(\u0026#34;id\u0026#34;); String uName = rs.getString(\u0026#34;username\u0026#34;); String pwd = rs.getString(\u0026#34;password\u0026#34;); String name = rs.getString(\u0026#34;name\u0026#34;); int age = rs.getInt(\u0026#34;age\u0026#34;); System.out.println(\u0026#34;ID: \u0026#34; + id + \u0026#34;, Username: \u0026#34; + uName + \u0026#34;, Password: \u0026#34; + pwd + \u0026#34;, Name: \u0026#34; + name + \u0026#34;, Age: \u0026#34; + age); } // 关闭资源 rs.close(); pstmt.close(); conn.close(); } 预编译SQL 静态SQL（参数预编码）\nStatement statement = connection.createStatement(); int i = statement.executeUpdate(\u0026#34;update user set age = 25 where id = 1\u0026#34;); System.out.println(\u0026#34;SQL执行完毕, 影响的记录数为: \u0026#34; + i); 预编译SQL（参数动态传递）\nPreparedStatement pstmt = conn.prepareStatement(\u0026#34;SELECT * FROM user WHERE username = ? AND password = ?\u0026#34;); pstmt.setString(1, \u0026#34;daqiao\u0026#34;); pstmt.setString(2, \u0026#34;123456\u0026#34;); ResultSet resultSet = pstmt.executeQuery(); 优势 1、可以防止SQL注入，更安全\nSQL注入：通过控制输入来修改事先定义好的SQL语句，以达到执行代码对服务器进行攻击的方法。\n2、性能高\nMybatis Mybatis入门程序 配置连接信息\n#数据库访问的url地址 spring.datasource.url=jdbc:mysql://localhost:3306/web01 #数据库驱动类类名 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver #访问数据库-用户名 spring.datasource.username=root #访问数据库-密码 spring.datasource.password=wsnbb1234 编写Mybatis程序：编写Mybatis的持久层接口，定义SQL语句（注解）\n在创建出来的springboot工程中，在引导类所在包下，在创建一个包 mapper。\nUserMapper，这是一个持久层接口（Mybatis的持久层接口规范一般都叫 XxxMapper）。\nUserMapper接口的内容如下： 包下创建一个接口\nimport com.itheima.pojo.User; import org.apache.ibatis.annotations.Mapper; import org.apache.ibatis.annotations.Select; import java.util.List; @Mapper public interface UserMapper { /** * 查询全部 */ @Select(\u0026#34;select * from user\u0026#34;) public List\u0026lt;User\u0026gt; findAll(); } 注解说明：\n@Mapper注解：表示是mybatis中的Mapper接口 程序运行时，框架会自动生成接口的实现类对象（代理对象），并给交Spring的IOC容器管理\n@Select注解：代表的就是select查询，用于书写select查询语句 单元测试\n在创建出来的SpringBoot工程中，在src下的test目录下，已经自动帮我们创建好了测试类，并且在测试类上已经添加了注解 @SpringBootTest，代表该测试类已经与SpringBoot整合。\n该测试类在运行时，会自动通过引导类加载Spring的环境（IOC容器）。我们要测试那个bean对象，就可以直接通过@Autowired 注解直接将其注入进行，然后就可以测试了。\n这里一定要注意IOC容器的生效的地方，要想生效，还需要被组件扫描注解@ComponentScan扫描。\n该注解虽然没有显式配置，但是实际上已经包含在了启动类声明注解@SpringBootAppljcatjon 中，默认扫描的范围是启动类所在包及其子包。 @SpringBootTest class SpringbootMybatisQuickstartApplicationTests { @Autowired private UserMapper userMapper; @Test public void testFindAll(){ List\u0026lt;User\u0026gt; userList = userMapper.findAll(); for (User user : userList) { System.out.println(user); } } } 辅助配置-配置Mybatis的日志输出 默认情况下，在Mybatis中，SQL语句执行时，我们并看不到SQL语句的执行日志。加入如下配置，即可查看日志：\n#mybatis的配置mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl JDBC vs Mybatis Mybatis解决硬编码：把连接数据库的信息放置在单独的配置文件中，不用改java代码，改java代码需要重新编译，改配置文件不需要\nMybatis解决获取资源繁琐：自动会解析数据到对象中\nMybatis解决频繁连接，释放连接，资源浪费性能降低：用到了数据库连接池\n数据库连接池 数据库连接池是个容器，负责分配、管理数据库连接（Connection）。 它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个。 释放空闲时间超过最大空闲时间的连接，来避免因为没有释放连接而引起的数据库连接遗漏。（数据库连接池会检测客户端连接的空闲时间，如果空闲时间超过了规定的最大空闲时间，会让连接归还给数据库连接池，解决数据库连接遗漏的问题） 优势：\n资源重用 提升系统响应速度 避免数据库连接遗漏 标准接口：DataSource\n官方（sun）提供的数据库连接池接口，由第三方组织实现此接口（一定要实现） 功能：获取连接 Connection getConnection（） throws SQLException； 后两个是比较常用的\nDruid（德鲁伊）\nDruid连接池是阿里巴巴开源的数据库连接池项目 功能强大，性能优秀，是Java语言最好的数据库连接池之一 使用方法：\n在pro.xml中引入依赖\n\u0026lt;dependency\u0026gt; \u0026lt;!-- Druid连接池依赖 --\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;druid-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.19\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 在application.properties中配置数据库连接：\nspring.datasource.type=com.alibaba.druid.pool.DruidDataSource spring.datasource.druid.driver-class-name=com.mysql.cj.jdbc.Driver spring.datasource.druid.url=jdbc:mysql://localhost:3306/web spring.datasource.druid.username=root spring.datasource.druid.password=1234 Delete操作 Mapper接口：\n@Delete(\u0026#34;delete from user where id = #{id}\u0026#34;) public Integer deleteById(Integer id); DML语句执行完毕的返回值，表示该DML语句执行完毕影响的行数。\n里边的#{id}会用id来替换（名字要一样，并不是根据名字的，而是只有一个正好数目匹配上了）\n#{id}这个会被替换成? 符合预编译SQL的优势\n符号 说明 场景 优缺点 #{…} 占位符。执行时，会将#{…}替换为?，生成预编译SQL 参数值传递 安全、性能高 （推荐） ${…} 拼接符。直接将参数拼接在SQL语句中，存在SQL注入问题 表名、字段名动态设置时使用 不安全、性能低 ${\u0026hellip;}用的很少，是拼接的SQL\n@Delete(\u0026#34;delete from dept where id = #{id}\u0026#34;) @Select(\u0026#34;select id,name,score from ${tableName} order by ${sortField}\u0026#34;) Insert操作 Mapper接口：\n@Insert(\u0026#34;insert into user(username,password,name,age) values(#{username},#{password},#{name},#{age})\u0026#34;) public void insert(User user); 用$替换#可能会报错，原因是：将 \u0026lt;font style=\u0026quot;color:rgb(6, 6, 7);\u0026quot;\u0026gt;#{}\u0026lt;/font\u0026gt; 改为 \u0026lt;font style=\u0026quot;color:rgb(6, 6, 7);\u0026quot;\u0026gt;${}\u0026lt;/font\u0026gt; 后，MyBatis 不再使用预处理语句，而是直接将参数值拼接到 SQL 语句中，这可能会导致 SQL语法错误\n使用对象的方式插入，里边写的是对象的属性名而不是表中字段名\n主键是自增的，如果之前的号码使用过，即使是删除了（4，5），这些号码（4，5）还是不会重复使用，会从一个没用过的开始自增（6）\nUpdate操作 Mapper接口：\n@Update(\u0026#34;update user set username=#{username}, password=#{password}, name=#{name}, age=#{age} where id=#{id}\u0026#34;) public void update(User user); Select操作 Mapper接口：\n@Select(\u0026#34;select * from user where username=#{username} and password=#{password}\u0026#34;) public User findByUsernameAndPassword(@Param(\u0026#34;username\u0026#34;) String username, @Param(\u0026#34;password\u0026#34;) String password); 不止一个参数的时候，需要为形参取名字用@Param\n@Param注解的作用是为接口的方法形参起名字的\n#{}里写的是为Param为这个参数起的名字\n基于springboot官方骨架创建出来的项目在pom.xml里边都会有一个父工程，接口编译时会保留方法形参名， @Param注解可以省略\n**查询操作有返回值，一定要把返回值接收 **\nXML映射配置 在Mybatis中，既可以通过注解配置SQL语句，也可以通过XML配置文件配置SQL语句。\n默认规则：\nXML映射文件的名称与Mapper接口名称一致，并且将XML映射文件和Mapper接口放置在相同包下（同包同名）。 XML映射文件的namespace属性为Mapper接口全限定名一致。 XML映射文件中Sq1语句的id与Mapper 接口中的方法名一致，并保持返回类型一致。 xml中的id属性值是这个SQL语句的唯一标识，并且属性值要和方法名保持一致\nresources下的目录不能用.分隔，因为不是包，只是普通的目录需要用/分隔 编写xml文件中的映射文件，xml映射文件中的dtd约束，直接从mybatis官网复制即可; 或者直接AI生成\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;https://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;\u0026#34;\u0026gt; \u0026lt;/mapper\u0026gt; result type 指的是查询返回的单条语句往哪里进行封装，是单条，不是List集合，而是User对象\n二选一定义，要么基于注解，要么基于xml\n使用Mybatis的注解，主要是来完成一些简单的增删改查功能。如果需要实现复杂的SQL功能，建议使用XML来配置映射语句。\nSpringBoot配置文件 SpringBoot项目提供了多种属性配置方式（properties、yaml、yml）\n一般使用yml格式\nyml配置文件 格式：\n数值前边必须有空格，作为分隔符 使用缩进表示层级关系，缩进时，不允许使用Tab键，只能用空格（idea中会自动将Tab转换为空格） 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可 ＃ 表示注释，从这个字符一直到行尾，都会被解析器忽略 在yml格式的配置文件中，如果配置项的值是以0开头的，值需要使用\u0026rsquo;\u0026lsquo;引起来，因为以0开头在yml中表示8进制的数据。\n定义对象/Map集合：\nuser: name: 张三 age: 18 password: 123456 定义数组/List/Set集合：\nhobby: - java - game - sport spring: application: name: springboot-mybatis-quickstar datasource: type: com.alibaba.druid.pool.DruidDataSource url: jdbc:mysql://localhost:3306/web01 username: root password: wsnbb1234 mybatis: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl ","permalink":"https://wqnm1gb.github.io/posts/day06java%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/Day06Java%e6%93%8d%e4%bd%9c%e6%95%b0%e6%8d%ae%e5%ba%93.assets/1732677227599-0381eba1-2488-49b4-bc90-da0c210c5184-20250224204816892.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003ch1 id=\"jdbc介绍\"\u003eJDBC介绍\u003c/h1\u003e\n\u003cp\u003eJDBC：（Java DataBase Connectivity），就是使用Java语言操作关系型数据库的一套API。\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/Day06Java%e6%93%8d%e4%bd%9c%e6%95%b0%e6%8d%ae%e5%ba%93.assets/1732677291127-ec2b62db-0dd9-4bc3-975b-d5ecede913a0-20250224204828000.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/Day06Java%e6%93%8d%e4%bd%9c%e6%95%b0%e6%8d%ae%e5%ba%93.assets/1732677303807-db1a055a-36a9-4140-a5d5-fa7476415b9a-20250224204830135.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e本质：\u003c/p\u003e\n\u003cp\u003e• sun公司官方定义的一套操作所有关系型数据库的规范，即接口。\u003c/p\u003e","title":"Day06 Java操作数据库"},{"content":"MySQL的连接\n// 其中-h和-P是可选的，如果不指定，那么默认就是本机的3306端口 mysql [-h数据库服务器的IP地址 -P端口号] -u用户名 -p密码 MySQL数据模型 关系型数据库：建立在关系模型基础上，由多张相互连接的二维表组成的数据库。\n特点：\n• 使用表存储数据，格式统一，便于维护。\n• 使用SQL语言操作，标准统一，使用方便，可用于复杂查询。\nSQL语句 SQL：一门操作关系型数据库的编程语言，定义操作所有关系型数据库的统一标准。\n分类：\n分类 全称 说明 DDL Data Definition Language 数据定义语言，用来定义数据库对象(数据库，表，字段) DML Data Manipulation Language 数据操作语言，用来对数据库表中的数据进行增删改 DQL Data Query Language 数据查询语言，用来查询数据库中表的记录 DCL Data Control Language 数据控制语言，用来创建数据库用户、控制数据库的访问权限 DDL-数据库 操作语法 -- 查询所有数据库 show databases; -- 查询当前数据库 select database(); -- 使用/切换数据库 use 数据库名; -- 创建数据库 create database [if not exists] 数据库名 [default charset utf8mb4]; -- 删除数据库 drop database [if exists] 数据库名; 上述语法中的database，也可以替换成 schema。如：create schema db01；MySQL8版本中，默认字符集为utf8mb4。\n在同一个数据库服务器中，数据库的名字不可以相同\nDDL-表结构 创建表的语法 create table tablename( 字段1 字段类型 [约束] [comment 字段1注释], ...... 字段2 字段类型 [约束] [comment 字段2注释] )[comment 表注释]; 约束：约束是作用于表中字段上的规则，用于限制存储在表中的数据。\n目的：保证数据库中数据的正确性、有效性和完整性。\n常见的约束 约束 描述 关键字 非空约束 限制该字段值不能为null not null 唯一约束 保证字段的所有数据都是唯一、不重复的 unique 主键约束 主键是一行数据的唯一标识，要求非空且唯一 primary key 默认约束 保存数据时，如果未指定该字段值，则采用默认值 default 外键约束 让两张表的数据建立连接，保证数据的一致性和完整性 foreign key 一张表中最多只能有一个主键，一个字段可以有多个约束，只需要在约束中用空格分开即可\n自动增长的关键字是auto_increment\n自动增长的主键指定了值是最大的，会从最大的值之后开始自动增长，避免从小的值开始增长遇到大的值之后重复\n数据类型 数值类型：\n类型 大小(byte) 有符号(SIGNED)范围 无符号(UNSIGNED)范围 描述 备注 tinyint 1 (-128，127) (0，255) 小整数值 smallint 2 (-32768，32767) (0，65535) 大整数值 mediumint 3 (-8388608，8388607) (0，16777215) 大整数值 int 4 (-2147483648，2147483647) (0，4294967295) 大整数值 bigint 8 (-2^63，2^63-1) (0，2^64-1) 极大整数值 float 4 (-3.402823466 E+38，3.402823466351 E+38) 0 和 (1.175494351 E-38，3.402823466 E+38) 单精度浮点数值 float(5,2)：5表示整个数字长度，2 表示小数位个数 double 8 (-1.7976931348623157 E+308，1.7976931348623157 E+308) 0 和 (2.2250738585072014 E-308，1.7976931348623157 E+308) 双精度浮点数值 double(5,2)：5表示整个数字长度，2 表示小数位个数 decimal 小数值(精度更高) decimal(5,2)：5表示整个数字长度，2 表示小数位个数 数值类型的选取原则: 在满足业务需求的前提下, 尽可能选择占用磁盘空间小的数据类型\n字符串类型：\n类型 大小 描述 char 0-255 bytes 定长字符串 varchar 0-65535 bytes 变长字符串 tinyblob 0-255 bytes 不超过255个字符的二进制数据 tinytext 0-255 bytes 短文本字符串 blob 0-65 535 bytes 二进制形式的长文本数据 text 0-65 535 bytes 长文本数据 mediumblob 0-16 777 215 bytes 二进制形式的中等长度文本数据 mediumtext 0-16 777 215 bytes 中等长度文本数据 longblob 0-4 294 967 295 bytes 二进制形式的极大文本数据 longtext 0-4 294 967 295 bytes 极大文本数据 char定长字符串，char(10) 存储A，也会占用10个空间，其他地方用空来占用\nblob存放二进制文件，音频视频等内容，但是一般用的比较少，一般用专门的文件存储系统来管理\ntext存放文本字符串\n校验最少字段（最少需要多少个字段），需要在前端进行校验，数据库能校验字段是不是超了\n日期类型：\n类型 大小****(byte) 范围 格式 描述 date 3 1000-01-01 至 9999-12-31 YYYY-MM-DD 日期值 time 3 -838:59:59 至 838:59:59 HH:MM:SS 时间值或持续时间 year 1 1901 至 2155 YYYY 年份值 datetime 8 1000-01-01 00:00:00 至 9999-12-31 23:59:59 YYYY-MM-DD HH:MM:SS 混合日期和时间值 timestamp 4 1970-01-01 00:00:01 至 2038-01-19 03:14:07 YYYY-MM-DD HH:MM:SS 混合日期和时间值，时间戳 timestamp存放到2038年为止，时间快到了，所以用的比较少\n-- 案例：设计员工表 create table emp( id int unsigned primary key auto_increment comment \u0026#39;id 主键\u0026#39;, username varchar(20) not null unique comment \u0026#39;用户名\u0026#39;, password varchar(32) default \u0026#39;123456\u0026#39; comment \u0026#39;密码\u0026#39;, name varchar(10) not null comment \u0026#39;姓名\u0026#39;, gender tinyint unsigned not null comment \u0026#39;性别 男：1 女：2\u0026#39;, phone char(11) not null unique comment \u0026#39;手机号码\u0026#39;, job tinyint unsigned comment \u0026#39;职位 1 班主任 2 讲师 3 学工主管 4 教研主管 5 咨询师\u0026#39;, salary int unsigned comment \u0026#39;薪资\u0026#39;, entry_date date comment \u0026#39;入职日期\u0026#39;, image varchar(255) comment \u0026#39;头像\u0026#39;, creat_time datetime comment \u0026#39;创建日期\u0026#39;, update_time datetime comment \u0026#39;更新日期\u0026#39; ) comment \u0026#39;员工表\u0026#39;; 表中一般都要有的基础字段\n基础字段（id，creat_time，update_time）\n密码一般设置成32字节是因为进行md5加密之后固定是32字节\n查询、修改、删除 show tables; -- 查询当前数据库的所有表 desc 表名; -- 查询表结构 show create table 表名; -- 查询建表语句 alter table 表名 add 字段名 类型(长度) [comment 注释] [约束]; -- 添加字段 alter table 表名 modify 字段名 新数据类型(长度); -- 修改字段类型 alter table 表名 change 旧字段名 新字段名 类型(长度) [comment 注释] [约束]; -- 修改字段名与字段类型 alter table 表名 drop column 字段名; -- 删除字段 alter table 表名 rename to 新表名; -- 修改表名 drop table [if exists] 表名; -- 删除表 删除之后，表中的数据也都会被删除 DML-对表中的数据记录进行增删改 insert语句 -- 指定字段添加数据 insert into 表名(字段名1, 字段名2) values (值1, 值2); -- 全部字段添加数据 insert into 表名 values (值1, 值2, ...); -- 批量添加数据（指定字段） insert into 表名 (字段名1, 字段名2) values (值1, 值2), (值1, 值2); -- 批量添加数据（全部字段） insert into 表名 values (值1, 值2, ...), (值1, 值2, ...); 主键如果会自增，在插入数据的时候可以给他一个null，这样在插入之后就会自增\n当前时间可以用自带的函数now()获取\n日期和字符串推荐用单引号括起来，但是使用双引号也是可以的\n• 插入数据时，指定的字段顺序需要与值的顺序是—对应的。\n• 字符串和日期型数据应该包含在引号中（单引号、双引号都可以）。\n• 插入的数据大小/长度，应该在字段的规定范围内。\nupdate语句 如果要更改多个字段，中间需要用,隔开，不是用的and\n-- 修改数据 update 表名 set 字段名1 = 值1 , 字段名2 = 值2 , .... [ where 条件 ] ; 修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表的所有数据\ndelete语句 -- 删除数据 delete from 表名 [where 条件]; DELETE 语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数据。\nDELETE 语句不能删除某一个字段的值（如果要操作，可以使用UPDATE，将该字段的值置为NULL），一次就要删一行的数据\nDQL-查询语句 完整的DQL语法：\nDQL-基本查询 -- 查询多个字段 select 字段1,字段2,字段3 from 表名; -- 查询所有字段(通配符) select * from 表名; -- 为查询字段设置别名，as关键字可以省略 select 字段1 [as 别名1], 字段2 [as 别名2] from 表名; -- 去除重复记录 select distinct 字段列表 from 表名; 号代表查询所有字段，在实际开发中尽量少用（不直观、影响效率）。 把所有字段罗列出来的查询方法在项目中比较常用，因为效率比较高，*的话没那么常用\nas取别名的时候，有一种情况需要加引号，就是中间有空格，\u0026lsquo;姓 名\u0026rsquo;这种别名的时候需要加引号\nDQL-条件查询 -- 条件查询 select 字段列表 from 表名 where 条件列表 ; 比较运算符 功能 \u0026gt; 大于 \u0026gt;= 大于等于 \u0026laquo;/font\u0026gt; 小于 \u0026lt;= 小于等于 = 等于 \u0026lt;\u0026gt; 或 != 不等于 between \u0026hellip; and \u0026hellip; 在某个范围之内(含最小、最大值) in(\u0026hellip;) 在in之后的列表中的值，多选一 like 占位符 模糊匹配(_匹配单个字符, %匹配任意个字符0或者多个) is null 是null in(\u0026hellip;)多选一的关系，只要满足其中的一个，就是符合条件的\nbetween and 既包含最小值又包含最大值，and之前要写最小值，and之后写最大值\n%代表任意个字符，可以是0个也可以是多个\n逻辑运算符 功能 and 或 \u0026amp;\u0026amp; 并且 (多个条件同时成立) or 或 not 或 ! 非 , 不是 DQL-分组查询 聚合函数：将一列数据作为一个整体，进行纵向计算，所以里边的参数可以写的是列名\n函数 功能 count 统计数量 max 最大值 min 最小值 avg 平均值 sum 求和 所有的聚合函数**不参与null值**的统计\ncount(*)就是统计表中的总数据量\ncount(常量例如1) 表示的含义，就是说统计出来一条数据就会标识成为1，最后统计1的数量\n优先使用count(*)，底层做了优化，性能最高\n-- 分组查询 select 字段列表 from 表名 [where 条件列表] group by 分组字段名 [having 分组后过滤条件]; where与having的区别：\n1．执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤。\n2． 判断条件不同：where不能对聚合函数进行判断，而having可以。\n其他注意：\n1.分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义。\n注意：分组之后，select后的字段列表就不能随意再写了，能写的一般是分组字段+聚合函数\nwhere后不能接着聚合函数\n2.执行顺序：where \u0026gt; 聚合函数 \u0026gt;having。\nDQL-排序查询 -- 排序查询 select 字段列表 from 表名 [where 条件列表] [group by 分组字段名 having 分组后过滤条件] order by 排序字段 排序方式; 排序方式：升序（asc），降序（desc）；默认为升序asc，是可以不写的。\n如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序。\nDQL-分页查询 -- 排序查询 select 字段 from 表名 [where 条件] [group by 分组字段 having 过滤条件] [order by 排序字段] limit 起始索引,查询记录数; 说明：\n1.起始索引从0开始。\n2.分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT。\n3.如果起始索引为0，起始索引可以省略，直接简写为 limit 10。\n开发中传递进来的是页码\n起始索引 = （页码-1）*每页展示记录数\n","permalink":"https://wqnm1gb.github.io/posts/day05mysql%E6%95%B0%E6%8D%AE%E5%BA%93/","summary":"\u003cp\u003eMySQL的连接\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-plain\" data-lang=\"plain\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e// 其中-h和-P是可选的，如果不指定，那么默认就是本机的3306端口\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003emysql [-h数据库服务器的IP地址 -P端口号] -u用户名 -p密码\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"mysql数据模型\"\u003eMySQL数据模型\u003c/h1\u003e\n\u003cp\u003e关系型数据库：建立在关系模型基础上，由多张相互连接的\u003c!-- raw HTML omitted --\u003e二维表\u003c!-- raw HTML omitted --\u003e组成的数据库。\u003c/p\u003e","title":"Day05 MySQL数据库"},{"content":" SpringBoot Web入门 Spring 官网：spring.io\nSpring发展到今天已经形成了一种开发生态圈，Spring提供了若干个子项目，每个项目用于完成特定的功能，他们最底层都是基于Spring Framework\nSpring Boot简化配置，可以快速开发，对比起Spring Framework\nSpringBoot入门程序 创建一个项目：\n项目结构：\n新建的文件可以放在zzzyj里边\n入门程序：\n@RestController //标识当前类是一个请求处理类 public class HelloController { @RequestMapping (\u0026#34;/hello\u0026#34;)//标识请求路径 public String hello(String name){ System.out.println(\u0026#34;name:\u0026#34;+name); return \u0026#34;hello:\u0026#34;+name+\u0026#34;~\u0026#34;; } } “脚手架”（Scaffold）通常指的是一个自动生成的项目结构和基础代码框架。它帮助开发者快速搭建项目的初始结构，减少重复性的基础工作。\n连接不上的解决方法\n入门程序解析 为什么main方法能将程序启动起来\n运行起来tomcat\nhttp协议 概念：Hyper Text Transfer Protocol，超文本传输协议，规定了浏览器和服务器之间数据传输的规则。\n特点：\n基于TCP协议：面向连接，安全 基于请求-响应模型的：一次请求对应一次晌应 HTTP协议是无状态的协议：对于事务处理没有记忆能力。每次请求-响应都是独立的 • 缺点：多次请求间不能共享数据\n• 优点：速度快\nhttp请求协议 请求方式-GET：请求参数在请求行中，没有请求体，如：/brand/findAlL?name=OPPO\u0026amp;status=1。GET请求大小在浏览器中是有限制的。\n请求方式-POST：请求参数在请求体中，POST请求大小是没有限制的。\n请求头和请求体之间有一个空行隔开\nGET方式一般没有请求体，POST传递的数据在请求体中\nHost 请求的主机名 User-Agent 浏览器版本，例如Chrome浏览器的标识类似Mozilla/5.0 \u0026hellip; Chrome/79，IE浏览器的标识类似****Mozilla/5.0 (Windows NT \u0026hellip;) like Gecko Accept 表示浏览器能接收的资源类型，如****text/***，****image/或者/***表示所有； Accept-Language 表示浏览器偏好的语言，服务器可以据此返回不同语言的网页； Accept-Encoding 表示浏览器可以支持的压缩类型，例如gzip, deflate****等。 Content-Type 请求主体的数据类型。 Content-Length 请求主体的大小（单位：字节）。 请求数据的获取 Web服务器（Tomcat）对HTTP协议的请求数据进行解析，并进行了封装（HttpServletRequest），在调用Controller方法的时候传递给了该方法。这样，就使得程序员不必直接对协议进行操作，让web开发更加便捷。\n@RestController public class RequestController { @RequestMapping(\u0026#34;/request\u0026#34;) public String reques(HttpServletRequest request){ // 获取请求方法 String method = request.getMethod(); System.out.println(\u0026#34;method:\u0026#34;+method); // 获取请求参数 String name1 = request.getParameter(\u0026#34;name\u0026#34;); String name2 = request.getParameter(\u0026#34;age\u0026#34;); System.out.println(\u0026#34;name:\u0026#34;+name1); System.out.println(\u0026#34;age:\u0026#34;+name2); // 获取请求路径url和uri String url = request.getRequestURL().toString(); // 这是一个完整的路径 String uri = request.getRequestURI(); // 这是后边的相对路径 System.out.println(\u0026#34;url:\u0026#34;+url); System.out.println(\u0026#34;uri:\u0026#34;+uri); // 获取请求体 String header = request.getHeader(\u0026#34;User-Agent\u0026#34;); System.out.println(\u0026#34;header = \u0026#34; + header); return \u0026#34;ok\u0026#34;; } } http响应数据 响应码：\n1xx 响应中-临时状态码，表示请求已经接收，告诉客户端应该继续请求或者如果它已经完成则忽略它。 2xx 成功-表示请求已经被成功接收，处理已完成。 3xx 重定向-重定向到其他地方；让客户端再发起一次请求以完成整个处理。 4xx 客户端错误-处理发生错误，责任在客户端。如: 请求了不存在的资源、客户端未被授权、禁止访问等。 5xx 服务器错误-处理发生错误，责任在服务端。如：程序抛出异常等。 响应头：\nContent-Type 表示该响应内容的类型，例如text/html，application/json。 Content-Length 表示该响应内容的长度（字节数）。 Content-Encoding 表示该响应压缩算法，例如gzip。 Cache-Control 指示客户端应如何缓存，例如max-age=300表示可以最多缓存300秒。 Set-Cookie 告诉浏览器为当前页面所在的域设置cookie。 响应数据的设置 @RestController public class ResponseController { @RequestMapping(\u0026#34;/response\u0026#34;) public void response(HttpServletResponse response) throws IOException { // 设置响应状态码 response.setStatus(401); // 设置响应头 response.setHeader(\u0026#34;zzzzyj\u0026#34;,\u0026#34;哈哈哈\u0026#34;); // 设置响应体 response.getWriter().write(\u0026#34;\u0026lt;h1\u0026gt;hello,response\u0026lt;/h1\u0026gt;\u0026#34;); } @RequestMapping(\u0026#34;/response2\u0026#34;) public ResponseEntity\u0026lt;String\u0026gt; response2(){ // spring提供的 return ResponseEntity.status(401) .header(\u0026#34;zzzzyj\u0026#34;,\u0026#34;xixixi\u0026#34;) .body(\u0026#34;\u0026lt;h1\u0026gt;hello,response\u0026lt;/h1\u0026gt;\u0026#34;); } } 响应状态码 和 响应头如果没有特殊要求的话，通常不手动设定。服务器会根据请求处理的逻辑，自动设置响应状态码和响应头。\nSpringBoot案例 构建项目的时候，需要勾选上lombok依赖，这个就是之前在javase中学习的@Data注解，可以直接有getset和构造器方法\n返回的数据之所以可以是json格式，是因为加了注解@RestController，他的底层还有一个注解@ResponseBody 作用：将controller返回值直接作为响应体的数据直接响应；返回值是对象/集合-\u0026gt;json-\u0026gt;再响应\n@RestController public class UserController { // 当访问list的时候，就会读取txt文件返回数据，加载到html页面中 @RequestMapping(\u0026#34;/list\u0026#34;) public List\u0026lt;User\u0026gt; list(){ // 1、加载并读取文件 InputStream in = this.getClass().getClassLoader().getResourceAsStream(\u0026#34;user.txt\u0026#34;); ArrayList\u0026lt;String\u0026gt; lines = IoUtil.readLines(in, StandardCharsets.UTF_8, new ArrayList\u0026lt;\u0026gt;()); // 2、解析数据，封装成对象 --\u0026gt;集合 List\u0026lt;User\u0026gt; userList = lines.stream().map(line -\u0026gt; { String[] parts = line.split(\u0026#34;,\u0026#34;); Integer id = Integer.parseInt(parts[0]); String username = parts[1]; String password = parts[2]; String name = parts[3]; Integer age = Integer.parseInt(parts[4]); LocalDateTime updateTime = LocalDateTime.parse(parts[5], DateTimeFormatter.ofPattern(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;)); return new User(id, username, password, name, age, updateTime); // 流的终结方法，打回集合 }).collect(Collectors.toList()); // 3、响应数据 return userList; } } 分层解耦 三层架构 单一职责原则\ncontroller：控制层，接收前端发送的请求，对请求进行处理，并响应数据。\nservice：业务逻辑层，处理具体的业务逻辑。\ndao：数据访问层（Data Access Object）（持久层），负责数据访问操作，包括数据的增、删、改、查。\n转换后的代码\n分层解耦 耦合：衡量软件中各个层/各个模块的依赖关联程度。\n内聚：软件中各个功能模块内部的功能联系。\n软件设计原则：高内聚低耦合。\n因为用new创建了对象，所以是高耦合\n控制反转： Inversion Of Control，简称IOC。对象的创建控制权由程序自身转移到外部（容器），这种思想称为控制反转。\n依赖注入：Dependency Injection，简称DI。容器为应用程序提供运行时，所依赖的资源，称之为依赖注入。\nBean对象：IOC容器中创建、管理的对象，称之为Bean。\nIOC\u0026amp;DI入门 1、将Dao 及 Service层的实现类，交给IOC容器管理。\n2、为Controller 及 Service注入运行时所依赖的对象。\nIOC详解 要把某个对象交给IOC容器管理，需要在对应类中加上下列注解之一：\n注解 说明 位置 @Component 声明bean的基础注解 不属于以下三类时，用此注解 @Controller @Component的衍生注解 标注在控制层类上(@RestController中包含了@Controller) @Service @Component的衍生注解 标注在业务层类上 @Repository @Component的衍生注解 标注在数据访问层类上（由于与mybatis整合，用的少） 不指定Bean的名字默认是类名首字母小写\n使用以上四个注解都可以声明bean，但是在springboot集成web开发中，声明控制器bean只能用@Controller。\n前面声明bean的四大注解，要想生效，还需要被组件扫描注解@ComponentScan扫描。\n该注解虽然没有显式配置，但是实际上已经包含在了启动类声明注解@SpringBootAppljcatjon 中，默认扫描的范围是启动类所在包及其子包。\nDI详解 \u0026lt;font style=\u0026quot;color:rgb(222,120,2);\u0026quot;\u0026gt;@Autowired\u0026lt;/font\u0026gt;注解，默认是按照类型进行自动装配的（去IOC容器中找某个类型的对象，然后完成注入操作）\n入门程序举例：在EmpController运行的时候，就要到IOC容器当中去查找EmpService这个类型的对象，而我们的IOC容器中刚好有一个EmpService这个类型的对象，所以就找到了这个类型的对象完成注入操作。\n三种注解形式\n方式1：属性注入\n@RestController public class UserController { @Autowired private UserService userService; //...... } 优点：代码简洁、方便快速开发。\n缺点：隐藏了类之间的依赖关系、可能会破坏类的封装性。\n方式一破坏了类的封装性，因为封装性要求私有成员变量却没有提供get和set方法\n方式2：构造器注入\n@RestController public class UserController { //方式二: 构造器注入 private final UserService userService; @Autowired //如果当前类中只存在一个构造函数, @Autowired可以省略 public UserController(UserService userService) { this.userService = userService; } } 优点：能清晰地看到类的依赖关系、提高了代码的安全性。\n缺点：代码繁琐、如果构造参数过多，可能会导致构造函数臃肿。\n注意：如果只有一个构造函数，@Autowired注解可以省略。\n方式3：setter注入\n/** * 用户信息Controller */ @RestController public class UserController { //方式三: setter注入 private UserService userService; @Autowired public void setUserService(UserService userService) { this.userService = userService; } } 优点：保持了类的封装性，依赖关系更清晰。\n缺点：需要额外编写setter方法，增加了代码量。\n一般使用的比较多的是方式1和方式2\n@Autowired注解，默认是按照类型进行注入的。\n如果存在多个相同类型的bean，将会报出如下错误：\n解决方式1：使用@Primary注解\n注意注释的地方是在类的上边\n@Primary @Service public class UserServiceImpl implements UserService { } 解决方式2：使用@Qualifier注解\n指定当前要注入的bean对象。 在@Qualifier的value属性中，指定注入的bean的名称。 @Qualifier注解不能单独使用，必须配合@Autowired使用。\n@RestController public class UserController { @Qualifier(\u0026#34;userServiceImpl\u0026#34;) @Autowired private UserService userService; 解决方式3：使用@Resource注解\n是按照bean的名称进行注入。通过name属性指定要注入的bean的名称。\n@RestController public class UserController { @Resource(name = \u0026#34;userServiceImpl\u0026#34;) private UserService userService; @Resource 与 @Autowired区别？ • @Autowired是Spring框架提供的注解，而@Resource是JavaEE规范提供的\n• @Autowired默认是按照类型注入，而@Resource默认是按照名称注入\n","permalink":"https://wqnm1gb.github.io/posts/day04web%E5%9F%BA%E7%A1%80/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/Day04Web%e5%9f%ba%e7%a1%80.assets/1731977559201-73e5a329-2595-4cae-bff1-05bfe1edee42-20250224204642352.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003ch1 id=\"springboot-web入门\"\u003eSpringBoot Web入门\u003c/h1\u003e\n\u003ch2 id=\"spring\"\u003eSpring\u003c/h2\u003e\n\u003cp\u003e\u003c!-- raw HTML omitted --\u003e官网：\u003c!-- raw HTML omitted --\u003e\u003ca href=\"https://spring.io/\"\u003e\u003c!-- raw HTML omitted --\u003espring.io\u003c!-- raw HTML omitted --\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003c!-- raw HTML omitted --\u003eSpring发展到今天已经形成了一种开发生态圈，Spring提供了若干个子项目，每个项目用于完成特定的功能，他们最底层都是基于Spring Framework\u003c!-- raw HTML omitted --\u003e\u003c/p\u003e","title":"Day04 Web基础"},{"content":"Maven Maven是一款用于管理和构建Java项目的工具，是apache旗下的一个开源项目。\nMaven的作用 方便的依赖管理 方便快捷的管理项目依赖的资源（jar包）\n标准的项目构建流程 标准化的跨平台（Linux、Windows、MacOs）的自动化项目构建方式\n统一结构的项目 提供标准、统一的项目结构\n仓库：用于存储资源，管理各种jar包。\n• 本地仓库：自己计算机上的一个目录。\n• 中央仓库：由Maven团队维护的全球唯一的。仓库地址：https://repo1.maven.org/maven2/\n• 远程仓库（私服）：一般由公司团队搭建的私有仓库。\n查找的顺序是\n1、本地仓库\n2、远程仓库（私服）\n3、中央仓库\nMaven坐标 什么是坐标？ Maven 中的坐标是资源（jar）的唯一标识，通过该坐标可以唯一定位资源位置\n使用坐标来定义项目或引入项目中需要的依赖\nMaven 坐标主要组成 groupId：定义当前Maven项目隶属组织名称（通常是域名反写，例如：com.itheima）\nartifactId：定义当前Maven项目名称（通常是模块名称，例如：order-service、goods-service）\nversion：定义当前项目版本号\nSNAPSHOT：功能不稳定、尚处于开发中的版本，即快照版本 RELEASE：功能趋于稳定、当前更新停止，可以用于发行的版本 导入Maven项目 方式1：\n方式2：\n建议将要导入的maven项目复制到你的项目目录下\n建议选择maven项目的pom.xml文件进行导入\n选择pom.xml文件导入，为了更方便的聚合（Maven高级）\nMaven依赖管理 依赖配置 依赖：指当前项目运行所需要的jar包，一个项目中可以引入多个依赖。\n配置：\n在 pom.xmL 中编写 标签\n在 标签中 使用 引入坐标\n3．定义坐标的 groupId,artifactId,version\n4．点击刷新按钮，引入最新加入的坐标\n如果不知道依赖的坐标信息，可以到 https://mvnrepository.com/中搜索。\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;6.1.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 排除依赖 排除依赖：指主动断开依赖的资源，被排除的资源无需指定版本。\n这个exclusions需要在dependecy里边\n想要有提示词，都需要先打一个\u0026laquo;/font\u0026gt;\n注意事项\n• 一旦依赖配置变更了，记得重新加载\n• 引入的依赖本地仓库不存在，记得联网\nMaven的生命周期 每套生命周期包含一些阶段（phase），阶段是有顺序的，后面的阶段依赖于前面的阶段。\n重点关注的几个阶段：\nclean：移除上一次构建生成的文件\ncompile：编译项目源代码\ntest：使用合适的单元测试框架运行测试（junit）\npackage：将编译后的文件打包，如：jar、war等\ninstall：安装项目到本地仓库\n在同一套生命周期中，当运行后面的阶段时，前面的阶段都会运行。（注意同一套）\n执行生命周期的两种方式：\n1、在idea中，右侧的maven工具栏，选中对应的生命周期，双击执行。\n2、在命令行中，通过命令执行\n只有点击install后，项目才会安装到Maven的本地仓库中，其他的文件都是生成在项目路径中\n测试 测试：是一种用来促进鉴定软件的正确性、完整性、安全性和质量的过程。\n阶段划分：单元测试、集成测试、系统测试、验收测试。\n测试方法：白盒测试，黑盒测试，灰盒测试\n单元测试 单元测试：就是针对最小的功能单元（方法），编写测试代码对其正确性进行测试。\nJUnit：最流行的Java测试框架之一，提供了一些功能，方便程序进行单元测试（第三方公司提供）。\nmain方法测试 1、测试代码与源代码未分开，难维护\n2、一个方法测试失败，影响后面方法\n3、无法自动化测试，得到测试报告\nJUnit单元测试 1、测试代码与源代码分开，便于维护\n2、可根据需要进行自动化测试\n3、可自动分析测试结果，产出测试报告\n测试方法：\n在pom.xml中，引入JUnit的依赖。 在test/java目录下，创建测试类，并编写对应的测试方法，并在方法上声明@Test注解。 运行单元测试（测试通过：绿色；测试失败：红色）。 JUnit单元测试类名命名规范：XxxxxTest【规范】。JUnit单元测试的方法，必须声明为 public void【规定】，可以有形参吗，可以的，@ParameterizedTest + @ValueSource\n断言 JUnit提供了一些辅助方法，用来帮我们确定被测试的方法是否按照预期的效果正常工作，这种方式称为断言。\n断言方法 描述 Assertions.assertEquals(Object exp, Object act, String msg) 检查两个值是否相等，不相等就报错。 Assertions.assertNotEquals(Object unexp, Object act, String msg) 检查两个值是否不相等，相等就报错。 Assertions.assertNull(Object act, String msg) 检查对象是否为null，不为null，就报错。 Assertions.assertNotNull(Object act, String msg) 检查对象是否不为null，为null，就报错。 Assertions.assertTrue(boolean condition, String msg) 检查条件是否为true，不为true，就报错。 Assertions.assertFalse(boolean condition, String msg) 检查条件是否为false，不为false，就报错。 Assertions. assertThrows(Class expType, Executable exec, String msg) 检查程序运行抛出的异常，是否符合预期。 上述方法形参中的最后一个参数 msg，表示错误提示信息，可以不指定（有对应的重载方法）。\nJUnit的常见注解 @ValueSource这个注解里边可以指定参数，传递到测试函数里边\n@DisplayName可以为测试命名解释\n@BeforAll只会运行一次\n注解 说明 备注 @Test 测试类中的方法用它修饰才能成为测试方法，才能启动执行 单元测试 @ParameterizedTest 参数化测试的注解 (可以让单个测试运行多次，每次运行时仅参数不同) 用了该注解，就不需要@Test注解了 @ValueSource 参数化测试的参数来源，赋予测试方法参数 与参数化测试注解配合使用 @DisplayName 指定测试类、测试方法显示的名称 （默认为类名、方法名） @BeforeEach 用来修饰一个实例方法，该方法会在每一个测试方法执行之前执行一次。 初始化资源(准备工作) @AfterEach 用来修饰一个实例方法，该方法会在每一个测试方法执行之后执行一次。 释放资源(清理工作) @BeforeAll 用来修饰一个静态方法，该方法会在所有测试方法之前只执行一次。 初始化资源(准备工作) @AfterAll 用来修饰一个静态方法，该方法会在所有测试方法之后只执行一次。 释放资源(清理工作) @DisplayName(\u0026#34;用户性别测试\u0026#34;) @ParameterizedTest @ValueSource(strings = {\u0026#34;110101200011011234\u0026#34;,\u0026#34;110101200011011214\u0026#34;,\u0026#34;110101200011011254\u0026#34;}) public void testGetGender2(String idCard){ UserService userService = new UserService(); String gender = userService.getGender(idCard); Assertions.assertEquals(\u0026#34;男\u0026#34;, gender); } 测试覆盖率\nClass 类覆盖率、Method 方法覆盖率、Line 代码覆盖率\n可以选定想要生成测试的函数，用AI一键生成\n依赖范围 依赖的jar包，默认情况下，可以在任何地方使用。可以通过 ..设置其作用范围。\n作用范围：\n＞ 主程序范围有效。（main文件夹范围内）\n＞ 测试程序范围有效。（test文件夹范围内）\n＞ 是否参与打包运行。（package指令范围内）\nscope****值 主程序 测试程序 打包（运行） 范例 compile（默认） Y Y Y log4j test - Y - junit provided Y Y - servlet-api runtime - Y Y jdbc驱动 常见问题的解决方案 ","permalink":"https://wqnm1gb.github.io/posts/day03web%E5%90%8E%E7%AB%AF%E5%9F%BA%E7%A1%80/","summary":"\u003ch1 id=\"maven\"\u003eMaven\u003c/h1\u003e\n\u003cp\u003eMaven是一款用于\u003c!-- raw HTML omitted --\u003e管理和构建Java项目\u003c!-- raw HTML omitted --\u003e的工具，是apache旗下的一个开源项目。\u003c/p\u003e\n\u003ch2 id=\"maven的作用\"\u003eMaven的作用\u003c/h2\u003e\n\u003ch3 id=\"方便的依赖管理\"\u003e方便的依赖管理\u003c/h3\u003e\n\u003cp\u003e方便快捷的管理项目依赖的资源（jar包）\u003c/p\u003e","title":"Day03 Web后端基础"},{"content":"JavaScript Javascript（简称：Js）是一门跨平台、面向对象的脚本语言，是用来控制网页行为，实现页面的交互效果。\nJavascript 和 Java 是完全不同的语言，不论是概念还是设计。但是基础语法类似。\n组成：\n• ECMAScript： 规定了JS基础语法核心知识，包括变量、数据类型、流程控制、函数、对象等。\n• BOM：浏览器对象模型，用于操作浏览器本身，如：页面弹窗、地址栏操作、关闭窗口等。\n• DOM：文档对象模型，用于操作HTML文档，如：改变标签内的内容、改变标签内字体样式等。\nJS的引入方式 内部脚本：将JS代码定义在HTML页面中 JavaScript代码必须位于 标签之间 在HTML文档中，可以在任意地方，放置任意数量的 一般会把脚本置于 元素的底部，可改善显示速度，原因如下： 一般会把script标签放在body的底部，因为html标签是从上到下渲染的，放在底部可以先渲染html语句，改善显示速度，同时如果js中有对html里的标签进行操作，标签还没加载出来的话，就会报错\n外部脚本：将 JS代码定义在外部 JS文件中，然后引入到HTML页面中 变量和常量 **JS中用 let 关键字来声明变量（****弱类型语言，变量可以存放不同类型**的值）\n变量名需要遵循如下规则：\n• 只能用 字母、数字、下划线（_）、美元符号（$）组成，且数字不能开头\n• 变量名严格区分大小写，如 name 和 Name 是不同的变量\n• 不能使用关键字，如：let、var、if、for等\nJS中用 const 关键字来声明常量。\n一旦声明，常量的值就不能改变（不可以重新赋值）\n在早期的js中，声明变量还可以使用var，但是并不严谨（不推荐）\n输出语句：\nwindow.alert（） ：弹出警告框（使用频次较高） console.log（）：写入浏览器控制台（使用频次较高） document.write（）：向HTML的body内输出内容 数据类型 JavaScript的数据类型分为：基本数据类型和引用数据类型（对象）。\n基本数据类型：\nnumber：数字（整数、小数、NaN（Not a Number）） boolean：布尔，true,false null：对象为空，Javascript是大小写敏感的，因此null、NuLL、NULL是完全不同的 undefined：当声明的变量未初始化时，该变量的默认值是 undefined string：字符串，单引号、双引号、反引号皆可，推荐使用单引号 使用 typeof 运算符可以获取数据类型\n模板字符串语法：\n•``（反引号，英文输入模式下按键盘的tab键上方波浪线~那个键）\n• 内容拼接变量时，使用$｛｝包住变量\n\u0026lt;script\u0026gt; let name = \u0026#39;Tom\u0026#39;; let age = 18; console.log(\u0026#39;大家好, 我是新入职的\u0026#39; + name + \u0026#39;, 今年\u0026#39; + age + \u0026#39;岁了, 请多多关照\u0026#39;); console.log(`大家好, 我是新入职的${name}, 今年${age}岁了, 请多多关照`); \u0026lt;/script\u0026gt; 函数 介绍：函数（ function ）是被设计用来执行特定任务的代码块，方便程序的封装复用。\n定义：JavaScript中的函数通过function关键字进行定义，语法为：\nfunction functionName(参数1, 参数2 ...){ //要执行的代码 } 由于JS是弱类型语言，形参、返回值都不需要指定类型。在调用函数时，实参个数与形参个数可以不一致，但是建议一致。\n匿名函数 函数表达式：\nlet add = function(a, b){ return a + b; } 箭头函数：\nlet add = (a, b) =\u0026gt; { return a + b; } 匿名函数定义后，可以通过变量名直接调用\nlet result = add(10,20); alert(result); 自定义对象 定义格式\nlet 对象名 = { 属性名1: 属性值1, 属性名2: 属性值2, 属性名3: 属性值3, 方法名: function (形参列表) {} } 例子：\nlet user = { name: \u0026#39;Tom\u0026#39;, age: 20, gender: \u0026#39;男\u0026#39;, sing: function () { alert(this.name+\u0026#39;唱着最炫的民族风\u0026#39;) } } 里边的方法可以简化成：\nlet user = { name: \u0026#39;Tom\u0026#39;, age: 20, gender: \u0026#39;男\u0026#39;, sing() { alert(this.name+\u0026#39;唱着最炫的民族风\u0026#39;) } } 调用格式\n对象名.属性名; 对象名.方法名(); console.log(user.name); user.sing(); 注意：在定义对象中的方法时，尽量不要使用箭头函数（this），因为在箭头函数里边，this会指向当前对象的父级对象 JSON 概念：Javascript Object Notation,Javascript对象标记法（JS对象标记法书写的文本）。\n由于其语法简单，层次结构鲜明，现多用于作为数据载体，在网络中进行数据传输。\nJSON.parse ：将json字符串转为js对象\nJSON.stringify：将js对象转为json字符串\nDOM 概念：Document Object Model，文档对象模型。\n将标记语言的各个组成部分封装对应的对象：\n• Document ： 整个文档对象\n• Element：元素对象\n• Attribute：属性对象\n• Text：文本对象\n• Comment： 注释对象\nJavaScript通过DOM，就能够对HTML进行操作：\n• 改变 HTML 元素的内容\n• 改变 HTML 元素的样式（CSS）\n• 对 HTML DOM 事件作出反应\n• 添加和删除 HTML 元素\nDOM操作 DOM操作核心思根：将网页中所有的元素当做对象来处理。（标签的所有属性在该对象上都可以找到）\nDOM是：文档对象模型，JS提供的专门用来操作网页内容的\n操作步骤\n• 获取要操作的DOM元素对象\n• 操作DOM对象的属性或方法（查文档或AI）\n获取DOM对象\n• 根据CSS选择器来获取DOM元素，获取匹配到的第一个元素：document.querySelector(\u0026lsquo;选择器\u0026rsquo;)\n#sid（id选择器） .txt（类选择器） span（标签选择器）\n• 根据CSS选择器来获取DOM元素，获取匹配到的所有元素：document.querySelectorALL（\u0026lsquo;选择器\u0026rsquo;）\n注意：得到的是一个NodeList节点集合，是一个伪数组（有长度、有索引的数组）\n事件监听 事件：HTML事件是发生在HTML元素上的“事情”。比如：\n• 按钮被点击\n• 鼠标移动到元素上\n• 按下键盘按键\n事件监听：JavaScript可以在事件触发时，就立即调用一个函数做出响应，也称为事件绑定或注册事件。\n语法：事件源.addEventListener（\u0026lsquo;事件类型\u0026rsquo;，事件触发执行的函数）；\n事件监听三要素\n事件源：哪个dom元素触发了事件，要获取dom元素 事件类型：用什么方式触发，比如：鼠标单击 click 事件触发执行的函数：要做什么事 \u0026lt;input id=\u0026#34;btn\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;点我一下试试2\u0026#34;\u0026gt; \u0026lt;script\u0026gt; document.querySelector(\u0026#39;#btn\u0026#39;).addEventListener(\u0026#39;click\u0026#39;,()=\u0026gt;{ alert(\u0026#39;试试就试试\u0026#39;); }) \u0026lt;/script\u0026gt; 早期版本写法（了解）：事件源.on事件= function（）｛\u0026hellip;｝\n\u0026lt;input id=\u0026#34;btn\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;点我一下试试2\u0026#34;\u0026gt; \u0026lt;script\u0026gt; document.querySelector(\u0026#39;#btn\u0026#39;).onclick = function () { alert(\u0026#39;试试就试试\u0026#39;); } \u0026lt;/script\u0026gt; 区别：on方式会被覆盖，addEventListener方式可以绑定多次，拥有更多特性，推荐使用\n事件源.addEventListener（\u0026lsquo;事件类型\u0026rsquo;，要执行的函数）\n常见事件 鼠标事件\nclick：鼠标点击\nmouseenter： 鼠标移入\nmouseleave：鼠标移出\n键盘事件\nkeydown：键盘按下触发\nkeyup：键盘抬起触发\n焦点事件\nfocus：获得焦点触发\nblur：失去焦点触发\n表达事件\ninput： 用户输入时触发\nsubmit： 表单提交时触发\nJS优化-模块化设计 \u0026lt;script src=\u0026#34;./js/eventDemo.js\u0026#34; type=\u0026#34;module\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; import { printLog } from \u0026#34;./utls.js\u0026#34;; //click: 鼠标点击事件 document.querySelector(\u0026#39;#b2\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { printLog(\u0026#34;我被点击了...\u0026#34;); }) //mouseenter: 鼠标移入 document.querySelector(\u0026#39;#last\u0026#39;).addEventListener(\u0026#39;mouseenter\u0026#39;, () =\u0026gt; { printLog(\u0026#34;鼠标移入了...\u0026#34;); }) export function printLog(msg){ console.log(msg); } Vue基础入门 Vue是一款用于构建用户界面的渐进式的JavaScript框架。\n构建用户界面：把数据变成用户能看得懂的形式进行展示\n渐进式：指的是我们使用Vue框架呢，我们不需要把所有的组件、语法全部学习完毕才可以使用Vue。 而是，我们学习一点就可以使用一点了\n框架：就是一套完整的项目解决方案，用于快速构建项目。\n优点：大大提升前端项目的开发效率。\n缺点：需要理解记忆框架的使用规则。（参照官网）\n准备\n• 引入Vue模块（官方提供）\n• 创建Vue程序的应用实例，控制视图的元素\n• 准备元素（div），被Vue控制\n数据驱动视图\n• 准备数据\n• 通过插值表达式渲染页面\n\u0026lt;body\u0026gt; \u0026lt;div id = \u0026#34;app\u0026#34;\u0026gt; 用插值表达式来渲染页面 \u0026lt;h1\u0026gt;{{message}}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; // 相当于引用了一个createApp这个函数，mount指定接管的区域 // data方法的返回值就是在vue中定义的数据 import { createApp, ref } from \u0026#39;https://unpkg.com/vue@3/dist/vue.esm-browser.js\u0026#39;; createApp({ data() { return { message: \u0026#39;Hello Vue!\u0026#39; } } }).mount(\u0026#39;#app\u0026#39;) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 在vs中 []括起来的是数组，{}括起来的是对象\n差值表达式不能写在标签的内部\nv-for 作用：列表渲染，遍历容器的元素或者对象的属性\n语法：\n\u0026lt;tr v-for=\u0026#34;(item,index) in items\u0026#34; :key=\u0026#34;item.id\u0026#34;\u0026gt; {{item}}\u0026lt;/tr\u0026gt; 参数说明：\n• items 为遍历的数组\n• item 为遍历出来的元素\n• index 为索引/下标，从0开始；可以省略，省略index语法：v-for=\u0026ldquo;item in items\nkey：\n作用：给元素添加的唯一标识，便于vue进行列表项的正确排序复用，提升渲染性能\n• 推荐使用id作为key（唯一），不推荐使用index作为key（会变化，不对应）\n遍历的数组，必须在data中定义；要想让哪个标签循环展示多次，就在哪个标签上使用 v-for 指令\nv-bind 作用：动态为HTML标签绑定属性值，如设置href，src，style样式等\n语法：v-bind：属性名=\u0026ldquo;属性值\u0026rdquo;\n\u0026lt;img v-bind:src=\u0026#34;item.image\u0026#34; width=\u0026#34;30px\u0026#34;\u0026gt; 简化：:属性名=\u0026ldquo;属性值\u0026rdquo;\n\u0026lt;img :src=\u0026#34;item.image\u0026#34; width=\u0026#34;30px\u0026#34;\u0026gt; 动态的为标签的属性绑定值，不能使用插值表达式，得使用 v-bind 指令。且绑定的数据，必须在data中定义。\nv-if \u0026amp; v-show 作用：这两个指令都是用来控制元素的显示与隐藏\nv-if • 语法：v-if=\u0026ldquo;表达式\u0026rdquo;，表达式值为 true，显示；false，隐藏 作用在标签上\n• 原理：基于条件判断，来控制创建或移除元素节点（条件渲染）\n• 场景：要么显示，要么不显示，不频繁切换的场景\n• 其它：可以配合 v-else-if / v-else 进行链式调用条件判断\nv-else-if必须出现在v-if之后，可以出现多个；v-else 必须出现在v-if/v-else-if之后。\nv-show • 语法：v-show=\u0026ldquo;表达式\u0026rdquo;，表达式值为 true，显示；false，隐藏\n• 原理：基于CSS样式display来控制显示与隐藏\n• 场景：频繁切换显示隐藏的场景\nv-show的表达式不论是真是假，都会渲染出来，但是底层是通过css的样式来控制显示还是隐藏\nvue的指令需要作用在标签中，类似于标签中的属性\nv-model 作用：在表单元素上使用，双向数据绑定。可以方便的 获取 或 设置 表单项数据\n语法：v-model=\u0026ldquo;变量名\u0026rdquo;\nv-model 中绑定的变量，必须在data中定义。\n双向数据绑定，就是页面和数据模型之间的绑定，数据和页面的展示都会改变\nv-on 作用：为html标签绑定事件（添加事件监听）\n语法：\n• v-on：事件名=\u0026ldquo;方法名\u0026rdquo;\n• 简写为@事件名=\u0026rdquo;..\u0026quot;\nmethod是与data平级的关系\nmethods函数中的this指向Vue实例，可以通过this获取到data中定义的数据。\nAjax 介绍：Asynchronous Javascript And XML，异步的javascript和XML。\n作用：\n•数据交换：通过Ajax可以给服务器发送请求，并获取服务器响应的数据。\n•异步交互：可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术，如：搜索联想、用户名是否可用的校验等等。\nXML：（英语：Extensible Markup Language） 可扩展标记语言，本质是一种数据格式，可以用来存储复杂的数据结构。\nAxios 介绍：Axios 对原生的Ajax进行了封装，简化书写，快速开发。\n官网：https://www.axios-http.cn\n步骤：\n• 引入Axios的js文件（参照官网）\n• 使用Axios发送请求，并获取响应结果\n为了方便起见，Axios已经为所有支持的请求方法提供了别名\n格式：axios.请求方式（url ［，data ［， config］］）\nasync \u0026amp; await 可以通过async、await可以让异步变为同步操作。async就是来声明一个异步方法，await是用来等待异步任务执行。\nawait关键字只在async函数内有效，await关键字取代then函数，等待获取到请求成功的结果值。\nVue的生命周期 生命周期：指一个对象从创建到销毁的整个过程。\n生命周期的八个阶段：每触发一个生命周期事件，会自动执行一个生命周期方法（钩子）。\n状态 阶段周期 beforeCreate 创建前 created 创建后 beforeMount 载入前 mounted 挂载完成 beforeUpdate 数据更新前 updated 数据更新后 beforeUnmount 组件销毁前 unmounted 组件销毁后 \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import { createApp } from \u0026#39;https://.../vue.esm-browser.js\u0026#39; const app = createApp({ data() { return { message: \u0026#34;Hello Vue\u0026#34; } },\u000b//生命周期-钩子函数 mounted mounted() { console.log(\u0026#39;Vue挂载完毕, 发送请求获取数据 ...\u0026#39;); } }).mount(\u0026#34;#app\u0026#34;); \u0026lt;/script\u0026gt; ","permalink":"https://wqnm1gb.github.io/posts/day02jsvueajax/","summary":"\u003ch1 id=\"javascript\"\u003eJavaScript\u003c/h1\u003e\n\u003cp\u003eJavascript（简称：Js）是一门跨平台、\u003c!-- raw HTML omitted --\u003e面向对象\u003c!-- raw HTML omitted --\u003e的脚本语言，是用来控制网页行为，实现页面的交互效果。\u003c/p\u003e","title":"Day02 JS\u0026Vue\u0026Ajax"},{"content":"Web的三个组成部分：\n• HTML：负责网页的结构（页面元素和内容）。\n• CSS：负责网页的表现（页面元素的外观、位置等页面样式，如：颜色、大小等）。\n• Javascript：负责网页的行为（交互效果）。\nhtml HTML（HyperText Markup Language）：超文本标记语言\n超文本：超越了文本的限制，比普通文本更强大。除了文字信息，还可以定义图片、音频、视频等内容\n标记语言：由标签“\u0026lt;标签名\u0026gt;\u0026ldquo;构成的语言\nHTML标签都是预定义好的。例如：使用展示标题，使用展示图片，使用展示视频。HTML代码直接在浏览器中运行，HTML标签由浏览器解析。\nhtml语言的特点 html标签是不区分大小写的，但是通常是使用小写 属性值可以用双引号括起来也可以用单引号括起来，但是通常使用双引号 html语法没那么严谨，可以不写结束标签也可以用 超链接 a 标签 标签：央视网\n属性：\nhref: 指定资源访问的url target: 指定在何处打开资源链接 _self: 默认值，在当前页面打开 _blank: 在空白页面打开 常见标签 标签 作用 属性说明 视频标签 src：指定视频的url（绝对路径/相对路径） controls：是否显示播放控件 width：宽度（像素/相对于父元素百分比） height：高度（像素/相对于父元素百分比） 图片标签 src, width，height 段落标签 标签 作用 属性说明 / 加粗 具有强调语义 / 下划线 具有强调语义 / 倾斜 \u0026laquo;/font\u0026gt;em\u0026gt; 具有强调语义 / 删除线 具有强调语义 字符实体 属性说明 \u0026amp;nbsp; 空格 \u0026amp;lt; \u0026laquo;/font\u0026gt; \u0026amp;gt; \u0026gt; 资源路径写法\n绝对路径 绝对磁盘路径（D:/xxX.ipg） 绝对网络路径（https://xxx.jpg） 相对路径 当前目录：./（可以省略） 上一级目录：../ 页面原型 指在应用程序开发初期，由产品经理制作的一个早期项目模型，它用于展示页面的基本布局、功能和交互设计。通常用来帮助设计师、开发者等更好地理解和讨论最终产品的外观和行为。\n表单标签 表单：在网页中主要负责数据采集功能，如注册、登录等数据采集。\n标签：\n表单项：不同类型的 input 元素、下拉列表、文本域等。\n• ：定义表单项，通过type属性控制输入形式（text/password/\u0026hellip;）\n• ：定义下拉列表，定义列表项\n• ：定义文本域\n属性：\n• action：规定当提交表单时向何处发送表单数据，URL\n• method： 规定用于发送表单数据的方式。GET、POST\nget: 在url后面拼接表单数据, 比如: ?username=Tom\u0026amp;age=12 , url长度有限制（默认值）\npost: 在消息体(请求体)中传递的, 参数大小无限制的\n注意：表单项必须有name属性才可以提交。\n// 如果想要只能选择一个，必须保证name是一样的，value的意思是会提交给服务器什么数据 // label标签是为了提升用户体验的，如果没有的话就需要精准的点击选择框，如果有的话 // 点击女字也可以选中 性别: \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; value=\u0026#34;1\u0026#34;\u0026gt; 男 \u0026lt;label\u0026gt;\u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; value=\u0026#34;2\u0026#34;\u0026gt; 女 \u0026lt;/label\u0026gt; type****取值 描述 形式 text 默认值，定义单行的输入字段 password 定义密码字段 radio 定义单选按钮 checkbox 定义复选框 file 定义文件上传按钮 date/time/datetime-local 定义日期/时间/日期时间 hidden 定义隐藏域 submit/reset/button 定义提交按钮 / 重置按钮 / 可点击按钮 表格标签 标签 描述 定义表格整体 用于定义表格头部(可选) 定义表格中的主体部分(可选) 表格的行，可以包裹多个 表格单元格(普通)，可以包裹内容；如果是表头单元格，可以替换为 CSS CSS的引入方式 lCSS引入方式：\n•行内样式：写在标签的style属性中（配合JavaScript使用）\n\u0026lt;span style=\u0026#34;color: gray;\u0026#34;\u0026gt;2024年05月15日 20:07\u0026lt;/span\u0026gt; •内部样式：写在style标签中（可以写在页面任何位置，但通常约定写在head标签中）\n\u0026lt;style\u0026gt; span { color: gray; } \u0026lt;/style\u0026gt; •外部样式：写在一个单独的.css文件中（需要通过 link 标签在网页中引入）\nspan { color: gray; } \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;css/news.css\u0026#34;\u0026gt; 表示方式 属性值 说明 示例 关键字 颜色英文单词 red、green、blue red、green、blue\u0026hellip; rgb表示法 rgb(r,g,b) 红绿蓝三原色，取值：0-255 rgb(0,0,0)、rgb(255,0,0) rgba表示法 rgba(r,g,b,a) 红绿蓝三原色，a表示透明度，取值：0-1 rgba(0,0,0,0.3)、rgba(255,0,0,0.5) 十六进制表示法 #rrggbb #开头，将数字转换成十六进制表示 #000000、#ff0000，简写：#000、#f00 CSS选择器 选择器 写法 示例 示例说明 元素选择器 元素名称 {\u0026hellip;} h1 {\u0026hellip;} 选择页面上所有的标签 类选择器 .class属性值 {\u0026hellip;} .cls{\u0026hellip;} 选择页面上所有class属性为cls的标签 id****选择器 #id属性值 {\u0026hellip;} #hid {\u0026hellip;} 选择页面上id属性为hid的标签 当都出现的时候，优先级大小：\nid选择器\u0026gt;类选择器\u0026gt;元素选择器\nCSS属性 line-height：设置行高\ntext-indent：首行缩进\n盒子模型 盒子：页面中所有的元素（标签），都可以看做是一个盒子，由盒子将页面中的元素包含在一个矩形区域内，通过盒子的视角更方便的进行页面布局\n盒子模型组成：内容区域（content）、内边距区域（padding）、边框区域（border）、外边距区域（margin）\n布局标签：网页开发中，会使用 div 和 span 这两个没有语义的布局标签。\n标签： 一行只显示一个（独占一行） 宽度默认是父元素的宽度，高度默认由内容撑开 可以设置宽高（width、height） 标签： 一行可以显示多个 宽度和高度默认由内容撑开 不可以设置宽高（width、height） \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;盒子模型\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; div { width: 200px; /* 宽度 */ height: 200px; /* 高度 */ box-sizing: border-box; /* 指定width height为盒子的高宽 */ background-color: aquamarine; /* 背景色 */ padding: 20px 20px 20px 20px; /* 内边距, 上 右 下 左 , 边距都一行, 可以简写: padding: 20px;*/ border: 10px solid red; /* 边框, 宽度 线条类型 颜色 */ margin: 30px 30px 30px 30px; /* 外边距, 上 右 下 左 , 边距都一行, 可以简写: margin: 30px; */ } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt; A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; flex布局 flex是flexible Box的缩写，意为“弹性布局”，是一种一维的布局模型。flex布局可以为元素之间提供强大的空间分布和对齐能力。\n通过给父容器添加flex的相关属性，来控制子元素的位置和排列方式。\n属性 取值 含义 display flex 使用flex布局 flex-direction（设置主轴） row 主轴方向为x轴，水平向右。（默认） column 主轴方向为y轴，垂直向下。 justify-content（子元素在主轴上的对齐方式） flex-start 从头开始排列 flex-end 从尾部开始排列 center 在主轴居中对齐 space-around 平分剩余空间 space-between 先两边贴边，再平分剩余空间 总结 html：\n类别 标签 说明 文本处理标签 - 一级标题 - 六级标题 \u0026laquo;/font\u0026gt;br\u0026gt;、 换行、段落 、\u0026laquo;/font\u0026gt;em\u0026gt;、、 文本加粗、倾斜、下划线、删除线 \u0026lt;a href=\u0026rdquo;\u0026hellip;\u0026quot;\u0026gt; 超链接 （属性：href、target） 图片、音视频标签 \u0026laquo;/font\u0026gt;imgsrc=\u0026quot;\u0026hellip;\u0026quot;\u0026gt; 图片（路径：绝对路径、相对路径） \u0026lt;audio src=\u0026quot;\u0026hellip;\u0026quot;\u0026gt;、\u0026lt;video src=\u0026quot;\u0026hellip;\u0026quot;\u0026gt; 音频、视频 布局标签 、 没有语义的布局标签，配合CSS实现页面布局 表格标签 、、 表格、表头、表格主体 / 、 行 / 单元格 表单标签 定义表单（属性：action、method） 表单项（文本输入框、按钮\u0026hellip;） / 表单项（下拉列表/选项） css：\n类别 属性 说明 盒子模型 作用：控制元素尺寸、内边距、边框、外边距，从而控制页面的布局展示 width、height 高度、宽度 box-sizing 高度和宽度的计算方式；content-box，border-box padding 内边距（上、右、下、左；上下、左右） border 边框 margin 外边距（上、右、下、左；上下、左右） flex弹性布局 作用：是一种一维的布局模型，为元素之间提供强大的空间分布和对齐能力。 display flex：使用flex布局 flex-direction 设置主轴方向（row：x轴，水平方向；column：y轴，垂直方向） justify-content 子元素在主轴上的对齐方式 ","permalink":"https://wqnm1gb.github.io/posts/day01htmlcss/","summary":"\u003cp\u003eWeb的三个组成部分：\u003c/p\u003e\n\u003cp\u003e• HTML：负责网页的结构（页面元素和内容）。\u003c/p\u003e\n\u003cp\u003e• CSS：负责网页的表现（页面元素的外观、位置等页面样式，如：颜色、大小等）。\u003c/p\u003e","title":"Day01 html\u0026css"},{"content":"单元测试 就是针对最小的功能单元：方法，编写测试代码对其进行正确性测试。\n咱们之前是如何进行单元测试的？有啥问题？\n• 只能在main方法编写测试代码，去调用其他方法进行测试。\n• 无法实现自动化测试，一个方法测试失败，可能影响其他方法的测试。\n• 无法得到测试的报告，需要程序员自己去观察测试是否成功。\nJunit单元测试框架 可以用来对方法进行测试，它是第三方公司开源出来的（很多开发工具已经集成了Junit框架比如IDEA）\n优点\n• 可以灵活的编写测试代码，可以针对某个方法执行测试，也支持一键完成对全部方法的自动化测试，且各自独立。\n• 不需要程序员去分析测试的结果，会自动生成测试报告出来。\nJunit单元测试的使用步骤 需求\n• 某个系统，有多个业务方法，请使用Junit单元测试框架，编写测试代码，完成对这些方法的正确性测试。\n具体步骤\n① 将Junit框架的jar包导入到项目中（注意：IDEA集成了Junit框架，不需要我们自己手工导入了）\n② 为需要测试的业务类，定义对应的测试类，并为每个业务方法，编写对应的测试方法（必须：公共、无参、无返回值）\n③ 测试方法上必须声明@Test注解，然后在测试方法中，编写代码调用被测试的业务方法进行测试\n④ 开始测试：选中测试方法，右键选择“JUnit运行”，如果测试通过则是绿色；如果测试失败，则是红色\n反射 反射就是：加载类，并允许以编程的方式解剖类中的各种成分（成员变量、方法、构造器等）\nidea中能提示各种类里边的信息就是用了反射的方式\n获取class的三种方式 Class c1=类名.class // 1、方式1：Class c1=类名.class Class c1= Student.class; System.out.println(c1); 调用Class提供方法：public static Class forName（String package） // 2、方式2：调用Class提供方法：public static Class forName（String package） Class c2 = Class.forName(\u0026#34;com.demo02Reflect.Student\u0026#34;); System.out.println(c1==c2); Object提供的方法：public Class getClassO； Class c3 = 对象.getClassl // 3、方式3：使用对象.getClass() Student s = new Student(); Class c3 = s.getClass(); System.out.println(c3); 获取类中的构造器 反射的第一步都是拿到类\n方法 说明 Constructor[] getConstructors() 获取全部构造器（只能获取public修饰的） Constructor[] getDeclaredConstructors() 获取全部构造器（只要存在就能拿到，私有构造器也能拿到） Constructor getConstructor(Class\u0026hellip; parameterTypes) 获取某个构造器（只能获取public修饰的） Constructor getDeclaredConstructor(Class\u0026hellip; parameterTypes) 获取某个构造器（只要存在就能拿到） 获取类构造器的作用：依然是初始化对象返回 Constructor****提供的方法 说明 T newInstance(Object\u0026hellip; initargs) 调用此构造器对象表示的构造器，并传入参数，完成对象的初始化并返回 public void setAccessible(boolean flag) 设置为true，表示禁止检查访问控制（暴力反射） @Test public void getConstructor() throws Exception { Class c1 = Dog.class; // 返回一个Constructor数组 Constructor[] cons = c1.getDeclaredConstructors(); for (Constructor con : cons) { System.out.println(con); } // 获取单个构造器，里边有String和Int变量的 Constructor con1 = c1.getDeclaredConstructor(String.class, int.class); System.out.println(con1); // 创建对象并且返回 Dog d1 = (Dog)con1.newInstance(\u0026#34;小黑\u0026#34;, 2); System.out.println(d1); } 获取类中的成员变量 方法 说明 public Field[] getFields() 获取类的全部成员变量（只能获取public修饰的） public Field[] getDeclaredFields() 获取类的全部成员变量（只要存在就能拿到） public Field getField(String name) 获取类的某个成员变量（只能获取public修饰的） public Field getDeclaredField(String name) 获取类的某个成员变量（只要存在就能拿到） 获取到成员变量的作用：依然是赋值、取值\n方法 说明 void set(Object obj, Object value)： 赋值 Object get(Object obj)s 取值 public void setAccessible(boolean flag) 设置为true，表示禁止检查访问控制（暴力反射） @Test public void getField() throws Exception { // 获取成员变量 Class c1 = Dog.class; Field[] f1 = c1.getDeclaredFields(); for (Field f : f1) { System.out.println(f.getName()+\u0026#34;(\u0026#34;+f.getType().getName()+\u0026#34;)\u0026#34;); } // 获取单个成员变量 Field f2 = c1.getDeclaredField(\u0026#34;hobby\u0026#34;); System.out.println(f2.getName()+\u0026#34;(\u0026#34;+f2.getType().getName()+\u0026#34;)\u0026#34;); // 给成员变量赋值 Dog d1 = new Dog(\u0026#34;小黑\u0026#34;, 2); // 因为hobby是私有变量，所以需要暴力反射 f2.setAccessible(true); // 需要拿到f2（变量对象），再拿到d1（对象），才能进行修改 f2.set(d1, \u0026#34;看门\u0026#34;); } 获取类中的成员方法 方法 说明 Method[] getMethods() 获取类的全部成员方法（只能获取public修饰的） Method[] getDeclaredMethods() 获取类的全部成员方法（只要存在就能拿到） Method getMethod(String name, Class\u0026hellip; parameterTypes) 获取类的某个成员方法（只能获取public修饰的） Method getDeclaredMethod(String name, Class\u0026hellip; parameterTypes) 获取类的某个成员方法（只要存在就能拿到） 成员方法的作用：依然是执行\nMethod****提供的方法 说明 public Object invoke(Object obj, Object\u0026hellip; args) 触发某个对象的该方法执行。 public void setAccessible(boolean flag) 设置为true，表示禁止检查访问控制（暴力反射） public void getMethod() throws Exception { // 获取类中的方法 Class c1 = Dog.class; Method[] m1 = c1.getDeclaredMethods(); for (Method m : m1) { System.out.println(m.getName() + \u0026#34;(\u0026#34; + m.getParameterCount() + \u0026#34;)\u0026#34;); } // 获取单个成员方法 Method m2 = c1.getDeclaredMethod(\u0026#34;eat\u0026#34;); Method m3 = c1.getDeclaredMethod(\u0026#34;eat\u0026#34;, String.class); System.out.println(m2.getName() + \u0026#34;(\u0026#34; + m2.getParameterCount() + \u0026#34;)\u0026#34;); System.out.println(m3.getName() + \u0026#34;(\u0026#34; + m3.getParameterCount() + \u0026#34;)\u0026#34;); // 4、获取成员方法的目的依然是调用方法。 Dog d1 = new Dog(\u0026#34;小黑\u0026#34;, 2); m2.setAccessible(true); Object invoke = m2.invoke(d1); System.out.println(invoke); // 带回来的返回值，void参数所以是null Object invoke2 = m3.invoke(d1, \u0026#34;骨头\u0026#34;); System.out.println(invoke2); // 带回来的返回值：狗说：谢谢！谢谢！汪汪汪！ } 反射的作用 基本作用：可以得到一个类的全部成分然后操作\n可以破坏封装性。\n可以绕过泛型的约束（因为泛型是在编译的时候替换的，反射可以直接获得class文件，这个是运行时的文件，所以可以绕过约束）\n最重要的用途是：适合做Java的框架，基本上，主流的框架都会基于反射设计出一些通用的功能。\n使用反射做一个简易版的框架 需求：\n对于任意一个对象，该框架都可以把对象的字段名和对应的值，保存到文件中去。\n实现步骤\n① 定义一个方法，可以接收任意对象。\n② 每收到一个对象后，使用反射获取该对象的Class对象，然后获取全部的成员变量。\n③ 遍历成员变量，然后提取成员变量在该对象中的具体值。\n④ 把成员变量名、和其值，写出到文件中去即可。\n注解 就是Java代码里的特殊标记，比如：@Override、@Test等，作用是：让其他程序根据注解信息来决定怎么执行该程序\n注意：注解可以用在类上、构造器上、方法上、成员变量上、参数上、等位置处，最后边不需要加分号。\n自定义注解 就是自己定义注解\npublic @interface 注解名称 { public 属性类型 属性名() default 默认值 ; } 特殊属性名：value\n如果注解中只有一个value属性，使用注解时，value名称可以不写\n@A(10) public @interface A { int value(); int a() default 20; } 注解的原理 注解本质是一个接口，Java中所有注解都是继承了Annotation接口的。\n@注解（..）：其实就是一个实现类对象，实现了该注解以及Annotation接口。\n元注解 注解注解的注解\n@Retention(RetentionPolicy.RUNTIME) @Target({ElementType.METHOD}) public @interface Test { } @Target 作用：声明被修饰的注解只能在哪些位置使用\n@Target （ElementType.TYPE）\nTYPE，类，接口\nFIELD，成员变量\nMETHOD，成员方法\nPARAMETER，方法参数\nCONSTRUCTOR，构造器\nLOCAL_VARIABLE，局部变量\n@Retention 作用：声明注解的保留周期。\n@Retention（RetentionPolicy.RUNTIME）\nSOURCE：只作用在源码阶段，字节码文件中不存在。\nCLASS（默认值）：保留到字节码文件阶段，运行阶段不存在.\nRUNTIME（开发常用）：一直保留到运行阶段。\n注解的解析 就是判断类上、方法上、成员变量上是否存在注解，并把注解里的内容给解析出来\n如何解析注解 指导思想：要解析谁上面的注解，就应该先拿到谁。\n比如要解析类上面的注解，则应该先获取该类的Class对象，再通过Class对象解析其上面的注解。\n比如要解析成员方法上的注解，则应该获取到该成员方法的Method对象，再通过Method对象解析其上面的注解。\nClass、 Method、Field, Constructor、都实现了AnnotatedElement接口，它们都拥有解析注解的能力。\nAnnotatedElement****接口提供了解析注解的方法 说明 public Annotation[] getDeclaredAnnotations() 获取当前对象上面的注解。 public T getDeclaredAnnotation(Class annotationClass) 获取指定的注解对象 public boolean isAnnotationPresent(Class annotationClass) 判断当前对象上是否存在某个注解 使用注解开发出一个简易版的Junit框架 需求：定义若干个方法，只要加了Mytest注解，就会触发该方法执行\n① 定义一个自定义注解MyTest，只能注解方法，存活范围是一直都在\n② 定义若干个方法，部分方法加上@MyTest注解修饰，部分方法不加\n③ 模拟一个junit程序，可以触发加了@MyTest注解的方法执行\n注解里边的成员变量可以用来指示运行的次数\n动态代理设计模式 用明星的例子来理解\n对象如果嫌身上干的事太多的话，可以通过代理来转移部分职责。对象有什么方法想被代理，代理就一定要有对应的方法\n中介如何知道要派有唱歌、跳舞方法的代理呢 ？接口\njava.lang.reflect.Proxy类：提供了为对象产生代理对象的方法：\npublic static Object newProxyInstance(ClassLoader loader,Class[] interfaces, InvocationHandler h) 参数一：用于指定用哪个类加载器，去加载生成的代理类\n参数二：指定接口，这些接口用于指定生成的代理长什么，也就是有哪些方法\n参数三：用来指定生成的代理对象要干什么事情\n// 采用了多态的写法，返回一个接口，但是可以通过这个接口来创建代理对象 public static StarServer createProxy (Star s) { /** * 参数一：用于执行用哪个类加载器去加载生成的代理类。 * 参数二：用于指定代理类需要实现的接口: 明星类实现了哪些接口，代理类就实现哪些接口 * 参数三：用于指定代理类需要如何去代理（代理要做的事情）。 */ StarServer proxy =(StarServer)Proxy.newProxyInstance(ProxyUtl.class.getClassLoader(), s.getClass().getInterfaces(), new InvocationHandler() { // 用来声明代理对象要干的事情。 // 参数一： proxy接收到代理对象本身（暂时用处不大） // 参数二： method代表正在被代理的方法 // 参数三： args代表正在被代理的方法的参数 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 有两种method方法，判断一下 String name = method.getName(); if (\u0026#34;sing\u0026#34;.equals(name)) { System.out.println(\u0026#34;准备话筒，收钱20w\u0026#34;); } else if (\u0026#34;dance\u0026#34;.equals(name)) { System.out.println(\u0026#34;准备场地，收钱310w\u0026#34;); } // 把明星喊过来干活 Object invoke = method.invoke(s, args); return invoke; } }); return proxy; } 执行的时候，会先执行代理里边的方法\n","permalink":"https://wqnm1gb.github.io/posts/day16-java%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/","summary":"\u003ch1 id=\"单元测试\"\u003e单元测试\u003c/h1\u003e\n\u003cp\u003e就是针对最小的功能单元：方法，编写测试代码对其进行正确性测试。\u003c/p\u003e\n\u003cp\u003e咱们之前是如何进行单元测试的？有啥问题？\u003c/p\u003e\n\u003cp\u003e• 只能在main方法编写测试代码，去调用其他方法进行测试。\u003c/p\u003e","title":"Day16 Java高级技术"},{"content":"InetAddress类 代表IP地址\nInetAddress类的常用方法 说明 public static InetAddress getLocalHost() throws UnknownHostException 获取本机IP，返回一个InetAddress对象 public String getHostName() 获取该ip地址对象对应的主机名。 public String getHostAddress() 获取该ip地址对象中的ip地址信息。 public static InetAddress getByName(String host) throws UnknownHostException 根据ip地址或者域名，返回一个inetAddress对象 public boolean isReachable(int timeout) throws IOException 判断主机在指定毫秒内与该ip对应的主机是否能连通 UDP通信 特点：无连接、不可靠通信。\n不事先建立连接；发送端每次把要发送的数据（限制在64KB内）、接收端IP、等信息封装成一个数据包，发出去就不管了。\nJava提供了一个java.net.DatagramSocket类来实现UDP通信。\nDatagramSocket：用于创建客户端、服务端\n构造器 说明 public DatagramSocket() 创建客户端的Socket对象, 系统会随机分配一个端口号。 public DatagramSocket(int port) 创建服务端的Socket对象, 并指定端口号 方法 说明 public void send(DatagramPacketdp****) 发送数据包 public void receive(DatagramPacket p) 使用数据包接收数据 DatagramPacket：创建数据包\n构造器 说明 public DatagramPacket(byte[] buf, int length, InetAddress address, int port) 创建发出去的数据包对象 public DatagramPacket(byte[] buf, int length) 创建用来接收数据的数据包 方法 说明 public int getLength() 获取数据包，实际接收到的字节个数 客户端实现步骤 ① 创建DatagramSocket对象（客户端对象）\u0026mdash;\u0026mdash;\u0026gt;扔韭菜的人\n② 创建DatagramPacket对象封装需要发送的数据（数据包对象）\u0026mdash;\u0026ndash;\u0026gt;韭菜盘子\n③ 使用Datagramsocket对象的send方法，传入DatagramPaket对象 \u0026mdash;\u0026ndash;\u0026gt;开始抛出韭菜\n④ 释放资源\n客户端实现可以反复发送数据 ① 创建DatagramSocket对象（发送端对象）\n② 使用while死循环不断的接收用户的数据输入，如果用户输入的exit则退出程序\n③ 如果用户输入的不是exit，把数据封装成DatagramPacket\n④ 使用DatagramSocket对象的send方法将数据包对象进行发送\n⑤ 释放资源\n服务端实现步骤 ① 创建DatagramSocket对象并指定端口（服务端对象）\u0026mdash;\u0026ndash;\u0026gt; 接韭菜的人\n② 创建DatagramPacket对象接收数据（数据包对象）\u0026mdash;\u0026mdash;-\u0026gt; 韭菜盘子\n③ 使用DatagramSocket对象的receive方法，传入DatagramPacket对象 \u0026mdash;\u0026mdash;-\u0026gt;开始接收韭菜\n④ 释放资源\n服务端实现可以反复发送数据 ① 创建DatagramSocket对象并指定端口（服务端对象）\u0026mdash;\u0026ndash;\u0026gt; 接韭菜的人\n② 创建DatagramPacket对象接收数据（数据包对象）\u0026mdash;\u0026mdash;-\u0026gt; 韭菜盘子\n③ 使用DatagramSocket对象的receive方法，传入DatagramPacket对象 \u0026mdash;\u0026mdash;-\u0026gt;开始接收韭菜\n④ 使用while死循环不断的进行第3步\nUDP的接收端为什么可以接收很多发送端的消息？\n接收端只负责接收数据包，无所谓是哪个发送端的数据包。\nTCP通信 客户端程序就是通过java.net包下的Socket类来实现的。\n构造器 说明 public Socket(String host , int port) 根据指定的服务器ip、端口号请求与服务端建立连接，连接通过，就获得了客户端socket 方法 说明 public OutputStreamgetOutputStream() 获得字节输出流对象 public InputStreamgetInputStream() 获得字节输入流对象 通过流对象来接收和传输数据\n服务端是通过java.net包下的ServerSocket类来实现的。\n构造器 说明 public ServerSocket(int port) 为服务端程序注册端口 方法 说明 public Socket accept() 阻塞等待客户端的连接请求，一旦与某个客户端成功连接，则返回服务端这边的Socket对象。 客户端实现步骤 ① 创建客户端的Socket对象，请求与服务端的连接。\n② 使用socket对象调用getOutputstream()方法得到字节输出流。\n③ 使用字节输出流完成数据的发送。\n④ 释放资源：关闭socket管道。\n服务端实现步骤 ① 创建ServerSocket对象，注册服务端端口。\n② 调用ServerSocket对象的accept()方法，等待客户端的连接，并得到Socket管道对象。\n③ 通过Socket对象调用getInputStream()方法得到字节输入流、完成数据的接收。\n④ 释放资源：关闭socket管道\n继承了Thread类本身也可以当一个Runnable对象来进行使用，因为Thread类也实现了Runnable接口！\n时间类 JDK8之后的新方案\nLocalDate：代表本地日期（年、月、日、星期）\nLocalTime：代表本地时间（时、分、秒、纳秒）\nLocalDateTime：代表本地日期、时间（年、月、日、星期、时、分、秒、纳秒）\n方法名 示例 public static Xxxx now(): 获取系统当前时间对应的该对象 LocaDateld = LocalDate.now(); LocalTimelt = LocalTime.now(); LocalDateTimeldt = LocalDateTime.now(); LocalDateTime的常用API（可以处理年、月、日、星期、时、分、秒、纳秒等信息）\n方法名 说明 getYear、getMonthValue、getDayOfMonth、getDayOfYeargetDayOfWeek、getHour、getMinute、getSecond、getNano 获取年月日、时分秒、纳秒等 withYear、withMonth、withDayOfMonth、withDayOfYearwithHour、withMinute、withSecond、withNano 修改某个信息，返回新日期时间对象 plusYears、plusMonths、plusDays、plusWeeksplusHours、plusMinutes、plusSeconds、plusNanos 把某个信息加多少，返回新日期时间对象 minusYears、minusMonths、minusDays、minusWeeksminusHours、minusMinutes、minusSeconds、minusNanos 把某个信息减多少，返回新日期时间对象 equals isBeforeisAfter 判断2个时间对象，是否相等，在前还是在后 字符串高效操作 +号拼接字符串内容，效率不高，原因是String的对象是不可变变量，每次都要指向新的对象\n对于字符串相关的操作，如频繁的拼接、修改等，建议用StringBuidler，效率更高！\n注意：如果操作字符串较少，或者不需要操作，以及定义字符串变量，还是建议用String。\nStringBuilder代表可变字符串对象，相当于是一个容器，它里面装的字符串是可以改变的，就是用来操作字符串的。\n好处：StringBuilder比String更适合做字符串的修改操作，效率会更高，代码也会更简洁，而且支持链式操作\n构造器 说明 public StringBuilder() 创建一个空白的可变的字符串对象，不包含任何内容 public StringBuilder(String str) 创建一个指定字符串内容的可变字符串对象 方法名称 说明 public StringBuilder append(任意类型) 添加数据并返回StringBuilder对象本身 public StringBuilder reverse() 将对象的内容反转 public int length() 返回对象内容长度 public String toString() 通过toString()就可以实现把StringBuilder转换为String BigDecimal 用于解决浮点型运算时，出现结果失真的问题\n构造器 说明 public BigDecimal(double val) 注意：不推荐使用这个 将 double转换为 BigDecimal public BigDecimal(String val) 把String转成BigDecimal 方法名 说明 public static BigDecimal valueOf(double val) 转换一个 double成 BigDecimal public BigDecimal add(BigDecimal b) 加法 public BigDecimal subtract(BigDecimal b) 减法 public BigDecimal multiply(BigDecimal b) 乘法 public BigDecimal divide(BigDecimal b) 除法 public BigDecimal divide (另一个BigDecimal对象，精确几位，舍入模式) 除法、可以控制精确到小数几位 public double doubleValue() 将BigDecimal转换为double 应该如何把浮点型转换成Biglecimal的对象？\nBigDecimal b1 = BigDecimal. valueOf（0.1）\n","permalink":"https://wqnm1gb.github.io/posts/day15-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","summary":"\u003ch1 id=\"inetaddress类\"\u003eInetAddress类\u003c/h1\u003e\n\u003cp\u003e代表IP地址\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e\u003c!-- raw HTML omitted --\u003eInetAddress\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e类的常用方法\u003c!-- raw HTML omitted --\u003e\u003c/th\u003e\n          \u003cth\u003e\u003c!-- raw HTML omitted --\u003e说明\u003c!-- raw HTML omitted --\u003e\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003epublic static \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eInetAddress \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003egetLocalHost\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e() \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003ethrows \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eUnknownHostException\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003e获取本机\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eIP\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e，返回一个\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eInetAddress\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e对象\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003epublic \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eString \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003egetHostName\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e()\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003e获取该\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eip\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e地址对象对应的主机名。\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003epublic \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eString \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003egetHostAddress\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e()\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003e获取该\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eip\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e地址对象中的\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eip\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e地址信息。\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003epublic static \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eInetAddress \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003egetByName\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e(\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eString host\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e)   \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e    \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003ethrows \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eUnknownHostException\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003e根据\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eip\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e地址或者域名，返回一个\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003einetAddress\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e对象\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003epublic boolean \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eisReachable\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e(\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eint \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003etimeout\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e) \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003ethrows \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eIOException\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003e判断主机在指定毫秒内与该\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eip\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e对应的主机是否能连通\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch1 id=\"udp通信\"\u003eUDP通信\u003c/h1\u003e\n\u003cp\u003e特点：无连接、不可靠通信。\u003c/p\u003e","title":"Day15 网络编程"},{"content":"多线程 什么是线程？\n线程（Thread）是一个程序内部的一条执行流程\n程序中如果只有一条执行流程，那这个程序就是单线程的程序\n多线程是指从软硬件上实现的多条执行流程的技术（多条线程由CPU负责调度执行）\n创建线程的方式一：继承Thread类 ① 定义一个子类MyJhread继承线程类java.lang.Thread，重写run()方法\n② 创建MyThread类的对象\n③ 调用线程对象的start()方法启动线程（启动后还是执行run方法的）\n方式一优缺点：\n优点：编码简单\n缺点：线程类已经继承Thread，无法继承其他类，不利于功能的扩展。\n创建线程的注意事项 启动线程必须是调用start方法，不是调用run方法。\n•直接调用run方法会当成普通方法执行，此时相当于还是单线程执行。\n•只有调用start方法才是启动一个新的线程执行。\n不要把主线程任务放在启动子线程之前。\n• 这样主线程一直是先跑完的，相当于是一个单线程的效果了。\n创建线程的方式二：实现Runnable接口 ① 定义一个线程任务类MyRunnable实现Runnable接口，重写run()方法\n② 创建MyRunnable任务对象\n③ 把MyRunnable任务对象交给Thread处理。\nThread****类提供的构造器 说明 public Thread(Runnable target) 封装Runnable对象成为线程对象 ④ 调用线程对象的start()方法启动线程\n方式二的优缺点\n优点：任务类只是实现接口，可以继续继承其他类、实现其他接口，扩展性强。\n缺点：需要多一个Runnable对象。\n匿名内部类的写法\n① 可以创建Runnable的匿名内部类对象。\n② 再交给Thread线程对象。\n③ 再调用线程对象的start()启动线程。\nnew Thread(()-\u0026gt;{for (int i = 0; i \u0026lt; 5; i++) { System.out.println(\u0026#34;子线程2输出：\u0026#34;+ i); }}).start(); 创建线程的方式三：实现Callabel接口 ①创建任务对象\n定义一个类实现Callable接口，重写call方法，封装要做的事情，和要返回的数据。把Callable类型的对象封装成FutureJask（线程任务对象）\n②把线程任务对象交给Thread对象\n③调用Thread对象的start方法启动线程\n④线程执行完毕后、通过FutureJask对象的的get方法去获取线程任务执行的结果\nFutureTask的API\nFutureTask****提供的构造器 说明 public FutureTask\u0026lt;\u0026gt;(Callable call) 把Callable对象封装成FutureTask对象。 FutureTask****提供的方法 说明 public V get() throws Exception 获取线程执行call方法返回的结果。 线程创建方式三的优缺点\n优点：线程任务类只是实现接口，可以继续继承类和实现接口，扩展性强；可以在线程执行完毕后去获取线程执行的结果。\n缺点：编码复杂一点\n三种线程方式的对比 方式 优点 缺点 继承Thread类 编程比较简单，可以直接使用Thread类中的方法 扩展性较差，不能再继承其他的类，不能返回线程执行的结果 实现Runnable接口 扩展性强，实现该接口的同时还可以继承其他的类。 编程相对复杂，不能返回线程执行的结果 实现Callable接口 扩展性强，实现该接口的同时还可以继承其他的类。可以得到线程执行的结果 编程相对复杂 Thread的常用方法 Thread****提供的常用方法 说明 public void run() 线程的任务方法 public void start() 启动线程 public String getName****() 获取当前线程的名称，线程名称默认是Thread-索引 public void setName****(String name) 为线程设置名称，设置名字要在启动线程之前 public static Thread currentThread****() 获取当前执行的线程对象 public static void sleep(long time) 让当前执行的线程休眠多少毫秒后，再继续执行 public final void join()\u0026hellip; 让调用当前这个方法的线程先执行完，相当于插队 Thread****提供的常见构造器 说明 public Thread(String name) 可以为当前线程指定名称 public Thread(Runnable target) 封装Runnable对象成为线程对象 public Thread(Runnable target,String name) 封装Runnable对象成为线程对象，并指定线程名称 主线程的名字是main\n创建的线程名字是 Thread-编号\n解决线程安全问题的方法 方法1：同步代码块 作用：把访问共享资源的核心代码给上锁，以此保证线程安全。\nsynchronized（同步锁）{ 访问共享资源的核心代码 } 原理：每次只允许一个线程加锁后进入，执行完毕后自动解锁，其他线程才可以进来执行\n同步锁的注意事项\n对于当前同时执行的线程来说，同步锁必须是同一把（同一个对象），否则会出bug。\n锁对象随便选择一个唯一的对象好不好呢？\n不好，会影响其他无关线程的执行。\n锁对象的使用规范\n建议使用共享资源作为锁对象，对于实例方法建议使用this作为锁对象。\n对于静态方法建议使用字节码（类名.class）对象作为锁对象。\n方法2：同步方法 作用：把访问共享资源的核心方法给上锁，以此保证线程安全。\n修饰符 synchronized 返回值类型 方法名称（形参列表）{ 操作共享资源的代码 } 原理：每次只能一个线程进入，执行完毕以后自动解锁，其他线程才可以进来执行\n同步方法底层原理\n同步方法其实底层也是有隐式对象的，只是锁的范围是整个方法代码。\n如果方法是实例方法：同步方法默认用this作为的锁对象。\n如果方法是静态方法：同步方法默认用类名.class作为的锁对象。\n把run方法用synchronized修饰不一定有效果\n同步代码块好还是同步方法好？\n范围上：同步代码块锁的范围更小，同步方法锁的范围更大\n可读性：同步方法更好\n方式3：Lock锁 Lock锁是JDK5开始提供的一个新的锁定操作，通过它可以创建出锁对象进行加锁和解锁，更灵活、更方便、更强大。\nLock是接口，不能直接实例化，可以采用它的实现类Reentrantlgck来构建Lock锁对象。\n构造器 说明 public ReentrantLock() 获得Lock锁的实现类对象 方法名称 说明 void lock() 获得锁 void unlock() 释放锁 锁对象建议加上什么修饰？\n建议使用final修饰，防止被别人篡改\n释放锁的操作建议放到哪里？\n建议将释放锁的操作放到finally代码块中，确保锁用完了一定会被释放\n线程池 线程池就是一个可以复用线程的技术。\n不使用线程池的问题\n用户每发起一个请求，后台就需要创建一个新线程来处理，下次新任务来了肯定又要创建新线程处理的，创建新线程的开销是很大的，并且请求过多时，肯定会产生大量的线程出来，这样会严重影响系统的性能。\n任务队列中只能是Runnable和Callable任务\n创建线程池 JDK 5.0起提供了代表线程池的接口：ExecutorService。\n方式一：使用ExecutorService的实现类ThreadPoolExecutor自创建一个线程池对象\nThreadPoolExecutor类提供的构造器 作用 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue\u0026laquo;/font\u0026gt;Runnable\u0026gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) 使用指定的初始化参数创建一个新的线程池对象 参数一：corePoolSize：指定线程池的核心线程的数量。 正式工：3\n参数二：maximumPoolSize：指定线程池的最大线程数量。最大员工数：5 临时工：2\n参数三：keepAliveTime：指定临时线程的存活时间。 临时工空闲多久被开除\n参数四：unit：指定临时线程存活的时间单位（秒、分、时、天）\n参数五：workQueue：指定线程池的任务队列。 客人排队的地方\n参数六：threadFactory：指定线程池的线程工厂。 负责招聘员工的（hr）\n参数七：handler：指定线程池的任务拒绝策略（线程都在忙，任务队列也满了的时候，新任务来了该怎么处理） 忙不过来咋办？\n方式二：使用Executors（线程池的工具类）调用方法返回不同特点的线程池对象\n方法名称 说明 public static ExecutorService newFixedThreadPool(int nThreads) 创建固定线程数量的线程池，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程替代它。 public static ExecutorService newSingleThreadExecutor() 创建只有一个线程的线程池对象，如果该线程出现异常而结束，那么线程池会补充一个新线程。 public static ExecutorService newCachedThreadPool() 线程数量随着任务增加而增加，如果线程任务执行完毕且空闲了60s则会被回收掉。 public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) 创建一个线程池，可以实现在给定的延迟后运行任务，或者定期执行任务。 大型并发系统环境中使用Executors如果不注意可能会出现系统风险\nExecutors工具类底层是基于什么方式实现的线程池对象？\n线程池ExecutorSeryi.ce的实现类：ThreadPooJExecutor\nExecutors是否适合做大型互联网场景的线程池方案？\n不合适。\n建议使用ThreadPoolExecutor来指定线程池参数，这样可以明确线程池的运行规则，规避资源耗尽的风险。\n处理Runnable任务 方法名称 说明 void execute(Runnable command) 执行 Runnable 任务 Future submit(Callable task) 执行 Callable 任务，返回未来任务对象，用于获取线程返回的结果 void shutdown() 等全部任务执行完毕后，再关闭线程池！ List\u0026laquo;/font\u0026gt;Runnable\u0026gt; shutdownNow() 立刻关闭线程池，停止正在执行的任务，并返回队列中未执行的任务 线程池的注意事项 什么时候开始创建临时线程？ 新任务提交时发现核心线程都在忙，任务队列也满了，并且还可以创建临时线程，此时才会创建临时线程。\n什么时候会拒绝新任务？ 核心线程和临时线程都在忙，任务队列也满了，新的任务过来的时候才会开始拒绝任务。\n任务拒绝策略\n策略 说明 ThreadPoolExecutor.AbortPolicy() 丢弃任务并抛出RejectedExecutionException异常。是默认的策略 ThreadPoolExecutor. DiscardPolicy() 丢弃任务，但是不抛出异常，这是不推荐的做法 ThreadPoolExecutor. DiscardOldestPolicy() 抛弃队列中等待最久的任务 然后把当前任务加入队列中 ThreadPoolExecutor. CallerRunsPolicy() 由主线程负责调用任务的run()方法从而绕过线程池直接执行 处理Callable任务 线程池如何处理Callable任务，并得到任务执行完后返回的结果？\n使用ExecutorService的方法\nFuture submit（Callable command） 多态写法，返回一个RunnableFuture对象，可以调用里边get()方法\n进程 正在运行的程序（软件）就是一个独立的进程\n线程是属于进程的，一个进程中可以同时运行很多个线程\n进程中的多个线程其实是并发和并行执行的\n并发的含义 进程中的线程是由CPU负责调度执行的，但CPU能同时处理线程的数量有限，为了保证全部线程都能往前执行，CPU会轮询为系统的每个线程服务，由于CPU切换的速度很快，给我们的感觉这些线程在同时执行，这就是并发。\n并行的理解 在同一个时刻上，同时有多个线程在被CPU调度执行。\n","permalink":"https://wqnm1gb.github.io/posts/day14-thread/","summary":"\u003ch2 id=\"多线程\"\u003e多线程\u003c/h2\u003e\n\u003cp\u003e什么是线程？\u003c/p\u003e\n\u003cp\u003e线程（Thread）是一个程序内部的一条执行流程\u003c/p\u003e\n\u003cp\u003e程序中如果只有一条执行流程，那这个程序就是单线程的程序\u003c/p\u003e\n\u003cp\u003e多线程是指从软硬件上实现的多条执行流程的技术（多条线程由CPU负责调度执行）\u003c/p\u003e","title":"Day14 Thread"},{"content":"File File是java.io.包下的类，File类的对象，用于代表当前操作系统的文件（可以是文件、或文件夹）\n注意：File类只能对文件本身进行操作，不能读写文件里面存储的数据\n可以使用相对路径定位文件对象\n只要带盘符的都称之为：绝对路径E:/resource/aaa.jpg\n相对路径：不带盘符，默认是到你的idea工程下直接寻找文件的，一般用来找工程下的项目文件的\n注意只能相对到工程，后边的文件夹名和src还需要手动写\n创建File对象 构造器 说明 public File(String pathname) 根据文件路径创建文件对象 public File(String parent, String child) 根据父路径和子路径名字创建文件对象 File对象既可以代表文件、也可以代表文件夹。\nFile封装的对象仅仅是一个路径名，这个路径可以是存在的，也允许是不存在的。\n可以用/，也可以用\\\nFile提供的判断文件类型、获取文件信息功能 方法名称 说明 public boolean exists() 判断当前文件对象，对应的文件路径是否存在，存在返回true public booleanisFile() 判断当前文件对象指代的是否是文件，是文件返回true，反之。 public booleanisDirectory() 判断当前文件对象指代的是否是文件夹，是文件夹返回true，反之。 public String getName() 获取文件的名称（包含后缀） public long length() 获取文件的大小，返回字节个数 public long lastModified() 获取文件的最后修改时间。 public String getPath() 获取创建文件对象时，使用的路径 public String getAbsolutePath() 获取绝对路径 File提供的创建和删除文件的方法 File类创建文件的功能 方法名称 说明 public booleancreateNewFile() 创建一个新的空的文件 public booleanmkdir() 只能创建一级文件夹 public booleanmkdirs() 可以创建多级文件夹 File类删除文件的功能 方法名称 说明 public boolean delete() 删除文件、空文件夹 注意：delete方法默认只能删除文件和空文件夹，删除后的文件不会进入回收站。\nFile提供的遍历文件夹的方法 方法名称 说明 public String[] list() 获取当前目录下所有的\u0026quot;一级文件名称\u0026quot;到一个字符串数组中去返回。 public File[] listFiles() 获取当前目录下所有的\u0026quot;一级文件对象\u0026quot;到一个文件对象数组中去返回（重点） 使用listFiles方法时的注意事项：\n• 当主调是文件，或者路径不存在时，返回null\n• 当主调是空文件夹时，返回一个长度为0的数组\n• 当主调是一个有内容的文件夹时，将里面所有一级文件和文件夹的路径放在File数组中返回\n• 当主调是一个文件夹，目里面有隐藏文件时，将里面所有文件和文件夹的路径放在File数组中返回，包含隐藏文件\n• 当主调是一个文件夹，但是没有权限访问该文件夹时，返回null\n递归的三要素 递归的公式： f(n)= f(n-1)*n；\n递归的终结点：f(1)\n递归的方向必须走向终结点\n文件搜索 先找出D:盘下的所有一级文件对象\n遍历全部一级文件对象，判断是否是文件\n如果是文件，判断是否是自己想要的\n如果是文件夹，需要继续进入到该文件夹，重复上述过程\n字符集 标准的ASCII编码 ASCII（American Standard Code for Information Interchange）：美国信息交换标准代码，包括了英文、符号等。\n标准ASCIl使用1个字节存储一个字符，首位是0因此，总共可表示128个字符，对美国佬来说完全够用。\nGBK（汉字内码扩展规范，国标） 汉字编码字符集，包含了2万多个汉字等字符，GBK中一个中文字符编码成两个字节的形式存储。\n注意：GBK兼容了ASCII字符集。\nGBK规定：汉字的第一个字节的第一位必须是1\nUnicode字符集（统一码，也叫万国码） Unicode是国际组织制定的，可以容纳世界上所有文字、符号的字符集。\nUTF-8字符集 是Unicode字符集的一种编码方案，采取可变长编码方案，共分四个长度区：1个字书，2个字节，3个字节，4个字节（不像Unicode会占用4个字节，太大了）\n英文字符、数字等只占1个字节（兼容标准ASCII编码），汉字字符占用3个字节。\n前缀码\n注意1：字符编码时使用的字符集，和解码时使用的字符集必须一致，否则会出现乱码\n注意2：英文，数字一般不会乱码，因为很多字符集都兼容了ASCII编码。\n对字符集进行编码\nString提供了如下方法 说明 byte[] getBytes() 使用平台的默认字符集将该String编码为一系列字节，将结果存储到新的字节数组中 byte[] getBytes(String charsetName) 使用指定的字符集将该 String编码为一系列字节，将结果存储到新的字节数组中 对字符的解码\nString****提供了如下方法 说明 String(byte[] bytes) 通过使用平台的默认字符集解码指定的字节数组来构造新的 String String(byte[] bytes, String charsetName) 通过指定的字符集解码指定的字节数组来构造新的 String IO流 用于读写数据的（可以读写文件，或者网络上的数据）\nIO流的分类 IO流的体系 FileInputStream（文件字节输入流） 作用：以内存为基准，可以把磁盘文件中的数据以字节的形式读入到内存中去。\n构造器 说明 public FileInputStream(File file) 创建字节输入流管道与源文件接通 public FileInputStream(String pathname) 创建字节输入流管道与源文件接通 方法名称 说明 public int read() 每次读取一个字节返回，如果发现没有数据可读会返回-1，性能较差，而且不能读中文，每次读一个字节的话，中文会乱码 public int read(byte[] buffer) 每次用一个字节数组去读取数据，返回字节数组读取了多少个字节，如果发现没有数据可读会返回-1 使用FilelnputStream每次读取一个字节，读取性能较差，并且读取汉字输出会乱码。\n使用FilelnputStream每次读取多个字节，读取性能得到了提升，但读取汉字输出还是会乱码。\n1、使用字节流读取中文，如何保证输出不乱码，怎么解决？\n定义一个与文件一样大的字节数组，一次性读取完文件的全部字节（只适合读小文件）\nJava提供了方法：\n方法名称 说明 public byte[] readAllBytes() throws IOException 直接将当前字节输入流对应的文件对象的字节数据装到一个字节数组返回 如果文件过大，创建的字节数组也会过大，可能引起内存溢出。\n读取文本适合用字符流 字节流适合做数据的转移，比如：文件复制\nFileOutputStream文件字节输出流 作用：以内存为基准，把内存中的数据以字节的形式写出到文件中去。\n用完流后都要关闭\n\u0026ldquo;\\r\\n\u0026rdquo;.getBytes(); // 写出一个换行符\n构造器 说明 public FileOutputStream(File file) 创建字节输出流管道与源文件对象接通 public FileOutputStream(String filepath) 创建字节输出流管道与源文件路径接通 public FileOutputStream(File file，boolean append) 创建字节输出流管道与源文件对象接通，可追加数据，后边跟true表示可以追加 public FileOutputStream(String filepath，boolean append) 创建字节输出流管道与源文件路径接通，可追加数据 方法名称 说明 public void write(int a) 写一个字节出去 public void write(byte[] buffer) 写一个字节数组出去 public void write(byte[] buffer , int pos , int len) 写一个字节数组的一部分出去。 public void close() throws IOException 关闭流。 资源释放的问题 try-catch-finally finally代码区的特点：无论try中的程序是正常执行了，还是出现了异常，最后都一定会执行finally区，除非JVM终止。\n作用：一般用于在程序执行完成后进行资源的释放操作（专业级做法），但是比较臃肿\ntry-with-resource try(定义资源1;定义资源2;…）{ 可能出现异常的代码; }catch(异常类名 变量名){ 异常的处理代码; } 该资源使用完毕后，会自动调用其close()方法，完成对资源的释放！\n()中只能放置资源，否则报错\n什么是资源呢？\n资源一般指的是最终实现了AutoCloseable接口。\n字符流 FileReader文件字符输入流 作用：以内存为基准，可以把文件中的数据以字符的形式读入到内存中去。\n拓展：文件字符输入流每次读取多个字符，性能较好，而且读取中文是按照字符读取，不会出现乱码！这是一种读取中文很好的方案。\n构造器 说明 public FileReader****(File file) 创建字符输入流管道与源文件接通 public FileReader****(String pathname) 创建字符输入流管道与源文件接通 方法名称 说明 public int read() 每次读取一个字符返回，如果发现没有数据可读会返回-1. public int read(char[] buffer) 每次用一个字符数组去读取数据，返回字符数组读取了多少个字符，如果发现没有数据可读会返回-1. 读文档的时候，不要需加换行符，文档中自己有换行符\n�\nFileWriter文件字符输出流 以内存为基准，把内存中的数据以字符的形式写出到文件中去。\n构造器 说明 public FileWriter(File file) 创建字节输出流管道与源文件对象接通 public FileWriter(String filepath) 创建字节输出流管道与源文件路径接通 public FileWriter(File file，boolean append) 创建字节输出流管道与源文件对象接通，可追加数据 public FileWriter(String filepath，boolean append) 创建字节输出流管道与源文件路径接通，可追加数据 方法名称 说明 void write(int c) 写一个字符 void write(String str) 写一个字符串 void write(String str, int off, int len) 写一个字符串的一部分 void write(char[] cbuf) 写入一个字符数组 字符输出流写出数据后，必须刷新流，或者关闭流，写出去的数据才能生效\n方法名称 说明 public void flush() throws IOException 刷新流，就是将内存中缓存的数据立即写到文件中去生效！ public void close() throws IOException 关闭流的操作，包含了刷新！ 使用close就会默认刷新，或者使用try with resource也会默认在关闭的时候刷新\nBufferedInputstream缓冲字节输入和输出流 作用：可以提高字节输入流读取数据的性能\n原理：缓冲字节输入流自带了8KB缓冲池；缓冲字节输出流也自带了8KB缓冲池。\n构造器 说明 public BufferedInputStream(InputStream is) 把低级的字节输入流包装成一个高级的缓冲字节输入流，从而提高读数据的性能 public BufferedOutputStream(OutputStreamos) 把低级的字节输出流包装成一个高级的缓冲字节输出流，从而提高写数据的性能 BufferedReader缓冲字符输入流 作用：自带8K（8192）的字符缓冲池，可以提高字符输入流读取字符数据的性能。\n构造器 说明 public BufferedReader(Reader r) 把低级的字符输入流包装成字符缓冲输入流管道，从而提高字符输入流读字符数据的性能 字符缓冲输入流新增的功能：按照行读取字符\n方法 说明 public String readLine() 读取一行数据返回，如果没有数据可读了，会返回null Bufferedwriter缓冲字符输出流 作用：自带8K的字符缓冲池，可以提高字符输出流写字符数据的性能。\n构造器 说明 public BufferedWriter(Writer r) 把低级的字符输出流包装成一个高级的缓冲字符输出流管道，从而提高字符输出流写数据的性能（把低级管道变成一个高级管道，里边包着一个高级管道） 字符缓冲输出流新增的功能：换行\n方法 说明 public void newLine() 换行 可以把低级管道的缓冲桶加大，那么这样性能就会接近高级管道，所以并不是低级管道的新能一定差，相对来说，桶越大，复制速度越快\n其他流 InputStreamReader（字节输入转换流） 解决不同编码时，字符流读取文本内容乱码的问题。\n解决思路： 先获取文件的原始字节流再将其按真实的字符集编码转成字符输入流，这样字符输入流中的字符就不乱码了。\n这也是个高级流，里边可以包着一个低级流\n构造器 说明 public InputStreamReader(InputStream is) 把原始的字节输入流，按照代码默认编码转成字符输入流（与直接用FileReader的效果一样） public InputStreamReader(InputStream is ，String charset) 把原始的字节输入流，按照指定字符集编码转成字符输入流(重点) PrintStream/PrintWriter（打印流） 作用：打印流可以实现更方便、更高效的打印数据出去，能实现打印啥出去就是啥出去，性能也高。\nPrintStream提供的打印数据的方案\n构造器 说明 public PrintStream(OutputStream/File/String) 打印流直接通向字节输出流/文件/文件路径 publicPrintStream(String fileName, Charset charset) 可以指定写出去的字符编码 publicPrintStream(OutputStream out, boolean autoFlush) 可以指定实现自动刷新 publicPrintStream(OutputStream out, boolean autoFlush, String encoding) 可以指定实现自动刷新，并可指定字符的编码 方法 说明 public void println(Xxx**** xx) 打印任意类型的数据出去，天生自带换行 public void write(int/byte[]/byte[]一部分) 可以支持写字节数据出去 PrintWriter提供的打印数据的方案\n构造器 说明 public Print****Writer(OutputStream/Writer/File/String) 打印流直接通向字节输出流/文件/文件路径 publicPrintWriter(String fileName, Charset charset) 可以指定写出去的字符编码 publicPrintWriter(OutputStream out/Writer, boolean autoFlush) 可以指定实现自动刷新 publicPrintWriter(OutputStream out, boolean autoFlush, String encoding) 可以指定实现自动刷新，并可指定字符的编码 方法 说明 public void println(Xxx**** xx) 打印任意类型的数据出去 public void write(int/String/char[]/..) 可以支持写字符数据出去 PrintStream和PrintWriter的区别 • 打印数据的功能上是一模一样的：都是使用方便，性能高效（核心优势）\n• PrintStream继承自字节输出流OutputStream，因此支持写**字节数据**的方法。\n• PrintWriter继承自**字符输出流Writer，因此支持写字符数据**出去。\nDataOutputStream（数据输出流） 允许把数据和其类型一并写出去。\n构造器 说明 public DataOutputStream(OutputStream**** out) 创建新数据输出流包装基础的字节输出流 方法 说明 public final void writeByte(int v) throws IOException 将byte类型的数据写入基础的字节输出流 public final void writeInt****(int v) throws IOException 将int类型的数据写入基础的字节输出流 public final void writeDouble(Double v) throws IOException 将double类型的数据写入基础的字节输出流 public final void writeUTF(String str) throws IOException 将字符串数据以UTF-8编码成字节写入基础的字节输出流 public void write(int/byte[]/byte[]一部分) 支持写字节数据出去 DatalnputStream（数据输入流） 用于读取数据输出流写出去的数据。\n构造器 说明 public DataInputStream(InputStream**** is) 创建新数据输入流包装基础的字节输入流 方法 说明 Public final byte readByte() throws IOException 读取字节数据返回 public final int readInt****() throws IOException 读取int类型的数据返回 public final double readDouble() throws IOException 读取double类型的数据返回 public final String readUTF****() throws IOException 读取字符串数（UTF-8）据返回 public int readInt()/read(byte[]) 支持读字节数据进来 IO框架 什么是框架？\n框架（Framework）是一个预先写好的代码库或一组工具，旨在简化和加速开发过程\n框架的形式：一般是把类、接口等编译成class形式，再压缩成一个.jar结尾的文件发行出去\n导入commons-io-2.11.0jar框架到项目的步骤\n① 在项目中创建一个文件夹：lib\n② 将commons-io-2.6.jar文件复制到1ib文件夹\n③ 在jar文件上点右键，选择 Add as Library -\u0026gt; 点击OK\n④ 在类中导包使用\nCommons-io框架\nCommons-io是apache开源基金组织提供的一组有关IO操作的小框架，目的是提高IO流的开发效率。\nFileUtils类提供的部分方法展示 说明 public static void copyFile(File srcFile, File destFile) 复制文件。 public static void copyDirectory(File srcDir, File destDir) 复制文件夹 public static void deleteDirectory(File directory) 删除文件夹 public static String readFileToString(File file, String encoding) 读数据 public static void writeStringToFile(File file, String data, String charname, boolean append) 写数据 IOUtils类提供的部分方法展示 说明 public static int copy(InputStreaminputStream, OutputStreamoutputStream) 复制文件。 public static int copy(Reader reader, Writer writer) 复制文件。 public static void write(String data, OutputStream output, String charsetName) 写数据 ","permalink":"https://wqnm1gb.github.io/posts/day13-file%E5%92%8Cio%E6%B5%81/","summary":"\u003ch2 id=\"file\"\u003eFile\u003c/h2\u003e\n\u003cp\u003eFile是java.io.包下的类，File类的对象，用于代表当前操作系统的文件（可以是文件、或文件夹）\u003c/p\u003e\n\u003cp\u003e注意：File类\u003c!-- raw HTML omitted --\u003e只能对文件本身进行操作，不能读写文件里面存储的数据\u003c!-- raw HTML omitted --\u003e\u003c/p\u003e","title":"Day13 File和IO流"},{"content":"Set系列集合：添加的元素是无序、不重复、无索引 HashSet： 无序、不重复、无索引\nLinkedHashSet： 有序、不重复、无索引\nTreeSet：排序（按照大小默认升序排序）、不重复、无索引\nSet要用到的常用方法，基本上就是Collection提供的！！\n自己几乎没有额外新增一些常用功能！\nHashSet的底层原理 哈希值：就是一个int类型的随机值，Java中每个对象都有一个哈希值。\nJava中的所有对象，都可以调用Obejct类提供的hashCode方法，返回该对象自己的哈希值。\n对象哈希值的特点 同一个对象多次调用hashCode()方法返回的哈希值是相同的。\n不同的对象，它们的哈希值大概率不相等，但也有可能会相等（哈希碰撞）。\n基于哈希表存储数据的。\n哈希表\n• JDK8之前，哈希表=数组+链表\n创建一个默认长度16的数组，默认加载因子为0.75，16*0.75=12，存的数据超过12，扩容，增加一被的容量，数组名table\n使用元素的哈希值对数组的长度做运算计算出应存入的位置\n判断当前位置是否为null，如果是null直接存入\n如果不为null，表示有元素，则调用equals方法比较相等，则不存；不相等，则存入数组\nJDK 8之前，新元素存入数组，占老元素位置，老元素挂下面\nJDK 8开始之后，新元素直接挂在老元素下面\nJDK8开始 当链表长度超过8 且数组长度\u0026gt;=64时 自动将链表转成红黑树（提高检索性能）\n• JDK8开始，哈希表=数组+链表+红黑树\n• 哈希表是一种增删改查数据，性能都较好的数据结构\nHashSet集合去重复机制\n结论：如果希望Set集合认为2个内容一样的对象是重复的，必须重写对象的hashCode()和equals()方法\nLinkHashSet的底层原理 依然是基于哈希表（数组、链表、红黑树）实现的。\n但是，它的每个元素都额外的多了一个双链表的机制记录它前后元素的位置。\nTreeSet集合 特点：不重复、无索引、可排序（默认升序排序，按照元素的大小，由小到大排序）\n底层是基于红黑树实现的排序。\n注意：\n• 对于数值类型：Integer,Double，默认按照数值本身的大小进行升序排序。\n• 对于字符串类型：默认按照首字符的编号升序排序。\n• 对于自定义类型如Student对象，TreeSet默认是无法直接排序的。\n结论：TreeSet集合默认不能 给白定义对象排序啊，因为不知道大小规则，并且一定要实现\n1、对象类实现一个Comparable比较接口，重写compareTo方法，指定大小比较规则\n@Override public int compareTo(Teacher o) { //用年龄进行比较 if(this.age\u0026gt;o.age) return 1; if(this.age\u0026lt;o.age) return -1; //如果return 0的话，两个相等的值就只会保留一个，如果想都保留，需要在相等的时候return1 return 1; // return 0; } 2、public Treeset （Comparator c）集合自带比较器Comparator对象，指定比较规则（优先级更高）\n//解决方法2、public Treeset （Comparator c）集合自带比较器Comparator对象，指定比较规则（优先级更高） // Set\u0026lt;Teacher\u0026gt; set = new TreeSet\u0026lt;\u0026gt;(new Comparator\u0026lt;Teacher\u0026gt;() { // @Override // public int compare(Teacher o1, Teacher o2) { // return o2.getAge()-o1.getAge(); // } // }); Set\u0026lt;Teacher\u0026gt; set = new TreeSet\u0026lt;\u0026gt;((o1, o2) -\u0026gt; o2.getAge()-o1.getAge()); Map-双列集合 每个元素包含两个值（键值对）\nMap集合也被叫做“键值对集合”，格式：｛keyl=valuel，key2=value2,key3=value3，\u0026hellip;｝\nMap集合的所有键是不允许重复的，但值可以重复，键和值是一一对应的，每一个键只能找到自己对应的值\n需要存储一一对应的数据时，就可以考虑使用Map集合来做\nMap集合体系的特点 注意：Map系列集合的特点都是由键决定的，值只是一个附属品，值是不做要求的\n• HashMap（由键决定特点）：无序、不重复、无索引、键值对可以都是null；（用的最多）\n• LinkedHashMap（由键决定特点）：由键决定的特点：有序、不重复、无索引、键值对可以都是null\n• TreeMap（由键决定特点）：按照大小默认升序排序、不重复、无索引\nMap集合的常用方法 方法名称 说明 public V put(K key,V value) 添加元素 public int size() 获取集合的大小 public void clear() 清空集合 public booleanisEmpty() 判断集合是否为空，为空返回true , 反之 public V get(Object key) 根据键获取对应值 public V remove(Object key) 根据键删除整个元素 public booleancontainsKey(Object key) 判断是否包含某个键 public booleancontainsValue(Object value) 判断是否包含某个值 public Set keySet() 获取全部键的集合 public Collection values() 获取Map集合的全部值 Map集合的遍历方式 方式1：键找值 先获取Map集合全部的键，再通过遍历键来找值\npublic static void main(String[] args) { //遍历方式1 键找值：通过Set集合获得键集合，然后找到所有的值集合 Map\u0026lt;String,Integer\u0026gt; m =new HashMap\u0026lt;\u0026gt;(); m.put(\u0026#34;张三\u0026#34;,18); m.put(\u0026#34;李四\u0026#34;,19); m.put(\u0026#34;王五\u0026#34;,20); m.put(\u0026#34;王五\u0026#34;,22);//键相同的情况下只会保留一个键值对 m.put(\u0026#34;赵六\u0026#34;,21); Set\u0026lt;String\u0026gt; keys = m.keySet(); for (String key : keys) { System.out.println(key+\u0026#34;--\u0026gt;\u0026#34;+m.get(key)); } } 方式2：键值对 Map****提供的方法 说明 Set\u0026laquo;/font\u0026gt;Map.Entry\u0026lt;K, V\u0026raquo; entrySet() 获取所有“键值对”的集合 Map.Entry****提供的方法 说明 K getKey() 获取键 V getValue() 获取值 public static void main(String[] args) { //遍历方式2 键值对：Set\u0026lt;Map.Entry\u0026lt;K, V\u0026gt;\u0026gt; entrySet() Map\u0026lt;String,Integer\u0026gt; m =new HashMap\u0026lt;\u0026gt;(); m.put(\u0026#34;张三\u0026#34;,18); m.put(\u0026#34;李四\u0026#34;,19); m.put(\u0026#34;王五\u0026#34;,20); m.put(\u0026#34;王五\u0026#34;,22);//键相同的情况下只会保留一个键值对 m.put(\u0026#34;赵六\u0026#34;,21); Set\u0026lt;Map.Entry\u0026lt;String,Integer\u0026gt;\u0026gt; set = m.entrySet(); // Map.Entry\u0026lt;String,Integer\u0026gt;相当于是一个类型 for (Map.Entry\u0026lt;String, Integer\u0026gt; stringIntegerEntry : set) { String s = stringIntegerEntry.getKey(); Integer i = stringIntegerEntry.getValue(); System.out.println(s+\u0026#34;---\u0026gt;\u0026#34;+i); } } 方式3：Lambda 本质也是增强for\n方法名称 说明 default void forEach(BiConsumer\u0026lt;? super K, ? super V\u0026gt; action) 结合lambda遍历Map集合 public static void main(String[] args) { //遍历方式3 Lambda Map\u0026lt;String,Integer\u0026gt; m =new HashMap\u0026lt;\u0026gt;(); m.put(\u0026#34;张三\u0026#34;,18); m.put(\u0026#34;李四\u0026#34;,19); m.put(\u0026#34;王五\u0026#34;,20); m.put(\u0026#34;王五\u0026#34;,22);//键相同的情况下只会保留一个键值对 m.put(\u0026#34;赵六\u0026#34;,21); m.forEach((k,v)-\u0026gt;System.out.println(k+\u0026#34;--\u0026gt;\u0026#34;+v)); m.forEach(new BiConsumer\u0026lt;String, Integer\u0026gt;() { @Override public void accept(String s, Integer integer) { //重写accpet方法就可以遍历 System.out.println(s+\u0026#34;--\u0026gt;\u0026#34;+integer); } }); HashMap的底层原理 实际上：原来学的Set系列集合的底层就是基于Map实现的，只是Set集合中的元素只要键数据，不要值数据而已。\nLinkHashMap的底层原理 实际上：原来学习 的LinkedHashSet集合的底层原理就是LinkedHashMap。\nTreeMap的底层原理 特点：不重复、无索引、可排序（按照键的大小默认升序排序，只能对键排序）\n原理：TreeMap跟TreeSet集合的底层原理是一样的，都是基于红黑树实现的排序。\nTreeMap集合同样也支持两种方式来指定排序规则\n• 让类实现Comparable接口，重写比较规则。\n• TreeMap集合有一个有参数构造器，支持创建Comparator比较器对象，以便用来指定比较规则。\nStream流 是Jdk8开始新增的一套API （java.util.stream.*），可以用于操作集合或者数组的数据。\n优势：Stream流大量的结合了Lambda的语法风格来编程，功能强大，性能高效，代码简洁，可读性好。\nStream流的使用步骤 获取Stream流 • 获取集合的Stream流\nCollection提供的如下方法\ndefault Streams stream()\n获取当前集合对象的stream流\n• 获取 数组的Stream流\nArrays类提供的如下方法\npublic static Streams stream(T[] array)\n获取当前数组的stream流\nStream类提供的如下方法\npublic static Streams of (T\u0026hellip; values)\n//\u0026hellip;是可变参数\n获取当前接收数据的stream流\nStream流上的常用方法 称为中间方法，用完之后会返回一个新的流，支持链式编程\npublic static void main(String[] args) { // 目标：认识Stream流的常用方法 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;张无忌\u0026#34;); list.add(\u0026#34;周芷若\u0026#34;); list.add(\u0026#34;赵敏\u0026#34;); list.add(\u0026#34;张强\u0026#34;); list.add(\u0026#34;张三丰\u0026#34;); list.add(\u0026#34;张翠山\u0026#34;); // 1、过滤方法 list.stream().filter(s -\u0026gt; s.startsWith(\u0026#34;张\u0026#34;) \u0026amp;\u0026amp; s.length() == 3).forEach(System.out::println); System.out.println(\u0026#34;=========================\u0026#34;); // 2.排序方法 List\u0026lt;Double\u0026gt; scores = new ArrayList\u0026lt;\u0026gt;(); scores.add(88.6); scores.add(66.6); scores.add(66.6); scores.add(77.6); scores.add(77.6); scores.add(99.6); scores.stream().sorted().forEach(System.out::println); // 升序 System.out.println(\u0026#34;=========================\u0026#34;); // 降序需要重写 scores.stream().sorted((o1,o2)-\u0026gt; Double.compare(o2,o1)).forEach(System.out::println); System.out.println(\u0026#34;=========================\u0026#34;); // 3、只要前两名 scores.stream().sorted((o1,o2)-\u0026gt; Double.compare(o2,o1)).limit(2).forEach(System.out::println); System.out.println(\u0026#34;=========================\u0026#34;); // 4、跳过前两名 scores.stream().sorted((o1,o2)-\u0026gt; Double.compare(o2,o1)).skip(2).forEach(System.out::println); System.out.println(\u0026#34;=========================\u0026#34;); // 5、去重 scores.stream().sorted((o1,o2)-\u0026gt; Double.compare(o2,o1)).distinct().forEach(System.out::println); // 6、映射/加工方法，把流上的数据加工后，再次放回流里边去 scores.stream().map(s -\u0026gt;\u0026#34;加十分后:\u0026#34; + s+10).forEach(System.out::println); // 7、合并流 Stream\u0026lt;String\u0026gt; s1 = Stream.of(\u0026#34;张三丰\u0026#34;, \u0026#34;张无忌\u0026#34;, \u0026#34;张翠山\u0026#34;, \u0026#34;张良\u0026#34;, \u0026#34;张学友\u0026#34;); Stream\u0026lt;Integer\u0026gt; s2 = Stream.of(111, 22, 33, 44); Stream\u0026lt;Object\u0026gt; s3 = Stream.concat(s1, s2); s3.forEach(System.out::println); // 流没有重写toString方法java.util.stream.ReferencePipeline$Head@77459877 System.out.println(s3); } Stream上的终结方法 收集Stream流：就是把Stream流操作后的结果转回到集合或者数组中去返回。\nStream流：方便操作集合/数组的手段； 集合/数组：才是开发中的目的。\n流只能收集一次\npublic static void main(String[] args) { // 目标：掌握Stream流的统计，收集操作（终结方法） List\u0026lt;Teacher\u0026gt; teachers = new ArrayList\u0026lt;\u0026gt;(); teachers.add(new Teacher(\u0026#34;张三\u0026#34;, 23, 5000)); teachers.add(new Teacher(\u0026#34;金毛狮王\u0026#34;, 54, 16000)); teachers.add(new Teacher(\u0026#34;李四\u0026#34;, 24, 6000)); teachers.add(new Teacher(\u0026#34;王五\u0026#34;, 25, 7000)); teachers.add(new Teacher(\u0026#34;白眉鹰王\u0026#34;, 66, 108000)); teachers.add(new Teacher(\u0026#34;陈昆\u0026#34;, 42, 48000)); teachers.stream().filter(t -\u0026gt; t.getSalary() \u0026gt; 15000).forEach(System.out::println); System.out.println(\u0026#34;--------------------------------------------------\u0026#34;); long count = teachers.stream().filter(t -\u0026gt; t.getSalary() \u0026gt; 15000).count(); System.out.println(count); System.out.println(\u0026#34;--------------------------------------------------\u0026#34;); // 获取薪水最高的老师对象 Optional\u0026lt;Teacher\u0026gt; max = teachers.stream().max((t1, t2) -\u0026gt; Double.compare(t1.getSalary(), t2.getSalary())); Teacher maxTeacher = max.get(); // 获取Optional对象中的元素 System.out.println(maxTeacher); Optional\u0026lt;Teacher\u0026gt; min = teachers.stream().min((t1, t2) -\u0026gt; Double.compare(t1.getSalary(), t2.getSalary())); Teacher minTeacher = min.get(); // 获取Optional对象中的元素 System.out.println(minTeacher); System.out.println(\u0026#34;---------------------------------------------------------\u0026#34;); List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;张无忌\u0026#34;); list.add(\u0026#34;周芷若\u0026#34;); list.add(\u0026#34;赵敏\u0026#34;); list.add(\u0026#34;张强\u0026#34;); list.add(\u0026#34;张三丰\u0026#34;); list.add(\u0026#34;张三丰\u0026#34;); list.add(\u0026#34;张翠山\u0026#34;); // 流只能收集一次 // 收集到集合或者数组中去。 Stream\u0026lt;String\u0026gt; s1 = list.stream().filter(s -\u0026gt; s.startsWith(\u0026#34;张\u0026#34;)); // 收集到List集合 List\u0026lt;String\u0026gt; list1 = s1.collect(Collectors.toList()); System.out.println(list1); // Set\u0026lt;String\u0026gt; set2 = new HashSet\u0026lt;\u0026gt;(); // set2.addAll(list1); // 收集到Set集合 Stream\u0026lt;String\u0026gt; s2 = list.stream().filter(s -\u0026gt; s.startsWith(\u0026#34;张\u0026#34;)); Set\u0026lt;String\u0026gt; set = s2.collect(Collectors.toSet()); System.out.println(set); // 收集到数组中去 Stream\u0026lt;String\u0026gt; s3 = list.stream().filter(s -\u0026gt; s.startsWith(\u0026#34;张\u0026#34;)); Object[] array = s3.toArray(); System.out.println(\u0026#34;数组：\u0026#34; + Arrays.toString(array)); System.out.println(\u0026#34;------------------收集到Map集合---------------------------\u0026#34;); // 收集到Map集合：键是老师名称，值是老师薪水 Map\u0026lt;String, Double\u0026gt; map = teachers.stream().collect(Collectors.toMap(Teacher::getName, Teacher::getSalary)); System.out.println(map); } 方法中的可变参数 就是一种特殊形参，定义在方法、构造器的形参列表里，格式是：数据类型⋯参数名称；\n可变参数的特点和好处 特点：可以不传数据给它；可以传一个或者同时传多个数据给它；也可以传一个数组给它。\n好处：常常用来灵活的接收数据。\n可变参数对内其实就是一个数组\n可变参数在形参列表中只能有一个，可变参数必须放在形参列表的最后面\npublic static void main(String[] args) { // 认识方法中的可变参数 show(); show(1,2,3); show(new int[]{1,2,3,4,4}); } public static void show(int... args){ // 内部怎么拿数据： // 可变参数对内实际上就是一个数组。nums就是数组 System.out.println(args.length); System.out.println(Arrays.toString(args)); System.out.println(\u0026#34;------------------------------------------------\u0026#34;); } Collections工具类 1、给集合批量加数据\n2、打乱顺序\npublic static void main(String[] args) { // 目标：Colllections工具类 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); // list.add(\u0026#34;张无忌\u0026#34;); // list.add(\u0026#34;周芷若\u0026#34;); // list.add(\u0026#34;赵敏\u0026#34;); // list.add(\u0026#34;张强\u0026#34;); // list.add(\u0026#34;张三丰\u0026#34;); // list.add(\u0026#34;张翠山\u0026#34;); // 1、Collections的方法批量加 Collections.addAll(list,\u0026#34;张无忌\u0026#34;,\u0026#34;周芷若\u0026#34;,\u0026#34;赵敏\u0026#34;,\u0026#34;张强\u0026#34;,\u0026#34;张三丰\u0026#34;,\u0026#34;张翠山\u0026#34;); System.out.println(list); // 2、打乱顺序 Collections.shuffle(list); System.out.println(list); }\t","permalink":"https://wqnm1gb.github.io/posts/day12-mapstream%E6%B5%81/","summary":"\u003ch3 id=\"set系列集合添加的元素是无序不重复无索引\"\u003eSet系列集合：添加的元素是\u003c!-- raw HTML omitted --\u003e无序、不重复、无索引\u003c!-- raw HTML omitted --\u003e\u003c/h3\u003e\n\u003cp\u003eHashSet： \u003c!-- raw HTML omitted --\u003e无序\u003c!-- raw HTML omitted --\u003e、不重复、无索引\u003c/p\u003e\n\u003cp\u003eLinkedHashSet： \u003c!-- raw HTML omitted --\u003e有序\u003c!-- raw HTML omitted --\u003e、不重复、无索引\u003c/p\u003e","title":"Day12 Map、Stream流"},{"content":"异常 Error Error 代表的系统级别错误（属于严重问题），也就是说系统一旦出现问题，sun公司会把这些问题封装成Error对象给出来（说白了，Error是给sun公司自己用的，不是给我们程序员用的，因此我们开发人员不用管它）\nException 运行时异常 编译阶段不报错，运行时报错，继承自RunTimeException，一旦错误出现，程序就会结束\nNullPointException空指针\n编译时异常 提醒程序员这里的程序很容易出错，需要小心\n使用try catch解决(可以解决编译时异常，也可以解决运行时异常），提醒会更加的强烈，同时处理完异常后，程序不会结束\n异常的基本处理 throws抛出异常 在方法上使用throws关键字，可以将方法内部出现的异常抛出去给调用者处理。\ntry catch捕获异常 直接捕获可能出现的异常\n异常的作用 1、用来定位bug的关键信息\n2、作为方法内部的一种特殊的返回值，以便通知上层调用者，方法执行的问题\n自定义异常 Java无法为这个世界上全部的问题都提供异常类来代表 如果企业自己的某种问题， 想通过异常来表示，以便用异常来管理该问题，那就需要自己来定义异常类了。\n建议使用运行时异常，这样提醒没有那么强烈\n自定义运行时异常 定义一个异常类继承RuntimeException\n重写构造器\n通过throw new 异常类（xxx）来创建异常对象并拋出\n特点：编译阶段不报错，运行时才可能出现！提醒不属于激进型\n自定义编译时异常 定义一个异常类继承Exception\n重写构造器\n通过throw new 异常类（xxxx）创建异常对象并抛出\n特点：编译阶段就报错，提醒比较激进\n异常的处理方案 command option t 快捷生成try catch\n方案1 底层异常层层往上抛出，最外层捕获异常，记录下异常信息，并响应适合用户观看的信息进行提示\n有多个异常的时候，直接抛Exception，这样不用多个异常写多个异常的种类\n然后catch的时候，也就catch Exception类就行了\n方案2 最外层捕获异常后，尝试重新修复\n泛型 定义类、接口、方法时，同时声明了一个或者多个类型变量（如：）\n称为泛型类、泛型接口，泛型方法、它们统称为泛型。\npublic class ArrayList\u0026lt;E\u0026gt;{ } 作用：泛型提供了在编译阶段约束所能操作的数据类型，并自动进行检查的能力！\n泛型的本质：把具体的数据类型作为参数传给类型变量\n泛型类 修饰符 class类名\u0026lt;类型变量，类型变量，…\u0026gt;｛ ｝ 注意：类型变量建议用大写的英文字母，常用的有：E、T、K、V等\n泛型接口 修饰符 interface 接口名\u0026lt;类型变量，类型变量，...\u0026gt; ｝ 泛型方法，通配符，上下限 泛型方法 修饰符\u0026lt;类型变量，类型变量，…＞返回值类型 方法名（形参列表）｛ ｝ // 泛型方法声明都有一个类型参数声明部分（由尖括号分隔） public static \u0026lt;T\u0026gt; void test（T t）｛ ｝ 通配符 就是“？”，可以在“使用泛型”的时候代表一切类型；ET KV 是在定义泛型的时候使用。\n泛型的上下限 • 泛型上限：？extends Car：？能接收的必须是Car或者其子类。\n• 泛型下限：？super Car：？能接收的必须是Car或者其父类。\n泛型支持的类型 泛型不支持基本数据类型，只能支持对象类型（引用数据类型）\n泛型擦除：泛型工作在编译阶段，等编译后泛型就没用了，所以泛型在编译后都会被擦除。所有类型会恢复成Object类型，Object一定要指向一个对象\n包装类 包装类就是把基本类型的数据包装成对象的类型\nInteger把-128-127先缓存起来了\nInteger it1 = Integer.valueof(100); Integer it3 = 100;//和第一句一样的，自动装箱，变成对象 Integer it2 = Integer.valueof(100); System.out.println(it1==it2);//true 自动装箱：基本数据类型可以自动转换为包装类型。\n自动拆箱：包装类型可以自动转换为基本数据类型。\n包装类的其他功能 可以把基本类型的数据转换成字符串类型。\npublic static String toString(double d) public String toString() //功能比较鸡肋，一般转成字符串会用 String s1 = 123 + \u0026#34;\u0026#34;; 可以把字符串类型的数值转换成数值本身对应的真实数据类型（这个重要）\npublic static int parselnt(String s) public static Integer valueOf(String s) 集合框架 集合是一种容器，用来装数据的，类似于数组，但集合的大小可变，开发中也非常常用\n集合体系结构 集合的结构分成了两类\nCollection-单列集合 每个元素（数据）只包含一个值\n常用功能\n方法名 说明 public boolean add(E e) 把给定的对象添加到当前集合中 public void clear() 清空集合中所有的元素 public boolean remove(E e) 把给定的对象在当前集合中删除 public boolean contains(Object obj) 判断当前集合中是否包含给定的对象 public boolean isEmpty() 判断当前集合是否为空 public int size() 返回集合中元素的个数。 public Object[] toArray() 把集合中的元素，存储到数组中，默认转换成Object数组 Collection的遍历方式1：迭代器遍历\nnext() 函数默认是在第一个元素的位置，先取值在去到下一个元素位置\nhasnext() 函数是判断当前位置是否有元素\n获取迭代器\n方法名称 说明 Iterator iterator() 返回集合中的迭代器对象，该迭代器对象默认指向当前集合的第一个元素 迭代器中常用的方法\n方法名称 说明 boolean hasNext() 询问当前位置是否有元素存在，存在返回true ,不存在返回false E next() 获取当前位置的元素，并同时将迭代器对象指向下一个元素处。 Collection的遍历方式2：增强for循环\nfor (元素的数据类型 变量名 : 数组或者集合) { } 增强for可以用来遍历集合或者数组\n增强for遍历集合，本质就是迭代器遍历集合的简化写法\n快捷方式 数组/集合名.for\n底层就是基于迭代器\nCollection的遍历方式3：Lambda表达式\n要使用如下方法来完成\n方法名称 说明 default void forEach(Consumer\u0026lt;? super T\u0026gt; action) 结合lambda遍历集合 public static void main(String[] args) { //遍历方式3：使用Lambda表达式 ArrayList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;张三\u0026#34;); list.add(\u0026#34;李四\u0026#34;); list.add(\u0026#34;王五\u0026#34;); list.add(\u0026#34;赵6\u0026#34;); list.forEach(s -\u0026gt; System.out.println(s)); list.forEach(System.out::println); } 三种遍历的区别 认识并发修改异常问题\n遍历集合的同时又存在增删集合元素的行为时可能出现业务异常，这种现象被称之为并发修改异常问题。\nfor循环删除元素没删干净的本质原因是：删除一个元素后，后边一个元素立马补上来，导致了漏删\n解决方案1：删除元素后做一步i\u0026ndash;\n解决方案2：倒着遍历删除（前提是支持索引），原因是后边的元素补过来都是判断后不用删的，而顺着遍历前边的元素补上来不知道是否要删除\n1、迭代器遍历并删除存在并发修改异常问题，解决方案：使用迭代器自己的删除方法\n2、增强for和lambda都没办法解决并发修改异常问题，他们只适合做遍历，不适合做增删\n如果知道索引可以使用i\u0026ndash;的方式解决，如果不知道索引，就用迭代器的删除功能\nList系列集合：添加的元素是有序、可重复、有索引 List集合因为支持索引，所以多了很多与索引相关的方法，当然，Collection的功能List也都继承了。\n方法名称 说明 void add(int index,E element) 在此集合中的指定位置插入指定的元素 E remove(int index) 删除指定索引处的元素，返回被删除的元素 E set(int index,E element) 修改指定索引处的元素，返回被修改的元素 E get(int index) 返回指定索引处的元素 ArrayList、LinekdList：有序、可重复、有索引\nArrayList底层是基于数组存储数据的 数组的特点\n查询速度快（注意：是根据索引查询数据快）：查询数据通过地址值和索引定位，查询任意数据耗时相同。\n增删数据效率低：可能需要把后面很多的数据进行前移。\n第一次创建的时候是创建一个空数组，第一次添加的时候才扩容为初始大小为10的数组，二次添加后，会添加成之前的1.5倍\nLinkedList底层是基于链表存储数据的 链表的特点\n链表中的数据是一个一个独立的结点组成的，结点在内存中是不连续的，每个结点包含数据值和下一个结点的地址。是基于双链表实现的，特点：对首尾元素进行增删改查的速度是极快的，占用的内存更多\nLinkedList新增了：很多首尾操作的特有方法。\n链表的特点1：查询慢，无论查询哪个数据都要从头开始找。\n链表的特点2：链表增删相对快\n只需要一个的对象可以用static修饰\nSet系列集合：添加的元素是无序、不重复、无索引 HashSet： 无序、不重复、无索引\nLinkedHashSet： 有序、不重复、无索引\nTreeSet：按照大小默认升序排序、不重复、无索引\nMap-双列集合 每个元素包含两个值（键值对）\n","permalink":"https://wqnm1gb.github.io/posts/day11-%E5%BC%82%E5%B8%B8%E6%B3%9B%E5%9E%8B%E5%92%8C%E9%9B%86%E5%90%88/","summary":"\u003ch2 id=\"异常\"\u003e异常\u003c/h2\u003e\n\u003ch3 id=\"error\"\u003eError\u003c/h3\u003e\n\u003cp\u003eError 代表的系统级别错误（属于严重问题），也就是说系统一旦出现问题，sun公司会把这些问题封装成Error对象给出来（说白了，Error是给sun公司自己用的，不是给我们程序员用的，因此我们开发人员不用管它）\u003c/p\u003e","title":"Day11 异常、泛型和集合"},{"content":"ArrayList集合 数组定义完成并且启动后，长度就固定了\n集合大小可变，功能丰富，开发中用的更多\n要用泛型定义集合\n构造器 说明 public ArrayList() 创建一个空的集合对象 常用方法名 说明 public boolean add(E e) 将指定的元素添加到此集合的末尾 public void add(intindex,E element) 在此集合中的指定位置插入指定的元素 public E get(int index) 返回指定索引处的元素 public int size() 返回集合中的元素的个数 public E remove(int index) 删除指定索引处的元素，返回被删除的元素 public boolean remove(Object o) 删除指定的元素，返回删除是否成功 public E set(intindex,E element) 修改指定索引处的元素，返回被修改的元素 ","permalink":"https://wqnm1gb.github.io/posts/day10-arraylist%E9%9B%86%E5%90%88/","summary":"\u003ch2 id=\"arraylist集合\"\u003eArrayList集合\u003c/h2\u003e\n\u003cp\u003e数组定义完成并且启动后，长度就固定了\u003c/p\u003e\n\u003cp\u003e集合大小可变，功能丰富，开发中用的更多\u003c/p\u003e\n\u003cp\u003e要用泛型定义集合\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e\u003c!-- raw HTML omitted --\u003e构造器\u003c!-- raw HTML omitted --\u003e\u003c/th\u003e\n          \u003cth\u003e\u003c!-- raw HTML omitted --\u003e说明\u003c!-- raw HTML omitted --\u003e\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003epublic \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eArrayList\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e()\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003e创建一个空的集合对象\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e\u003c!-- raw HTML omitted --\u003e常用方法名\u003c!-- raw HTML omitted --\u003e\u003c/th\u003e\n          \u003cth\u003e\u003c!-- raw HTML omitted --\u003e说明\u003c!-- raw HTML omitted --\u003e\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003epublic \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eboolean\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e add(E e)\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003e将指定的元素添加到此集合的末尾\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003epublic void add(\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eint\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eindex,E\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e element)\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003e在此集合中的指定位置插入指定的元素\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003epublic E get(\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eint\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e index)\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003e返回指定索引处的元素\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003epublic \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eint\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e size()\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003e返回集合中的元素的个数\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003epublic E remove(\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eint\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e index)\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003e删除指定索引处的元素，返回被删除的元素\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003epublic \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eboolean\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e remove(Object o)\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003e删除指定的元素，返回删除是否成功\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003epublic E set(\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eint\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eindex,E\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e element)\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003e修改指定索引处的元素，返回被修改的元素\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e","title":"Day10 ArrayList集合"},{"content":"函数式编程 此“函数”类似于数学中的函数（强调做什么），只要输入的数据一致返回的结果也是一致的\n可以用于替代某些匿名内部类对象，从而让程序更简洁，可读性更好。\n(被重写方法的形参列表) -\u0026gt;{ 被重写方法的方法体代码 } 注意：Lambda表达式只能替代函数式接口的匿名内部类！！！\n什么是函数式接口：只有一个抽象方法的接口\n@FunctionInterface 专门用来声明函数式接口\nLambda表达式的省略规则 • 作用：用于进一步简化Lambda表达式的写法。\n具体规则\n1、参数类型全部可以省略不写。\n2、如果只有一个参数，参数类型省略的同时“（）”也可以省略，但多个参数不能省略（）”\n3、如果Lambda表达式中只有一行代码，大括号可以不写，同时要省略分号“；”如果这行代码是return\n语句，也必须去掉return。\n方法引用 静态方法引用 类名::静态方法\n使用场景\n如果某个Lambda表达式里只是调用一个静态方法，并且“-\u0026gt;”前后参数的形式一致，就可以使用静态方法引用。\nArrays.sort(students,Student::compare); 实例方法引用 对象名::实例方法。\n使用场景\n如果某个Lambda表达式里只是通过对象名称调用一个实例方法，并且“-\u0026gt;”前后参数的形式一致，就可以\n使用实例方法引用。\n特定类的方法引用 特定类的名称：方法\n使用场景\n如果某个Lambda表达式里只是调用一个特定类型的实例方法，并且前面参数列表中的第一个参数是作为方法的主调，后面的所有参数都是作为该实例方法的入参的，则此时就可以使用特定类型的方法引用。\n构造器引用 类名::new\n使用场景\n如果某个Lambda表达式里只是在创建对象，并且“-\u0026gt;”前后参数情况一致，就可以使用构造器引用。\nString类 String代表字符串，它的对象可以封装字符串数据，并提供了很多方法完成对字符串的处理。\n创建对线的区别\n只要是以\u0026quot;..\u0026ldquo;方式写出的字符串对象，会存储到字符串常量池，且相同内容的字符串只存储一份（节约内存）；\n通过new方式创建字符串对象，每new一次都会产生一个新的对象放在堆内存中。\n字符串对象的内容比较不要用==号，==号默认比较的是地址，字符串对象的内容一样时地址不一定一样\n建议使用String提供的equals方法，只关心内容，不关心地址\nsc.next()用来接收字符串对象\nString创建字符串对象的方式 构造器 说明 public String() 创建一个空白字符串对象，不含有任何内容 public String(String original) 根据传入的字符串内容，来创建字符串对象 public String(char[] chars) 根据字符数组的内容，来创建字符串对象 public String(byte[] bytes) 根据字节数组的内容，来创建字符串对象 String提供的常用方法 方法名 说明 public int length() 获取字符串的长度返回（就是字符个数） public char charAt(int index) 获取某个索引位置处的字符返回 public char[] toCharArray()： 将当前字符串转换成字符数组返回 public boolean equals(Object anObject) 判断当前字符串与另一个字符串的内容一样，一样返回true public booleanequalsIgnoreCase(String anotherString) 判断当前字符串与另一个字符串的内容是否一样(忽略大小写) public String substring(int beginIndex, int endIndex) 根据开始和结束索引进行截取，得到新的字符串（包前不包后，索引从0开始） public String substring(int beginIndex) 从传入的索引处截取，截取到末尾，得到新的字符串返回 public String replace(CharSequence target, CharSequence replacement) 使用新值，将字符串中的旧值替换，得到新的字符串 public boolean contains(CharSequence s) 判断字符串中是否包含了某个字符串 public booleanstartsWith(String prefix) 判断字符串是否以某个字符串内容开头，开头返回true，反之 public String[] split(String regex) 把字符串按照某个字符串内容分割，并返回字符串数组回来 ","permalink":"https://wqnm1gb.github.io/posts/day09-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E5%92%8Cstring%E7%B1%BB/","summary":"\u003ch2 id=\"函数式编程\"\u003e函数式编程\u003c/h2\u003e\n\u003cp\u003e此“函数”类似于数学中的函数（强调做什么），只要输入的数据一致返回的结果也是一致的\u003c/p\u003e\n\u003cp\u003e可以用于替代某些匿名内部类对象，从而让程序更简洁，可读性更好。\u003c/p\u003e","title":"Day09 函数式编程、方法引用和String类"},{"content":"接口 Java提供了一个关键字interface定义出接口\nJDK8之前，接口只能定义常量和抽象方法\n接口中定义常量，可以省略public static final不写，默认会加上去\n接口中定义方法，可以省略public abstract不写，默认会加上去\n注意：接口不能创建对象\n接口是用采被类实现（implements）的，买现接口的类称为买现类， 一个类可以同时实现**多个**接口（多实现）。\n实现类实现了多个接口，必须重写完全部接口的全部抽象方法，否则这个类要定义为抽象类\n接口的好处 弥补了类单继承的不足，一个类同时可以实现多个接口，使类的角色更多，功能更强大。\n让程序可以面向接口编程，这样程序员就可以灵活方便的切换各种业务实现（更利于程序的解耦合）\nJDK8开始接口新增了3种方法\n1、默认方法（普通实例方法）：必须加default修饰，默认会用public修饰。\n2、私有方法（JDK 9开始才支持的）私有的实例方法。如何调用？使用接口中的其他实例方法来调用它（间接调用）\n3、静态方法默认会用public修饰。如何调用？只能使用当前接口名来调用。\n类必须extend在前，implement在后\n接口的注意事项 1、接口与接口可以多继承：一个接口可以同时继承多个接口［重点］。\n类与类：单继承 一个类只能继承一个直接父类\n类与接口：多实现，一个类可以同时实现多个接口。\n接口与接口：多继承，一个接口可以同时继承多个接口（用的是extends关键字）。\n2、一个接口继承多个接口，如果多个接口中存在方法签名冲突，则此时不支持多继承，也不支持多实现。\n4、一个类继承了父类，又同时实现了接口，如果父类中和接口中有同名的方法，实现类会优先用父类的。\n5、一个类实现了多个接口，如果多个接口中存在同名的默认方法，可以不冲突，这个类重写该方法即可。\n接口和抽象类的对比 相同点：\n1、都是抽象形式，都可以有抽象方法，都**不能创建对象****。**\n2、都是派生子类形式，抽象类是被子类继承使用，接口是被实现类实现。\n3、一个类继承抽象类，或者实现接口，都必须重写完他们的抽象方法，否则自己要成为抽象类或者报错！\n4、都能支持的多态，都能够实现解耦合。\n不同点：\n1、抽象类中可以定义类的**全部普通成员****，接口只能定义常量，抽象方法（JDK8新增的三种方式）**\n2、抽象类只能被类**单继承，接口可以被类多实现****。**\n3、一个类继承抽象类就不能再继承其他类，一个类实现了接口还可以继承其他类或者实现其他接口。\n4、抽象类体现**模板思想****：更利于做父类，实现代码的复用性。最佳实践**\n5、接口更适合**做功能的解耦合****：解耦合性更强更灵活。 最佳实践**\n代码块 代码块是类的5大成分之一（成员变量、构造器、方法、代码块、内部类）\n静态代码块 格式：static{}\n特点：类加载时自动执行，由于类只会加载一次，所以静态代码块也只会执行一次。\n作用：完成类的初始化，例如：对静态变量的初始化赋值。\n比如说给静态数组赋值\nArrarys.toString(数组名) //返回数组的内容\n实例代码块： 格式：{}\n特点：属于对象，每次创建对象时，执行实例代码块，并在构造器前执行。\n作用：和构造器一样，都是用来完成对象的初始化的例如：对实例变量进行初始化赋值。\n内部类 如果一个类定义在另一个类的内部，这个类就是内部类。\n场景：当一个类的内部，包含了一个完整的事物，且这个事物没有必要单独设计时，就可以把这个事物设计成内部类。\n成员内部类 就是类中的一个普通成员，类似前面我们学过的普通的成员变量、成员方法。\n成员内部类：无stati修饰，属于外部类的对象持有的。\n外部类名.内部类名 对象名=new 外部类(\u0026hellip;).new 内部类(..)；\n成员内部类中访问其他成员的特点：\n1、成员内部类种可以直接访问外部类的实例成员、静态成员。\n2、成员内部类的实例方法中，可以直接拿到当前外部类对象，格式是：外部类名.this。\nclass OuterClass { private String outerField = \u0026#34;Outer Field\u0026#34;; class InnerClass { private String innerField = \u0026#34;Inner Field\u0026#34;; public void display() { // 访问内部类的成员 System.out.println(innerField); // 访问外部类的成员 外部类名.this System.out.println(OuterClass.this.outerField); } } } public class Test { public static void main(String[] args) { OuterClass outer = new OuterClass(); OuterClass.InnerClass inner = outer.new InnerClass(); inner.display(); } } 静态内部类 有static修饰的内部类，属于外部类自己持有。\n外部类名.内部类名 对象名=new 外部类.内部类(..)；\nOuter.Inner in = new Outer.Inner() ；\n可以直接访问外部类的静态成员，不能直接访问外部类的实例成员。\n匿名内部类 是一种特殊的局部内部类；\n所谓匿名：指的是程序员不需要为这个类声明名字，默认有个隐藏的名字。\n特点：匿名内部类本质就是一个子类，并会立即创建出一个子类对象。\n作用：用于更方便的创建一个子类对象。\n匿名内部类实际上是有名字：外部类名$编号.class\n匿名内部类在开发中的常见形式\n通常作为一个对象参数传输给方法。\n需求：学生，老师要参加游泳比赛。\n开发中不是我们要主动去写匿名内部类，而是用别人的功能的时候，别人可以让我们写一个匿名内部类吗，我们才会写！\npublic static void sort(T[] a, Comparator\u0026lt;T\u0026gt; c) 参数一：需要排序的数组 参数二： 需要给sort声明一个Comparator比较器对象（指定排序的规则） sort方法会调用匿名内部类对象的compare 方法 对数组中的学生对象进行两两比较从而实现排序 指定排序规则： 如果你认为左边对象 大于 右边对象 那么返回正整数。 如果你认为左边对象 小于 右边对象 那么返回负整数。 如果两边相等那么返回0。 // 调用排序的函数，用匿名内部类的方式实现 Arrays.sort(students, new Comparator\u0026lt;Student\u0026gt;() { @Override public int compare(Student o1, Student o2) { //规则是左边大于右边，返回正整数 // 左边小于右边，返回负整数 // 左边等于右边，返回0 // if(o1.getHight()\u0026gt;o2.getHight()){ // return 1; // }else if(o1.getHight()\u0026lt;o2.getHight()){ // return -1; // }else { // return 0; // } return (int) (o2.getHight()-o1.getHight()); } }); ","permalink":"https://wqnm1gb.github.io/posts/day08-%E6%8E%A5%E5%8F%A3%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/","summary":"\u003ch2 id=\"接口\"\u003e接口\u003c/h2\u003e\n\u003cp\u003eJava提供了一个关键字interface定义出接口\u003c/p\u003e\n\u003cp\u003eJDK8之前，接口只能定义常量和抽象方法\u003c/p\u003e\n\u003cp\u003e接口中定义常量，可以省略public static final不写，默认会加上去\u003c/p\u003e","title":"Day08 接口和面向对象编程"},{"content":"多态 有对象多态，行为多态\n编译看左，运行看右\n多态的前提 有继承/实现关系，存在父类引用子类对象，存在方法重写\n使用多态的好处 1、在多态形态下，右边对象是解耦合的，便于扩展和维护\n2、定义方法的时候，使用父类类型的形参，可以接收一切子类对象，扩展性更强，更便利\n多态产生的问题 不能调用子类独有的行为\n多态下的类型转换 可以解决多态下调用独有功能\n自动类型转换：父类 变量名 = new 子类();\nPeople p = new Teacher();\n强制类型转换：子类 变量名 = (子类)父类变量;\nTeacher t = (Teacher) p;\n注意事项 1、存在继承/实现关系就可以在编译阶段进行强制类型转换，编译阶段不会报错。\n2、运行时，如果发现对象的真实类型与强转后的类型**不同****，就会报类型转换异常（ClassCastException）的错误出来。**\n强制转换前，Java建议先判断对象的真实类型\np instanceof Student 会返回TRUE或FALSE\nfinal关键字 1、修饰类：该类称为最终类，不能再被继承（工具类）\n2、修饰方法：该方法称为最终方法，特点是不能被重写（下边的模板方法的设计模式）\n3、修饰变量：该变量有且仅能被赋值一次，第二次赋值会报错\n变量的类型\na.成员变量：\n静态成员变量\n实例成员变量\nb.局部变量\n使用final修饰后\na.成员变量：\n静态成员变量：这个变量今后被称为常量，可以记住一个固定值，并且在程序中不能修改了，通常这个值作为系统的配置信息（常量的名称建议全部大写，多个单词用下划线分隔）\n实例成员变量：一般没有意义\nb.局部变量\n注意事项\nfinal修饰**基本类型**的变量，变量存储的数据不能被改变。\nfinal修饰**引用类型的变量，变量存储的地址不能被改变，但地址所指向对象的内容是**可以被改变的。\nstatic和final的区别 final修饰的变量是不能再修改的\nstatic修饰的变量只强调加载一份，可以再修改\n常量 使用了 static final 修饰的成员变量就被称为常量.\n作用：常用于记录系统的配置信息。\n使用常量：代码可读性更好，可维护性也更好。\n程序编译后，常量会被“宏替换”：出现常量的地方全部会被替换成其记住的字面量，这样可以保证使用常量和直接用字面量的**性能是一样的****。（编译后的文件是.class文件，去out文件夹里边找）**\n单例类（设计模式） 什么是设计模式\n一个问题通常有n种解法，其中肯定有一种解法是最优的，这个最优的解法被人总结出来了，称之为设计模式。\n怎么学设计模式\n1、解决了什么问题 2、怎么写\n单例模式\n作用：确保某个类只能创建一个对象\n实现步骤\n1、把类的构造器私有化（确保单例类在外边不能创建太多的对象，单例才有了可能性）\n2、定义一个类变量记住类的一个对象\n3、定义一个类方法，返回对象\n饿汉式单例：用对象时，对象已经创建好了\n懒汉式单例：用对象时，才开始创建对象\n枚举类 枚举类是一种特殊的类\n枚举类的写法\n修饰符 enum 枚举类名{ 名称1,名称2,名称3; 其他成员... } 1、枚举都是**最终类****，不可以被继承，枚举类都是继承java.lang.Enum类的。**\n2、枚举类的第一行只能罗列一些名称，这些名称都是常量，并且每个常量会记住枚举类的一个对象。\n**3、枚举类的构造器都是私有的（写不写都只能是私有的），因此，枚举类对外不能创建对象。所以枚举类是多例模式 **\n4、编译器为枚举类新增了几个方法。\n枚举适合做信息的标志和分类\n抽象类 在Java中有一个关键字叫：abstract，它就是抽象的意思，可以用它修饰类、成员方法。\nabstract修饰类，这个类就是抽象类。\nabstract修饰方法，这个方法就是抽象方法（只能有方法签名，不能有方法体）\n抽象类的特点：\n1、抽象类中不一定要有抽象方法，有抽象方法的类必须是抽象类。\n2、类有的成员：成员变量、方法、构造器，抽象类都可以有。\n3、****抽象类最主要的特点：抽象类不能创建对象，仅作为一种特殊的父类，让子类继承并实现。\n抽象类的使命就是被继承\n4、一个类继承抽象类，必须重写完抽象类的全部抽象方法，否则这个类也必须定义成抽象类。\n**抽象方法不能使用private修饰 **\n抽象类的好处 父类知道每个子类都要做某个行为，但每个子类要做的情况不一样，父类就定义成抽象方法，交给子类去重写实现， 我们设计这样的抽象类，就是为了更好的支持多态（原因是如果不用抽象类定义方法，那么会多写无用的代码，如果不写，会无法实现多态）。\n模板方法设计模式 提供一个方法作为完成某类功能的模板，模板方法封装了每个实现步骤，但允许子类提供特定步骤的实现。\n模板方法设计模式可以：提高代码的复用、并简化子类设计。\n写法\n1、定义一个抽象类。\n2、在里面定义2个方法\n3、一个是模板方法：把共同的实现步骤放里面去。\n4、一个是抽象方法：不确定的实现步骤，交给具体的子类来完成。\n建议使用final关键字修饰模板方法，为什么？\n模板方法是给子类直接使用的，不能被子类重写。一旦子类重写了模板方法，模板方法就失效了。\n","permalink":"https://wqnm1gb.github.io/posts/day07-%E5%A4%9A%E6%80%81%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/","summary":"\u003ch2 id=\"多态\"\u003e多态\u003c/h2\u003e\n\u003cp\u003e有对象多态，行为多态\u003c/p\u003e\n\u003cp\u003e\u003c!-- raw HTML omitted --\u003e编译看左，运行看右\u003c!-- raw HTML omitted --\u003e\u003c/p\u003e\n\u003ch3 id=\"多态的前提\"\u003e多态的前提\u003c/h3\u003e\n\u003cp\u003e有\u003c!-- raw HTML omitted --\u003e继承/实现\u003c!-- raw HTML omitted --\u003e关系，存在父类引用子类对象，存在\u003c!-- raw HTML omitted --\u003e方法重写\u003c!-- raw HTML omitted --\u003e\u003c/p\u003e","title":"Day07 多态和面向对象编程"},{"content":" 不仅会退出循环，还会结束整个方法的执行\n比如说匹配id的时候，找到id就直接退出方法，没找到id的话在循环语句后边还会有一个没找到id的提示\n子类能继承父类的非私有成员（成员变量，成员方法）如果定义的变量是私有的，那么能继承公有的get，set方法\n子类对象是由子类和父类多张设计图共同创建出来的对象，所以子类对象是完整的\nprivate 只能本类 缺省 本类，同一个包中的类 protected 本类，同一个包中的类，子孙类中 public 任意位置 private\u0026lt;缺省\u0026lt;protected\u0026lt;public\n**java为什么不支持多继承 **\njava中的祖宗类object\njava中的所有类，要么直接继承object，要么默认继承object，要么间接继承object\n如果子类中，出现了重名的成员，会优先使用子类的，如果此时一定要使用父类的，需要加上super关键字\nJava的多个类中有且仅有一个可以用public修饰\n重写的时候会加上 @Override 在上边，这是方法重写的校验注解（标志），要求方法名称和形参列表必须与被重写的方法一致，否则报错\n优点：更安全，更易读\n注意事项\n1、子类方法重写时候，访问权限一定要大于等于父类方法的权限（public\u0026gt;protected\u0026gt;缺省）\n2、重写方法的返回值类型，必须与父类的返回值类型一样或者范围更小\n3、私有方法，静态方法不能被重写，如果重写会报错（原因是子类只能继承非私有的成员，所以不能重写）\n直接输出对象，会调用对象的toString()方法，返回对象的地址信息\n具体是调用父类的有参还是无参由自己决定，如果不管，默认调用无参，如果没有无参，需要自己写一个有参\n如何实现调用父类的构造器的？\n默认情况下，子类构造器的第一行都是super();（写不写都有），会调用父类的无参构造器\n如果父类没有无参构造器，则子类构造器的第一行必须手写一个super()，去指定调用父类的有参构造器\nthis调用本类中的兄弟构造器\nthis的作用是，在构造器中调用本类的其他构造器\n注意，super()和this()必须写在构造器的第一行，而且两者不能同时出现\npublic class Person { private String name; private int age; // 第一个构造器 public Person(String name) { this(name, 20); // 调用第二个构造器 } // 第二个构造器 public Person(String name, int age) { this.name = name; this.age = age; } // 其他方法 public void display() { System.out.println(\u0026#34;Name: \u0026#34; + name + \u0026#34;, Age: \u0026#34; + age); } public static void main(String[] args) { Person p1 = new Person(\u0026#34;Alice\u0026#34;); p1.display(); // 输出: Name: Alice, Age: 20 Person p2 = new Person(\u0026#34;Bob\u0026#34;, 30); p2.display(); // 输出: Name: Bob, Age: 30 } } ","permalink":"https://wqnm1gb.github.io/posts/day06-%E7%BB%A7%E6%89%BF/","summary":"\u003c!-- raw HTML omitted --\u003e\n\u003cp\u003e不仅会退出循环，还会\u003c!-- raw HTML omitted --\u003e结束整个方法的执行\u003c!-- raw HTML omitted --\u003e\u003c/p\u003e\n\u003cp\u003e比如说匹配id的时候，找到id就直接退出方法，没找到id的话在循环语句后边还会有一个没找到id的提示\u003c/p\u003e","title":"Day06 继承"},{"content":"","permalink":"https://wqnm1gb.github.io/posts/my-new-post/","summary":"","title":"My New Post"},{"content":"对象 对象是一种特殊的数据结构，可以用来记住一个事物的数据，从而代表该事物\n1、先设计一个对象的模板，也就是对象的设计图：类\n2、通过new关键字，每new一次就得到一个新的对象\n内存分成了栈内存，堆内存和方法区\n方法区存放类文件\nnew出来的东西叫做对象，会放在堆里边\n方法需要使用的时候，会被掉到栈内存中\n设计对象的关键就是设计类，对象的模板\n构造器 创建对象的时候，对象会自动的调用构造器\n常见应用场景\n构造器的作用： 创建对象时，同时完成对对象成员变量（属性）的初始化赋值、\n//构造器的语法 class Student{ public Student(){ //名字必须要和类名相同，可以带参数也可以不带参数，没有返回值 } } 构造器的注意事项 1、类默认就带了一个无参构造器\n2、如果类定义了有参构造器，类默认的无参构造器就没有了，此时如果还想用无参构造器，就要自己手写一个无参构造器\nthis关键字 this就是一个变量，可以用在方法中，来拿到当前对象（拿的对象地址）\n哪个对象调用这个方法，this就拿到哪个对象\n**this对象主要用来解决：****变量名称冲突**的问题\n成员变量与方法内部变量的名称一样的时候，导致的命名冲突的问题\n封装 面向对象的三大特征：封装，继承，多态\n类，方法就是一种封装\n封装的设计要求\n合理隐藏，合理暴露\n如何隐藏：使用private关键字进行修饰成员变量，就只能在本类中被直接访问，其他任何地方不能直接访问\n如何暴露： 使用public修饰的get和set方法合理暴露成员变量的取值和\nJavabean（实体类） 是一种特殊类，满足下列要求\n1、类中的成员变量全是私有的，并且提供public修饰的getter和setter方法\n2、需要提供一个无参数的构造器，有参数的可选\n实体类的基本作用：创建他的新对象，存取数据（封装数据）\n实体类的应用场景：\n实体类的对象只负责数据的存取，而不负责数据的处理，数据的处理交给其他类的对象来完成，已实现数据和业务处理相分离\nstatic关键字 static修饰变量 可以用来修饰成员变量和成员方法\n类在运行的时候只会被加载一次\n成员变量按照有无static修饰可以分成两种：\n1、静态变量（类变量）：有static修饰属于类，在计算机中只有一份，会被全部对象共享，以最后的改动为准\n2、实例变量（对象的变量）（实例就是对象，对象就是实例（实例化之后就会占用内存） ，类是比他们高一个等级的抽象概念（不占用内存））：无static修饰，属于每个对象的\n推荐访问静态变量的方式\n类名.静态变量（推荐）\n实例名.静态变量（不推荐）\n静态变量的应用场景\n**如果某个数据只需要一份，且希望能够被共享（访问、修改），则该数据可以定义成静态变量来记住 **\n同一个类中，访问静态成员，可以省略类名不写\nstatic修饰方法 静态方法：有static修饰的成员方法，属于类持有\n实例方法：无static修饰的成员方法，属于对象\n如果这个方法只是为了做一个功能并且不需要直接访问对象的数据，这个方法直接定义为静态方法\n如果这个方法是对象的行为，需要访问对象的数据，这个方法必须定义为实例方法\n常见应用场景：做工具类，工具类中的所有方法都是一些静态方法，每一个方法来完成一个功能\n使用工具类的好处：提高代码复用，调用方便，提高了开发效率，不会占用内存\n工具类没有必要创建对象，可以把构造器进行私有化\npublic class Tools{ private Tools(){ //别人无法创建这个类 } } public修饰和没有关键字修饰（只能用这两种修饰符来修饰类） public修饰符 类级别: 如果一个类被声明为 public，它可以被任何地方访问，无论是在同一个包内还是其他包中，只要导入了该类所在的包。\n方法/字段级别: 如果类的成员（方法或字段）被声明为 public，那么任何类都可以访问这些成员，无论它们位于哪个包。\n没有修饰符（Package-private） **类级别: **如果一个类没有使用任何修饰符（即默认情况下），它只能在同一个包内访问。其他包中的类无法访问这个类，即使它们导入了该包。\n方法/字段级别: 如果类中的方法或字段没有使用访问修饰符，它们只能在同一个包内访问，而不能被其他包中的类访问。\n静态方法，实例方法的注意事项 1、静态方法中可以**直接访问静态成员****， 不可以直接访问实例成员**\n2、实例方法中既可以直接访问静态成员，也可以直接访问实例成员\n3、实例方法中可以出现this关键字，静态方法中**不可以出现this关键字**\n","permalink":"https://wqnm1gb.github.io/posts/day05-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/","summary":"\u003ch2 id=\"对象\"\u003e对象\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e对象是一种特殊的数据结构，可以用来记住一个事物的数据，从而代表该事物\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e1、先设计一个对象的模板，也就是对象的设计图：类\u003c/p\u003e\n\u003cp\u003e2、通过new关键字，每new一次就得到一个新的对象\u003c/p\u003e","title":"Day05 面向对象编程"},{"content":" ","permalink":"https://wqnm1gb.github.io/posts/testpicture/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://cdn.nlark.com/yuque/0/2024/png/28219979/1728611073038-cdcb6289-b485-4060-9727-8c3732d22bfe.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/image.png\" alt=\"\"  /\u003e\n\u003c/p\u003e","title":"testPicture"},{"content":"无限循环 无限循环下边不能再写其他的代码了，因为执行不到了\n//for格式的无限循环 for(;;){ } //while格式的无限循环 while(true){ } continue和break continue：跳过本次循环，继续执行下次循环\nbreak：结束整个循环\nRandom类 使用步骤：\nimport java.util.Random; Random r = new Random(); int num = r.nextInt(随机数范围); int num = r.nextInt(100);//0~99内取值 //生成任意随机数的方法 //例如我要生成1~100的随机数 //先把左边的范围变成0，然后通过加法补上 //例如要生成1~100之间的随机数 import java.util.Random; Random r = new Random(); //首先生成0~99的数字，然后再+1，变成1~100 int num = r.nextInt(100)+1; 随机数的范围，包头不包尾，包左不包右\n0-100 包括0但是不包括100\n数组 数组：是一种容器，可以存储同种数据类型的多个值\n完整格式：数据类型[] 数组名 = new 数据类型[]{元素1,元素2,元素3\u0026hellip;};\nint[] array = new int[]{11,22,33} //简化格式 int[] arrary = {11,22,33}; array.length可以快速的获取数组的长度\n二维数组中的每一个数据都是一个一维数组\nfor-each循环 public class TestArray { public static void main(String[] args) { double[] myList = {1.9, 2.9, 3.4, 3.5}; // 打印所有数组元素 for (double element: myList) { System.out.println(element); } } } 数组的动态初始化和静态初始化 静态初始化：初始化的时候直接赋值\n动态初始化：初始化的时候只指定数组的长度，由系统为数组分配初始值\nint[] array = new int[3]; 数组默认初始化值的规律\n1、整数类型：默认初始化值是0\n2、小数类型：默认初始化值是0.0\n3、字符类型：默认初始化值是\u0026rsquo;/u0000\u0026rsquo; 显示出来是一个空格\n4、布尔类型：默认初始化值是FALSE\n5、引用数据类型：默认初始化值是null\n换行输出和不换行输出 System.out.print(\u0026#34;这是不换行输出\u0026#34;); System.out.println(\u0026#34;这是换行输出\u0026#34;); 拆分数字 12345这个四位数\n拆分 12345%10=5 12345/10=1234 1234%10=4 1234/10=123 123%10=3 123/10=12 12%10=2 12/10=1 1%10=1 1/10=0 //循环结束 组合 //组合是从高位向低位组合，比如说给出的是1，2，3，4这样的顺序 sum=0; sum = 1 + sum*10; //sum=1 sum = 2 + sum*10;//sum=12 sum = 3 + sum*10//sum=123 方法 方法：是程序中最小的执行单元\n要么全都一起执行，要么全都不执行\n要先定义后调用\n方法的定义和调用 无参数无返回值的方法 定义： public static void 方法名(){ 方法体; } 调用： 方法名(); 带参数无返回值的方法 定义： public static void 方法名(类型 参数1,类型 参数2，,...){ //形参 方法体; } 调用： 方法名(参数1,参数2); //实参 带参数带返回值的方法 定义： public static 返回值类型 方法名(类型 参数1,类型 参数2，,...){ //形参 方法体; return 返回值; } 调用： 直接调用 方法名(参数1,参数2); //实参 赋值调用 整数类型 变量名= 方法名（实参）; 输出调用 System.out.println(方法名(实参)); ","permalink":"https://wqnm1gb.github.io/posts/day04-%E6%95%B0%E7%BB%84%E5%92%8C%E6%96%B9%E6%B3%95/","summary":"\u003ch2 id=\"无限循环\"\u003e无限循环\u003c/h2\u003e\n\u003cp\u003e无限循环下边不能再写其他的代码了，因为执行不到了\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e//for格式的无限循环\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003efor\u003c/span\u003e\u003cspan class=\"p\"\u003e(;;){\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"c1\"\u003e//while格式的无限循环\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003ewhile\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kc\"\u003etrue\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"continue和break\"\u003econtinue和break\u003c/h2\u003e\n\u003cp\u003econtinue：跳过本次循环，继续执行下次循环\u003c/p\u003e\n\u003cp\u003ebreak：结束整个循环\u003c/p\u003e\n\u003ch2 id=\"random类\"\u003eRandom类\u003c/h2\u003e\n\u003cp\u003e使用步骤：\u003c/p\u003e","title":"Day04 数组和方法"},{"content":"if的注意点 1、在语句中，如果只有一句代码，那么大括号可以省略不写\nint a = 100; //这不算是一句代码，算是两句代码，一句是定义变量a，另一句是赋值 2、如果对一个布尔类型的变量进行判断，不要使用==号，直接把变量写在小括号中\nswitch语句 switch (表达式){ case 值1: //case后边的值只能是字面量，不能是变量 语句体1; break; case 值2: 语句体2; break; ... default: 语句体n+1; break; } default可以省略，语法不会有问题，但是不建议省略，default可以放在程序的任意位置\ncase穿透，语句体中没有写break导致的\n如果匹配上了，就会执行对应的语句体，如果此时发现了break，那么结束switch语句，如果没有发现break，那么程序就会继续执行下一个case语句，一直到遇到break或者右大括号为止\n如果多个case的语句体重复了，那么我们考虑用case穿透去简化代码\nif else一般是对范围的判断\nswitch 把有限个数据一一列举出来，让我们任选其一\n循环语句 100.fori 可以快速的写出循环100次的\nfor和while的区别 for循环中，控制循环的变量（变量i），归属于for循环的语法结构中，在for循环结束之后，就不能再次访问了（但是改写之后，可以改变这个规则）\nwhile循环中，控制循环的变量（变量i），不归属于while的循环结构中，在while循环结束之后，该变量还能继续访问\nfor循环一般知道循环的次数和范围\nwhile循环不知道次数和范围，但是知道结束条件\n","permalink":"https://wqnm1gb.github.io/posts/day03-%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/","summary":"\u003ch2 id=\"if的注意点\"\u003eif的注意点\u003c/h2\u003e\n\u003cp\u003e1、在语句中，如果只有一句代码，那么大括号可以省略不写\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e100\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"c1\"\u003e//这不算是一句代码，算是两句代码，一句是定义变量a，另一句是赋值\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e2、如果对一个布尔类型的变量进行判断，不要使用==号，直接把变量写在小括号中\u003c/p\u003e\n\u003ch2 id=\"switch语句\"\u003eswitch语句\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eswitch\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003e表达式\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"k\"\u003ecase\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e值1\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e         \u003c/span\u003e\u003cspan class=\"c1\"\u003e//case后边的值只能是字面量，不能是变量\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"n\"\u003e语句体1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003ebreak\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"k\"\u003ecase\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e值2\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"n\"\u003e语句体2\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003ebreak\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e...\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"k\"\u003edefault\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"n\"\u003e语句体n\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"n\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003ebreak\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003edefault可以省略，语法不会有问题，但是不建议省略，default可以放在程序的任意位置\u003c/p\u003e","title":"Day03 循环语句"},{"content":" 1、基本数据类型\n数据类型 关键字 整数 byte 1 short 2 int 4 long 8在数据值后边加一个L作为后缀，建议使用大写的L 浮点数 float 4数据值后边也需要加一个F作为后缀 double 8 字符 char 2 布尔 boolean 1 整数和小数取值范围大小关系：\n2、引用数据类型\n之后补充\n硬性要求：1、由数字，字母，下划线和美元符号($)组成 2、不能以数字开头 3、不能是关键字 4、区分大小写\n软性建议：\n小驼峰命名法：方法、变量\n1、标识符是一个单词的时候，全部小写\n2、标识符由多个单词组成的时候，第一个单词首字母小写，其他单词首字母大写\n大坨峰命名方法：类名\n1、标识符是一个单词的时候，首字母大写\n2、标识符由多个单词组成的时候，每个单词首字母大写\nproject（项目）\nmodule（模块）\npackage（包）\nclass（类）\n加，减，乘，除，取模\n在代码中，如果有小数参与运算，结果可能不精确\n整数参与计算，结果只能得到整数\n1.1小的会先提升为大的，在进行运算\n1.2byte，short和char三种数据类型在进行运算的时候，都会直接先提升为int，然后再进行运算\nbyte a = 10; byte b = 20; c = a + b;//此时的c是int类型 适用于规则1.2 取值范围\nbyte \u0026lt; short \u0026lt; int \u0026lt; long \u0026lt; float \u0026lt;double\n2、强制转换，取值范围大的变成取值范围小的\n要强制转换的是最终的结果\n如果我想把c定义为byte型\nbyte c = a + b //报错 byte c = (byte)a + b //报错，相当于强制转换a byte c = (byte)a + (byte)b //报错，相当于强制转换a和b，并不是转换最后的结果 byte c = (byte)(a + b) //正确 在+的过程中，只要有字符串参与，做的都会是拼接的操作\n连续+从左到右依次+\n+=，-=，*=，/=，%=底层都隐藏了一个强制类型转换\nshort s = 1; s + = 1; //等同于 s = (short)(s+1); 比如第一个不满足了就直接不满足，右边的语句就不会运行了\n|| 短路非 结果与|相同，但是有短路效果\n比如第一个满足了就全满足，右边的语句就不会运行了\n注意事项\n\u0026amp;|，无论左边是TRUE还是FALSE，右边都要执行\n\u0026amp;\u0026amp; || ，如果左边能确定表达式的结果，右边不执行\n关系表达式？表达式1:表达式2\n如果关系表达式是真，那么就使用表达式1，如果为假，那就使用表达式2\n使用的时候的方法是，max = a\u0026gt;b?a:b //把a，b中的最大值赋给max\noption+command+L 会自动格式化代码\n","permalink":"https://wqnm1gb.github.io/posts/day02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/","summary":"\u003c!-- raw HTML omitted --\u003e\n\u003cp\u003e1、基本数据类型\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e数据类型\u003c/th\u003e\n          \u003cth\u003e关键字\u003c/th\u003e\n          \u003cth\u003e\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e整数\u003c/td\u003e\n          \u003ctd\u003ebyte\u003c/td\u003e\n          \u003ctd\u003e1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c/td\u003e\n          \u003ctd\u003eshort\u003c/td\u003e\n          \u003ctd\u003e2\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c/td\u003e\n          \u003ctd\u003eint\u003c/td\u003e\n          \u003ctd\u003e4\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c/td\u003e\n          \u003ctd\u003elong\u003c/td\u003e\n          \u003ctd\u003e8\u003c!-- raw HTML omitted --\u003e在数据值后边加一个L作为后缀，建议使用大写的L\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e浮点数\u003c/td\u003e\n          \u003ctd\u003efloat\u003c/td\u003e\n          \u003ctd\u003e4\u003c!-- raw HTML omitted --\u003e数据值后边也需要加一个F作为后缀\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c/td\u003e\n          \u003ctd\u003edouble\u003c/td\u003e\n          \u003ctd\u003e8\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e字符\u003c/td\u003e\n          \u003ctd\u003echar\u003c/td\u003e\n          \u003ctd\u003e2\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e布尔\u003c/td\u003e\n          \u003ctd\u003eboolean\u003c/td\u003e\n          \u003ctd\u003e1\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e整数和小数取值范围大小关系：\u003c/p\u003e","title":"Day02 数据类型和运算符"},{"content":"cmd默认操作的是用户命名的文件夹（C:\\users\\用户名）\n盘符名称 + : 能够切换到这个盘符\ndir 查询该目录下的所有文件\nwindow下的文件分隔符是\\ 注意与Linux下的/ 不同\ncls 是清屏命令\nexit 是关闭窗口命令\njava目录 bin中存放了各种工具命令\nJDK java的开发工具 里边包含了 JVM+核心类库+开发工具\nJRE java的运行环境 里边包含了 JVM+核心类库+运行工具\n多行注释是 /* */\n文档注释是/** **/\nJava会先找到main语句，从main开始运行\njavac用于编译\njava用于运行\n类是Java最基本的组成单元\n空类型的null不能直接打印\n在打印的时候，把前边字符串的长度补齐到8，或者8的整数倍，最少补1个空格，最多补8个空格\n用处：打印类似表格数据的时候，让数据对齐\n2、变量名不允许被重复定义\n3、一条语句可以定义多个变量\n4、变量在使用之前一定要进行赋值\n5、变量的作用范围\n十进制：前边不加任何前缀\n八进制：代码中以0开头\n十六进制：代码中以0x开头\n","permalink":"https://wqnm1gb.github.io/posts/day01-java%E5%9F%BA%E7%A1%80/","summary":"\u003cp\u003ecmd默认操作的是用户命名的文件夹（C:\\users\\用户名）\u003c/p\u003e\n\u003cp\u003e盘符名称 + : 能够切换到这个盘符\u003c/p\u003e\n\u003cp\u003edir 查询该目录下的所有文件\u003c/p\u003e\n\u003cp\u003ewindow下的文件分隔符是\\ 注意与Linux下的/ 不同\u003c/p\u003e","title":"Day01 Java基础"},{"content":"Hello World！ ","permalink":"https://wqnm1gb.github.io/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","summary":"\u003ch1 id=\"hello-world\"\u003eHello World！\u003c/h1\u003e","title":"我的第一篇博客"},{"content":"个人学习博客\n","permalink":"https://wqnm1gb.github.io/about/","summary":"about","title":"关于"}]