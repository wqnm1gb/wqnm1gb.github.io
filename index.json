[{"content":"单元测试 就是针对最小的功能单元：方法，编写测试代码对其进行正确性测试。\n咱们之前是如何进行单元测试的？有啥问题？\n• 只能在main方法编写测试代码，去调用其他方法进行测试。\n• 无法实现自动化测试，一个方法测试失败，可能影响其他方法的测试。\n• 无法得到测试的报告，需要程序员自己去观察测试是否成功。\nJunit单元测试框架 可以用来对方法进行测试，它是第三方公司开源出来的（很多开发工具已经集成了Junit框架比如IDEA）\n优点\n• 可以灵活的编写测试代码，可以针对某个方法执行测试，也支持一键完成对全部方法的自动化测试，且各自独立。\n• 不需要程序员去分析测试的结果，会自动生成测试报告出来。\nJunit单元测试的使用步骤 需求\n• 某个系统，有多个业务方法，请使用Junit单元测试框架，编写测试代码，完成对这些方法的正确性测试。\n具体步骤\n① 将Junit框架的jar包导入到项目中（注意：IDEA集成了Junit框架，不需要我们自己手工导入了）\n② 为需要测试的业务类，定义对应的测试类，并为每个业务方法，编写对应的测试方法（必须：公共、无参、无返回值）\n③ 测试方法上必须声明@Test注解，然后在测试方法中，编写代码调用被测试的业务方法进行测试\n④ 开始测试：选中测试方法，右键选择“JUnit运行”，如果测试通过则是绿色；如果测试失败，则是红色\n反射 反射就是：加载类，并允许以编程的方式解剖类中的各种成分（成员变量、方法、构造器等）\nidea中能提示各种类里边的信息就是用了反射的方式\n获取class的三种方式 Class c1=类名.class // 1、方式1：Class c1=类名.class Class c1= Student.class; System.out.println(c1); 调用Class提供方法：public static Class forName（String package） // 2、方式2：调用Class提供方法：public static Class forName（String package） Class c2 = Class.forName(\u0026#34;com.demo02Reflect.Student\u0026#34;); System.out.println(c1==c2); Object提供的方法：public Class getClassO； Class c3 = 对象.getClassl // 3、方式3：使用对象.getClass() Student s = new Student(); Class c3 = s.getClass(); System.out.println(c3); 获取类中的构造器 反射的第一步都是拿到类\n方法 说明 Constructor[] getConstructors() 获取全部构造器（只能获取public修饰的） Constructor[] getDeclaredConstructors() 获取全部构造器（只要存在就能拿到，私有构造器也能拿到） Constructor getConstructor(Class\u0026hellip; parameterTypes) 获取某个构造器（只能获取public修饰的） Constructor getDeclaredConstructor(Class\u0026hellip; parameterTypes) 获取某个构造器（只要存在就能拿到） 获取类构造器的作用：依然是初始化对象返回 Constructor****提供的方法 说明 T newInstance(Object\u0026hellip; initargs) 调用此构造器对象表示的构造器，并传入参数，完成对象的初始化并返回 public void setAccessible(boolean flag) 设置为true，表示禁止检查访问控制（暴力反射） @Test public void getConstructor() throws Exception { Class c1 = Dog.class; // 返回一个Constructor数组 Constructor[] cons = c1.getDeclaredConstructors(); for (Constructor con : cons) { System.out.println(con); } // 获取单个构造器，里边有String和Int变量的 Constructor con1 = c1.getDeclaredConstructor(String.class, int.class); System.out.println(con1); // 创建对象并且返回 Dog d1 = (Dog)con1.newInstance(\u0026#34;小黑\u0026#34;, 2); System.out.println(d1); } 获取类中的成员变量 方法 说明 public Field[] getFields() 获取类的全部成员变量（只能获取public修饰的） public Field[] getDeclaredFields() 获取类的全部成员变量（只要存在就能拿到） public Field getField(String name) 获取类的某个成员变量（只能获取public修饰的） public Field getDeclaredField(String name) 获取类的某个成员变量（只要存在就能拿到） 获取到成员变量的作用：依然是赋值、取值\n方法 说明 void set(Object obj, Object value)： 赋值 Object get(Object obj)s 取值 public void setAccessible(boolean flag) 设置为true，表示禁止检查访问控制（暴力反射） @Test public void getField() throws Exception { // 获取成员变量 Class c1 = Dog.class; Field[] f1 = c1.getDeclaredFields(); for (Field f : f1) { System.out.println(f.getName()+\u0026#34;(\u0026#34;+f.getType().getName()+\u0026#34;)\u0026#34;); } // 获取单个成员变量 Field f2 = c1.getDeclaredField(\u0026#34;hobby\u0026#34;); System.out.println(f2.getName()+\u0026#34;(\u0026#34;+f2.getType().getName()+\u0026#34;)\u0026#34;); // 给成员变量赋值 Dog d1 = new Dog(\u0026#34;小黑\u0026#34;, 2); // 因为hobby是私有变量，所以需要暴力反射 f2.setAccessible(true); // 需要拿到f2（变量对象），再拿到d1（对象），才能进行修改 f2.set(d1, \u0026#34;看门\u0026#34;); } 获取类中的成员方法 方法 说明 Method[] getMethods() 获取类的全部成员方法（只能获取public修饰的） Method[] getDeclaredMethods() 获取类的全部成员方法（只要存在就能拿到） Method getMethod(String name, Class\u0026hellip; parameterTypes) 获取类的某个成员方法（只能获取public修饰的） Method getDeclaredMethod(String name, Class\u0026hellip; parameterTypes) 获取类的某个成员方法（只要存在就能拿到） 成员方法的作用：依然是执行\nMethod****提供的方法 说明 public Object invoke(Object obj, Object\u0026hellip; args) 触发某个对象的该方法执行。 public void setAccessible(boolean flag) 设置为true，表示禁止检查访问控制（暴力反射） public void getMethod() throws Exception { // 获取类中的方法 Class c1 = Dog.class; Method[] m1 = c1.getDeclaredMethods(); for (Method m : m1) { System.out.println(m.getName() + \u0026#34;(\u0026#34; + m.getParameterCount() + \u0026#34;)\u0026#34;); } // 获取单个成员方法 Method m2 = c1.getDeclaredMethod(\u0026#34;eat\u0026#34;); Method m3 = c1.getDeclaredMethod(\u0026#34;eat\u0026#34;, String.class); System.out.println(m2.getName() + \u0026#34;(\u0026#34; + m2.getParameterCount() + \u0026#34;)\u0026#34;); System.out.println(m3.getName() + \u0026#34;(\u0026#34; + m3.getParameterCount() + \u0026#34;)\u0026#34;); // 4、获取成员方法的目的依然是调用方法。 Dog d1 = new Dog(\u0026#34;小黑\u0026#34;, 2); m2.setAccessible(true); Object invoke = m2.invoke(d1); System.out.println(invoke); // 带回来的返回值，void参数所以是null Object invoke2 = m3.invoke(d1, \u0026#34;骨头\u0026#34;); System.out.println(invoke2); // 带回来的返回值：狗说：谢谢！谢谢！汪汪汪！ } 反射的作用 基本作用：可以得到一个类的全部成分然后操作\n可以破坏封装性。\n可以绕过泛型的约束（因为泛型是在编译的时候替换的，反射可以直接获得class文件，这个是运行时的文件，所以可以绕过约束）\n最重要的用途是：适合做Java的框架，基本上，主流的框架都会基于反射设计出一些通用的功能。\n使用反射做一个简易版的框架 需求：\n对于任意一个对象，该框架都可以把对象的字段名和对应的值，保存到文件中去。\n实现步骤\n① 定义一个方法，可以接收任意对象。\n② 每收到一个对象后，使用反射获取该对象的Class对象，然后获取全部的成员变量。\n③ 遍历成员变量，然后提取成员变量在该对象中的具体值。\n④ 把成员变量名、和其值，写出到文件中去即可。\n注解 就是Java代码里的特殊标记，比如：@Override、@Test等，作用是：让其他程序根据注解信息来决定怎么执行该程序\n注意：注解可以用在类上、构造器上、方法上、成员变量上、参数上、等位置处，最后边不需要加分号。\n自定义注解 就是自己定义注解\npublic @interface 注解名称 { public 属性类型 属性名() default 默认值 ; } 特殊属性名：value\n如果注解中只有一个value属性，使用注解时，value名称可以不写\n@A(10) public @interface A { int value(); int a() default 20; } 注解的原理 注解本质是一个接口，Java中所有注解都是继承了Annotation接口的。\n@注解（..）：其实就是一个实现类对象，实现了该注解以及Annotation接口。\n元注解 注解注解的注解\n@Retention(RetentionPolicy.RUNTIME) @Target({ElementType.METHOD}) public @interface Test { } @Target 作用：声明被修饰的注解只能在哪些位置使用\n@Target （ElementType.TYPE）\nTYPE，类，接口\nFIELD，成员变量\nMETHOD，成员方法\nPARAMETER，方法参数\nCONSTRUCTOR，构造器\nLOCAL_VARIABLE，局部变量\n@Retention 作用：声明注解的保留周期。\n@Retention（RetentionPolicy.RUNTIME）\nSOURCE：只作用在源码阶段，字节码文件中不存在。\nCLASS（默认值）：保留到字节码文件阶段，运行阶段不存在.\nRUNTIME（开发常用）：一直保留到运行阶段。\n注解的解析 就是判断类上、方法上、成员变量上是否存在注解，并把注解里的内容给解析出来\n如何解析注解 指导思想：要解析谁上面的注解，就应该先拿到谁。\n比如要解析类上面的注解，则应该先获取该类的Class对象，再通过Class对象解析其上面的注解。\n比如要解析成员方法上的注解，则应该获取到该成员方法的Method对象，再通过Method对象解析其上面的注解。\nClass、 Method、Field, Constructor、都实现了AnnotatedElement接口，它们都拥有解析注解的能力。\nAnnotatedElement****接口提供了解析注解的方法 说明 public Annotation[] getDeclaredAnnotations() 获取当前对象上面的注解。 public T getDeclaredAnnotation(Class annotationClass) 获取指定的注解对象 public boolean isAnnotationPresent(Class annotationClass) 判断当前对象上是否存在某个注解 使用注解开发出一个简易版的Junit框架 需求：定义若干个方法，只要加了Mytest注解，就会触发该方法执行\n① 定义一个自定义注解MyTest，只能注解方法，存活范围是一直都在\n② 定义若干个方法，部分方法加上@MyTest注解修饰，部分方法不加\n③ 模拟一个junit程序，可以触发加了@MyTest注解的方法执行\n注解里边的成员变量可以用来指示运行的次数\n动态代理设计模式 用明星的例子来理解\n对象如果嫌身上干的事太多的话，可以通过代理来转移部分职责。对象有什么方法想被代理，代理就一定要有对应的方法\n中介如何知道要派有唱歌、跳舞方法的代理呢 ？接口\njava.lang.reflect.Proxy类：提供了为对象产生代理对象的方法：\npublic static Object newProxyInstance(ClassLoader loader,Class[] interfaces, InvocationHandler h) 参数一：用于指定用哪个类加载器，去加载生成的代理类\n参数二：指定接口，这些接口用于指定生成的代理长什么，也就是有哪些方法\n参数三：用来指定生成的代理对象要干什么事情\n// 采用了多态的写法，返回一个接口，但是可以通过这个接口来创建代理对象 public static StarServer createProxy (Star s) { /** * 参数一：用于执行用哪个类加载器去加载生成的代理类。 * 参数二：用于指定代理类需要实现的接口: 明星类实现了哪些接口，代理类就实现哪些接口 * 参数三：用于指定代理类需要如何去代理（代理要做的事情）。 */ StarServer proxy =(StarServer)Proxy.newProxyInstance(ProxyUtl.class.getClassLoader(), s.getClass().getInterfaces(), new InvocationHandler() { // 用来声明代理对象要干的事情。 // 参数一： proxy接收到代理对象本身（暂时用处不大） // 参数二： method代表正在被代理的方法 // 参数三： args代表正在被代理的方法的参数 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 有两种method方法，判断一下 String name = method.getName(); if (\u0026#34;sing\u0026#34;.equals(name)) { System.out.println(\u0026#34;准备话筒，收钱20w\u0026#34;); } else if (\u0026#34;dance\u0026#34;.equals(name)) { System.out.println(\u0026#34;准备场地，收钱310w\u0026#34;); } // 把明星喊过来干活 Object invoke = method.invoke(s, args); return invoke; } }); return proxy; } 执行的时候，会先执行代理里边的方法\n","permalink":"https://wqnm1gb.github.io/posts/day16-java%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/","summary":"\u003ch1 id=\"单元测试\"\u003e单元测试\u003c/h1\u003e\n\u003cp\u003e就是针对最小的功能单元：方法，编写测试代码对其进行正确性测试。\u003c/p\u003e\n\u003cp\u003e咱们之前是如何进行单元测试的？有啥问题？\u003c/p\u003e\n\u003cp\u003e• 只能在main方法编写测试代码，去调用其他方法进行测试。\u003c/p\u003e","title":"Day16 Java高级技术"},{"content":"InetAddress类 代表IP地址\nInetAddress类的常用方法 说明 public static InetAddress getLocalHost() throws UnknownHostException 获取本机IP，返回一个InetAddress对象 public String getHostName() 获取该ip地址对象对应的主机名。 public String getHostAddress() 获取该ip地址对象中的ip地址信息。 public static InetAddress getByName(String host) throws UnknownHostException 根据ip地址或者域名，返回一个inetAddress对象 public boolean isReachable(int timeout) throws IOException 判断主机在指定毫秒内与该ip对应的主机是否能连通 UDP通信 特点：无连接、不可靠通信。\n不事先建立连接；发送端每次把要发送的数据（限制在64KB内）、接收端IP、等信息封装成一个数据包，发出去就不管了。\nJava提供了一个java.net.DatagramSocket类来实现UDP通信。\nDatagramSocket：用于创建客户端、服务端\n构造器 说明 public DatagramSocket() 创建客户端的Socket对象, 系统会随机分配一个端口号。 public DatagramSocket(int port) 创建服务端的Socket对象, 并指定端口号 方法 说明 public void send(DatagramPacketdp****) 发送数据包 public void receive(DatagramPacket p) 使用数据包接收数据 DatagramPacket：创建数据包\n构造器 说明 public DatagramPacket(byte[] buf, int length, InetAddress address, int port) 创建发出去的数据包对象 public DatagramPacket(byte[] buf, int length) 创建用来接收数据的数据包 方法 说明 public int getLength() 获取数据包，实际接收到的字节个数 客户端实现步骤 ① 创建DatagramSocket对象（客户端对象）\u0026mdash;\u0026mdash;\u0026gt;扔韭菜的人\n② 创建DatagramPacket对象封装需要发送的数据（数据包对象）\u0026mdash;\u0026ndash;\u0026gt;韭菜盘子\n③ 使用Datagramsocket对象的send方法，传入DatagramPaket对象 \u0026mdash;\u0026ndash;\u0026gt;开始抛出韭菜\n④ 释放资源\n客户端实现可以反复发送数据 ① 创建DatagramSocket对象（发送端对象）\n② 使用while死循环不断的接收用户的数据输入，如果用户输入的exit则退出程序\n③ 如果用户输入的不是exit，把数据封装成DatagramPacket\n④ 使用DatagramSocket对象的send方法将数据包对象进行发送\n⑤ 释放资源\n服务端实现步骤 ① 创建DatagramSocket对象并指定端口（服务端对象）\u0026mdash;\u0026ndash;\u0026gt; 接韭菜的人\n② 创建DatagramPacket对象接收数据（数据包对象）\u0026mdash;\u0026mdash;-\u0026gt; 韭菜盘子\n③ 使用DatagramSocket对象的receive方法，传入DatagramPacket对象 \u0026mdash;\u0026mdash;-\u0026gt;开始接收韭菜\n④ 释放资源\n服务端实现可以反复发送数据 ① 创建DatagramSocket对象并指定端口（服务端对象）\u0026mdash;\u0026ndash;\u0026gt; 接韭菜的人\n② 创建DatagramPacket对象接收数据（数据包对象）\u0026mdash;\u0026mdash;-\u0026gt; 韭菜盘子\n③ 使用DatagramSocket对象的receive方法，传入DatagramPacket对象 \u0026mdash;\u0026mdash;-\u0026gt;开始接收韭菜\n④ 使用while死循环不断的进行第3步\nUDP的接收端为什么可以接收很多发送端的消息？\n接收端只负责接收数据包，无所谓是哪个发送端的数据包。\nTCP通信 客户端程序就是通过java.net包下的Socket类来实现的。\n构造器 说明 public Socket(String host , int port) 根据指定的服务器ip、端口号请求与服务端建立连接，连接通过，就获得了客户端socket 方法 说明 public OutputStreamgetOutputStream() 获得字节输出流对象 public InputStreamgetInputStream() 获得字节输入流对象 通过流对象来接收和传输数据\n服务端是通过java.net包下的ServerSocket类来实现的。\n构造器 说明 public ServerSocket(int port) 为服务端程序注册端口 方法 说明 public Socket accept() 阻塞等待客户端的连接请求，一旦与某个客户端成功连接，则返回服务端这边的Socket对象。 客户端实现步骤 ① 创建客户端的Socket对象，请求与服务端的连接。\n② 使用socket对象调用getOutputstream()方法得到字节输出流。\n③ 使用字节输出流完成数据的发送。\n④ 释放资源：关闭socket管道。\n服务端实现步骤 ① 创建ServerSocket对象，注册服务端端口。\n② 调用ServerSocket对象的accept()方法，等待客户端的连接，并得到Socket管道对象。\n③ 通过Socket对象调用getInputStream()方法得到字节输入流、完成数据的接收。\n④ 释放资源：关闭socket管道\n继承了Thread类本身也可以当一个Runnable对象来进行使用，因为Thread类也实现了Runnable接口！\n时间类 JDK8之后的新方案\nLocalDate：代表本地日期（年、月、日、星期）\nLocalTime：代表本地时间（时、分、秒、纳秒）\nLocalDateTime：代表本地日期、时间（年、月、日、星期、时、分、秒、纳秒）\n方法名 示例 public static Xxxx now(): 获取系统当前时间对应的该对象 LocaDateld = LocalDate.now(); LocalTimelt = LocalTime.now(); LocalDateTimeldt = LocalDateTime.now(); LocalDateTime的常用API（可以处理年、月、日、星期、时、分、秒、纳秒等信息）\n方法名 说明 getYear、getMonthValue、getDayOfMonth、getDayOfYeargetDayOfWeek、getHour、getMinute、getSecond、getNano 获取年月日、时分秒、纳秒等 withYear、withMonth、withDayOfMonth、withDayOfYearwithHour、withMinute、withSecond、withNano 修改某个信息，返回新日期时间对象 plusYears、plusMonths、plusDays、plusWeeksplusHours、plusMinutes、plusSeconds、plusNanos 把某个信息加多少，返回新日期时间对象 minusYears、minusMonths、minusDays、minusWeeksminusHours、minusMinutes、minusSeconds、minusNanos 把某个信息减多少，返回新日期时间对象 equals isBeforeisAfter 判断2个时间对象，是否相等，在前还是在后 字符串高效操作 +号拼接字符串内容，效率不高，原因是String的对象是不可变变量，每次都要指向新的对象\n对于字符串相关的操作，如频繁的拼接、修改等，建议用StringBuidler，效率更高！\n注意：如果操作字符串较少，或者不需要操作，以及定义字符串变量，还是建议用String。\nStringBuilder代表可变字符串对象，相当于是一个容器，它里面装的字符串是可以改变的，就是用来操作字符串的。\n好处：StringBuilder比String更适合做字符串的修改操作，效率会更高，代码也会更简洁，而且支持链式操作\n构造器 说明 public StringBuilder() 创建一个空白的可变的字符串对象，不包含任何内容 public StringBuilder(String str) 创建一个指定字符串内容的可变字符串对象 方法名称 说明 public StringBuilder append(任意类型) 添加数据并返回StringBuilder对象本身 public StringBuilder reverse() 将对象的内容反转 public int length() 返回对象内容长度 public String toString() 通过toString()就可以实现把StringBuilder转换为String BigDecimal 用于解决浮点型运算时，出现结果失真的问题\n构造器 说明 public BigDecimal(double val) 注意：不推荐使用这个 将 double转换为 BigDecimal public BigDecimal(String val) 把String转成BigDecimal 方法名 说明 public static BigDecimal valueOf(double val) 转换一个 double成 BigDecimal public BigDecimal add(BigDecimal b) 加法 public BigDecimal subtract(BigDecimal b) 减法 public BigDecimal multiply(BigDecimal b) 乘法 public BigDecimal divide(BigDecimal b) 除法 public BigDecimal divide (另一个BigDecimal对象，精确几位，舍入模式) 除法、可以控制精确到小数几位 public double doubleValue() 将BigDecimal转换为double 应该如何把浮点型转换成Biglecimal的对象？\nBigDecimal b1 = BigDecimal. valueOf（0.1）\n","permalink":"https://wqnm1gb.github.io/posts/day15-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","summary":"\u003ch1 id=\"inetaddress类\"\u003eInetAddress类\u003c/h1\u003e\n\u003cp\u003e代表IP地址\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e\u003c!-- raw HTML omitted --\u003eInetAddress\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e类的常用方法\u003c!-- raw HTML omitted --\u003e\u003c/th\u003e\n          \u003cth\u003e\u003c!-- raw HTML omitted --\u003e说明\u003c!-- raw HTML omitted --\u003e\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003epublic static \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eInetAddress \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003egetLocalHost\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e() \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003ethrows \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eUnknownHostException\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003e获取本机\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eIP\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e，返回一个\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eInetAddress\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e对象\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003epublic \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eString \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003egetHostName\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e()\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003e获取该\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eip\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e地址对象对应的主机名。\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003epublic \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eString \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003egetHostAddress\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e()\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003e获取该\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eip\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e地址对象中的\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eip\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e地址信息。\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003epublic static \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eInetAddress \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003egetByName\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e(\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eString host\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e)   \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e    \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003ethrows \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eUnknownHostException\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003e根据\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eip\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e地址或者域名，返回一个\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003einetAddress\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e对象\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003epublic boolean \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eisReachable\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e(\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eint \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003etimeout\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e) \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003ethrows \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eIOException\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003e判断主机在指定毫秒内与该\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eip\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e对应的主机是否能连通\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch1 id=\"udp通信\"\u003eUDP通信\u003c/h1\u003e\n\u003cp\u003e特点：无连接、不可靠通信。\u003c/p\u003e","title":"Day15 网络编程"},{"content":"多线程 什么是线程？\n线程（Thread）是一个程序内部的一条执行流程\n程序中如果只有一条执行流程，那这个程序就是单线程的程序\n多线程是指从软硬件上实现的多条执行流程的技术（多条线程由CPU负责调度执行）\n创建线程的方式一：继承Thread类 ① 定义一个子类MyJhread继承线程类java.lang.Thread，重写run()方法\n② 创建MyThread类的对象\n③ 调用线程对象的start()方法启动线程（启动后还是执行run方法的）\n方式一优缺点：\n优点：编码简单\n缺点：线程类已经继承Thread，无法继承其他类，不利于功能的扩展。\n创建线程的注意事项 启动线程必须是调用start方法，不是调用run方法。\n•直接调用run方法会当成普通方法执行，此时相当于还是单线程执行。\n•只有调用start方法才是启动一个新的线程执行。\n不要把主线程任务放在启动子线程之前。\n• 这样主线程一直是先跑完的，相当于是一个单线程的效果了。\n创建线程的方式二：实现Runnable接口 ① 定义一个线程任务类MyRunnable实现Runnable接口，重写run()方法\n② 创建MyRunnable任务对象\n③ 把MyRunnable任务对象交给Thread处理。\nThread****类提供的构造器 说明 public Thread(Runnable target) 封装Runnable对象成为线程对象 ④ 调用线程对象的start()方法启动线程\n方式二的优缺点\n优点：任务类只是实现接口，可以继续继承其他类、实现其他接口，扩展性强。\n缺点：需要多一个Runnable对象。\n匿名内部类的写法\n① 可以创建Runnable的匿名内部类对象。\n② 再交给Thread线程对象。\n③ 再调用线程对象的start()启动线程。\nnew Thread(()-\u0026gt;{for (int i = 0; i \u0026lt; 5; i++) { System.out.println(\u0026#34;子线程2输出：\u0026#34;+ i); }}).start(); 创建线程的方式三：实现Callabel接口 ①创建任务对象\n定义一个类实现Callable接口，重写call方法，封装要做的事情，和要返回的数据。把Callable类型的对象封装成FutureJask（线程任务对象）\n②把线程任务对象交给Thread对象\n③调用Thread对象的start方法启动线程\n④线程执行完毕后、通过FutureJask对象的的get方法去获取线程任务执行的结果\nFutureTask的API\nFutureTask****提供的构造器 说明 public FutureTask\u0026lt;\u0026gt;(Callable call) 把Callable对象封装成FutureTask对象。 FutureTask****提供的方法 说明 public V get() throws Exception 获取线程执行call方法返回的结果。 线程创建方式三的优缺点\n优点：线程任务类只是实现接口，可以继续继承类和实现接口，扩展性强；可以在线程执行完毕后去获取线程执行的结果。\n缺点：编码复杂一点\n三种线程方式的对比 方式 优点 缺点 继承Thread类 编程比较简单，可以直接使用Thread类中的方法 扩展性较差，不能再继承其他的类，不能返回线程执行的结果 实现Runnable接口 扩展性强，实现该接口的同时还可以继承其他的类。 编程相对复杂，不能返回线程执行的结果 实现Callable接口 扩展性强，实现该接口的同时还可以继承其他的类。可以得到线程执行的结果 编程相对复杂 Thread的常用方法 Thread****提供的常用方法 说明 public void run() 线程的任务方法 public void start() 启动线程 public String getName****() 获取当前线程的名称，线程名称默认是Thread-索引 public void setName****(String name) 为线程设置名称，设置名字要在启动线程之前 public static Thread currentThread****() 获取当前执行的线程对象 public static void sleep(long time) 让当前执行的线程休眠多少毫秒后，再继续执行 public final void join()\u0026hellip; 让调用当前这个方法的线程先执行完，相当于插队 Thread****提供的常见构造器 说明 public Thread(String name) 可以为当前线程指定名称 public Thread(Runnable target) 封装Runnable对象成为线程对象 public Thread(Runnable target,String name) 封装Runnable对象成为线程对象，并指定线程名称 主线程的名字是main\n创建的线程名字是 Thread-编号\n解决线程安全问题的方法 方法1：同步代码块 作用：把访问共享资源的核心代码给上锁，以此保证线程安全。\nsynchronized（同步锁）{ 访问共享资源的核心代码 } 原理：每次只允许一个线程加锁后进入，执行完毕后自动解锁，其他线程才可以进来执行\n同步锁的注意事项\n对于当前同时执行的线程来说，同步锁必须是同一把（同一个对象），否则会出bug。\n锁对象随便选择一个唯一的对象好不好呢？\n不好，会影响其他无关线程的执行。\n锁对象的使用规范\n建议使用共享资源作为锁对象，对于实例方法建议使用this作为锁对象。\n对于静态方法建议使用字节码（类名.class）对象作为锁对象。\n方法2：同步方法 作用：把访问共享资源的核心方法给上锁，以此保证线程安全。\n修饰符 synchronized 返回值类型 方法名称（形参列表）{ 操作共享资源的代码 } 原理：每次只能一个线程进入，执行完毕以后自动解锁，其他线程才可以进来执行\n同步方法底层原理\n同步方法其实底层也是有隐式对象的，只是锁的范围是整个方法代码。\n如果方法是实例方法：同步方法默认用this作为的锁对象。\n如果方法是静态方法：同步方法默认用类名.class作为的锁对象。\n把run方法用synchronized修饰不一定有效果\n同步代码块好还是同步方法好？\n范围上：同步代码块锁的范围更小，同步方法锁的范围更大\n可读性：同步方法更好\n方式3：Lock锁 Lock锁是JDK5开始提供的一个新的锁定操作，通过它可以创建出锁对象进行加锁和解锁，更灵活、更方便、更强大。\nLock是接口，不能直接实例化，可以采用它的实现类Reentrantlgck来构建Lock锁对象。\n构造器 说明 public ReentrantLock() 获得Lock锁的实现类对象 方法名称 说明 void lock() 获得锁 void unlock() 释放锁 锁对象建议加上什么修饰？\n建议使用final修饰，防止被别人篡改\n释放锁的操作建议放到哪里？\n建议将释放锁的操作放到finally代码块中，确保锁用完了一定会被释放\n线程池 线程池就是一个可以复用线程的技术。\n不使用线程池的问题\n用户每发起一个请求，后台就需要创建一个新线程来处理，下次新任务来了肯定又要创建新线程处理的，创建新线程的开销是很大的，并且请求过多时，肯定会产生大量的线程出来，这样会严重影响系统的性能。\n任务队列中只能是Runnable和Callable任务\n创建线程池 JDK 5.0起提供了代表线程池的接口：ExecutorService。\n方式一：使用ExecutorService的实现类ThreadPoolExecutor自创建一个线程池对象\nThreadPoolExecutor类提供的构造器 作用 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue\u0026laquo;/font\u0026gt;Runnable\u0026gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) 使用指定的初始化参数创建一个新的线程池对象 参数一：corePoolSize：指定线程池的核心线程的数量。 正式工：3\n参数二：maximumPoolSize：指定线程池的最大线程数量。最大员工数：5 临时工：2\n参数三：keepAliveTime：指定临时线程的存活时间。 临时工空闲多久被开除\n参数四：unit：指定临时线程存活的时间单位（秒、分、时、天）\n参数五：workQueue：指定线程池的任务队列。 客人排队的地方\n参数六：threadFactory：指定线程池的线程工厂。 负责招聘员工的（hr）\n参数七：handler：指定线程池的任务拒绝策略（线程都在忙，任务队列也满了的时候，新任务来了该怎么处理） 忙不过来咋办？\n方式二：使用Executors（线程池的工具类）调用方法返回不同特点的线程池对象\n方法名称 说明 public static ExecutorService newFixedThreadPool(int nThreads) 创建固定线程数量的线程池，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程替代它。 public static ExecutorService newSingleThreadExecutor() 创建只有一个线程的线程池对象，如果该线程出现异常而结束，那么线程池会补充一个新线程。 public static ExecutorService newCachedThreadPool() 线程数量随着任务增加而增加，如果线程任务执行完毕且空闲了60s则会被回收掉。 public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) 创建一个线程池，可以实现在给定的延迟后运行任务，或者定期执行任务。 大型并发系统环境中使用Executors如果不注意可能会出现系统风险\nExecutors工具类底层是基于什么方式实现的线程池对象？\n线程池ExecutorSeryi.ce的实现类：ThreadPooJExecutor\nExecutors是否适合做大型互联网场景的线程池方案？\n不合适。\n建议使用ThreadPoolExecutor来指定线程池参数，这样可以明确线程池的运行规则，规避资源耗尽的风险。\n处理Runnable任务 方法名称 说明 void execute(Runnable command) 执行 Runnable 任务 Future submit(Callable task) 执行 Callable 任务，返回未来任务对象，用于获取线程返回的结果 void shutdown() 等全部任务执行完毕后，再关闭线程池！ List\u0026laquo;/font\u0026gt;Runnable\u0026gt; shutdownNow() 立刻关闭线程池，停止正在执行的任务，并返回队列中未执行的任务 线程池的注意事项 什么时候开始创建临时线程？ 新任务提交时发现核心线程都在忙，任务队列也满了，并且还可以创建临时线程，此时才会创建临时线程。\n什么时候会拒绝新任务？ 核心线程和临时线程都在忙，任务队列也满了，新的任务过来的时候才会开始拒绝任务。\n任务拒绝策略\n策略 说明 ThreadPoolExecutor.AbortPolicy() 丢弃任务并抛出RejectedExecutionException异常。是默认的策略 ThreadPoolExecutor. DiscardPolicy() 丢弃任务，但是不抛出异常，这是不推荐的做法 ThreadPoolExecutor. DiscardOldestPolicy() 抛弃队列中等待最久的任务 然后把当前任务加入队列中 ThreadPoolExecutor. CallerRunsPolicy() 由主线程负责调用任务的run()方法从而绕过线程池直接执行 处理Callable任务 线程池如何处理Callable任务，并得到任务执行完后返回的结果？\n使用ExecutorService的方法\nFuture submit（Callable command） 多态写法，返回一个RunnableFuture对象，可以调用里边get()方法\n进程 正在运行的程序（软件）就是一个独立的进程\n线程是属于进程的，一个进程中可以同时运行很多个线程\n进程中的多个线程其实是并发和并行执行的\n并发的含义 进程中的线程是由CPU负责调度执行的，但CPU能同时处理线程的数量有限，为了保证全部线程都能往前执行，CPU会轮询为系统的每个线程服务，由于CPU切换的速度很快，给我们的感觉这些线程在同时执行，这就是并发。\n并行的理解 在同一个时刻上，同时有多个线程在被CPU调度执行。\n","permalink":"https://wqnm1gb.github.io/posts/day14-thread/","summary":"\u003ch2 id=\"多线程\"\u003e多线程\u003c/h2\u003e\n\u003cp\u003e什么是线程？\u003c/p\u003e\n\u003cp\u003e线程（Thread）是一个程序内部的一条执行流程\u003c/p\u003e\n\u003cp\u003e程序中如果只有一条执行流程，那这个程序就是单线程的程序\u003c/p\u003e\n\u003cp\u003e多线程是指从软硬件上实现的多条执行流程的技术（多条线程由CPU负责调度执行）\u003c/p\u003e","title":"Day14 Thread"},{"content":"File File是java.io.包下的类，File类的对象，用于代表当前操作系统的文件（可以是文件、或文件夹）\n注意：File类只能对文件本身进行操作，不能读写文件里面存储的数据\n可以使用相对路径定位文件对象\n只要带盘符的都称之为：绝对路径E:/resource/aaa.jpg\n相对路径：不带盘符，默认是到你的idea工程下直接寻找文件的，一般用来找工程下的项目文件的\n注意只能相对到工程，后边的文件夹名和src还需要手动写\n创建File对象 构造器 说明 public File(String pathname) 根据文件路径创建文件对象 public File(String parent, String child) 根据父路径和子路径名字创建文件对象 File对象既可以代表文件、也可以代表文件夹。\nFile封装的对象仅仅是一个路径名，这个路径可以是存在的，也允许是不存在的。\n可以用/，也可以用\\\nFile提供的判断文件类型、获取文件信息功能 方法名称 说明 public boolean exists() 判断当前文件对象，对应的文件路径是否存在，存在返回true public booleanisFile() 判断当前文件对象指代的是否是文件，是文件返回true，反之。 public booleanisDirectory() 判断当前文件对象指代的是否是文件夹，是文件夹返回true，反之。 public String getName() 获取文件的名称（包含后缀） public long length() 获取文件的大小，返回字节个数 public long lastModified() 获取文件的最后修改时间。 public String getPath() 获取创建文件对象时，使用的路径 public String getAbsolutePath() 获取绝对路径 File提供的创建和删除文件的方法 File类创建文件的功能 方法名称 说明 public booleancreateNewFile() 创建一个新的空的文件 public booleanmkdir() 只能创建一级文件夹 public booleanmkdirs() 可以创建多级文件夹 File类删除文件的功能 方法名称 说明 public boolean delete() 删除文件、空文件夹 注意：delete方法默认只能删除文件和空文件夹，删除后的文件不会进入回收站。\nFile提供的遍历文件夹的方法 方法名称 说明 public String[] list() 获取当前目录下所有的\u0026quot;一级文件名称\u0026quot;到一个字符串数组中去返回。 public File[] listFiles() 获取当前目录下所有的\u0026quot;一级文件对象\u0026quot;到一个文件对象数组中去返回（重点） 使用listFiles方法时的注意事项：\n• 当主调是文件，或者路径不存在时，返回null\n• 当主调是空文件夹时，返回一个长度为0的数组\n• 当主调是一个有内容的文件夹时，将里面所有一级文件和文件夹的路径放在File数组中返回\n• 当主调是一个文件夹，目里面有隐藏文件时，将里面所有文件和文件夹的路径放在File数组中返回，包含隐藏文件\n• 当主调是一个文件夹，但是没有权限访问该文件夹时，返回null\n递归的三要素 递归的公式： f(n)= f(n-1)*n；\n递归的终结点：f(1)\n递归的方向必须走向终结点\n文件搜索 先找出D:盘下的所有一级文件对象\n遍历全部一级文件对象，判断是否是文件\n如果是文件，判断是否是自己想要的\n如果是文件夹，需要继续进入到该文件夹，重复上述过程\n字符集 标准的ASCII编码 ASCII（American Standard Code for Information Interchange）：美国信息交换标准代码，包括了英文、符号等。\n标准ASCIl使用1个字节存储一个字符，首位是0因此，总共可表示128个字符，对美国佬来说完全够用。\nGBK（汉字内码扩展规范，国标） 汉字编码字符集，包含了2万多个汉字等字符，GBK中一个中文字符编码成两个字节的形式存储。\n注意：GBK兼容了ASCII字符集。\nGBK规定：汉字的第一个字节的第一位必须是1\nUnicode字符集（统一码，也叫万国码） Unicode是国际组织制定的，可以容纳世界上所有文字、符号的字符集。\nUTF-8字符集 是Unicode字符集的一种编码方案，采取可变长编码方案，共分四个长度区：1个字书，2个字节，3个字节，4个字节（不像Unicode会占用4个字节，太大了）\n英文字符、数字等只占1个字节（兼容标准ASCII编码），汉字字符占用3个字节。\n前缀码\n注意1：字符编码时使用的字符集，和解码时使用的字符集必须一致，否则会出现乱码\n注意2：英文，数字一般不会乱码，因为很多字符集都兼容了ASCII编码。\n对字符集进行编码\nString提供了如下方法 说明 byte[] getBytes() 使用平台的默认字符集将该String编码为一系列字节，将结果存储到新的字节数组中 byte[] getBytes(String charsetName) 使用指定的字符集将该 String编码为一系列字节，将结果存储到新的字节数组中 对字符的解码\nString****提供了如下方法 说明 String(byte[] bytes) 通过使用平台的默认字符集解码指定的字节数组来构造新的 String String(byte[] bytes, String charsetName) 通过指定的字符集解码指定的字节数组来构造新的 String IO流 用于读写数据的（可以读写文件，或者网络上的数据）\nIO流的分类 IO流的体系 FileInputStream（文件字节输入流） 作用：以内存为基准，可以把磁盘文件中的数据以字节的形式读入到内存中去。\n构造器 说明 public FileInputStream(File file) 创建字节输入流管道与源文件接通 public FileInputStream(String pathname) 创建字节输入流管道与源文件接通 方法名称 说明 public int read() 每次读取一个字节返回，如果发现没有数据可读会返回-1，性能较差，而且不能读中文，每次读一个字节的话，中文会乱码 public int read(byte[] buffer) 每次用一个字节数组去读取数据，返回字节数组读取了多少个字节，如果发现没有数据可读会返回-1 使用FilelnputStream每次读取一个字节，读取性能较差，并且读取汉字输出会乱码。\n使用FilelnputStream每次读取多个字节，读取性能得到了提升，但读取汉字输出还是会乱码。\n1、使用字节流读取中文，如何保证输出不乱码，怎么解决？\n定义一个与文件一样大的字节数组，一次性读取完文件的全部字节（只适合读小文件）\nJava提供了方法：\n方法名称 说明 public byte[] readAllBytes() throws IOException 直接将当前字节输入流对应的文件对象的字节数据装到一个字节数组返回 如果文件过大，创建的字节数组也会过大，可能引起内存溢出。\n读取文本适合用字符流 字节流适合做数据的转移，比如：文件复制\nFileOutputStream文件字节输出流 作用：以内存为基准，把内存中的数据以字节的形式写出到文件中去。\n用完流后都要关闭\n\u0026ldquo;\\r\\n\u0026rdquo;.getBytes(); // 写出一个换行符\n构造器 说明 public FileOutputStream(File file) 创建字节输出流管道与源文件对象接通 public FileOutputStream(String filepath) 创建字节输出流管道与源文件路径接通 public FileOutputStream(File file，boolean append) 创建字节输出流管道与源文件对象接通，可追加数据，后边跟true表示可以追加 public FileOutputStream(String filepath，boolean append) 创建字节输出流管道与源文件路径接通，可追加数据 方法名称 说明 public void write(int a) 写一个字节出去 public void write(byte[] buffer) 写一个字节数组出去 public void write(byte[] buffer , int pos , int len) 写一个字节数组的一部分出去。 public void close() throws IOException 关闭流。 资源释放的问题 try-catch-finally finally代码区的特点：无论try中的程序是正常执行了，还是出现了异常，最后都一定会执行finally区，除非JVM终止。\n作用：一般用于在程序执行完成后进行资源的释放操作（专业级做法），但是比较臃肿\ntry-with-resource try(定义资源1;定义资源2;…）{ 可能出现异常的代码; }catch(异常类名 变量名){ 异常的处理代码; } 该资源使用完毕后，会自动调用其close()方法，完成对资源的释放！\n()中只能放置资源，否则报错\n什么是资源呢？\n资源一般指的是最终实现了AutoCloseable接口。\n字符流 FileReader文件字符输入流 作用：以内存为基准，可以把文件中的数据以字符的形式读入到内存中去。\n拓展：文件字符输入流每次读取多个字符，性能较好，而且读取中文是按照字符读取，不会出现乱码！这是一种读取中文很好的方案。\n构造器 说明 public FileReader****(File file) 创建字符输入流管道与源文件接通 public FileReader****(String pathname) 创建字符输入流管道与源文件接通 方法名称 说明 public int read() 每次读取一个字符返回，如果发现没有数据可读会返回-1. public int read(char[] buffer) 每次用一个字符数组去读取数据，返回字符数组读取了多少个字符，如果发现没有数据可读会返回-1. 读文档的时候，不要需加换行符，文档中自己有换行符\n�\nFileWriter文件字符输出流 以内存为基准，把内存中的数据以字符的形式写出到文件中去。\n构造器 说明 public FileWriter(File file) 创建字节输出流管道与源文件对象接通 public FileWriter(String filepath) 创建字节输出流管道与源文件路径接通 public FileWriter(File file，boolean append) 创建字节输出流管道与源文件对象接通，可追加数据 public FileWriter(String filepath，boolean append) 创建字节输出流管道与源文件路径接通，可追加数据 方法名称 说明 void write(int c) 写一个字符 void write(String str) 写一个字符串 void write(String str, int off, int len) 写一个字符串的一部分 void write(char[] cbuf) 写入一个字符数组 字符输出流写出数据后，必须刷新流，或者关闭流，写出去的数据才能生效\n方法名称 说明 public void flush() throws IOException 刷新流，就是将内存中缓存的数据立即写到文件中去生效！ public void close() throws IOException 关闭流的操作，包含了刷新！ 使用close就会默认刷新，或者使用try with resource也会默认在关闭的时候刷新\nBufferedInputstream缓冲字节输入和输出流 作用：可以提高字节输入流读取数据的性能\n原理：缓冲字节输入流自带了8KB缓冲池；缓冲字节输出流也自带了8KB缓冲池。\n构造器 说明 public BufferedInputStream(InputStream is) 把低级的字节输入流包装成一个高级的缓冲字节输入流，从而提高读数据的性能 public BufferedOutputStream(OutputStreamos) 把低级的字节输出流包装成一个高级的缓冲字节输出流，从而提高写数据的性能 BufferedReader缓冲字符输入流 作用：自带8K（8192）的字符缓冲池，可以提高字符输入流读取字符数据的性能。\n构造器 说明 public BufferedReader(Reader r) 把低级的字符输入流包装成字符缓冲输入流管道，从而提高字符输入流读字符数据的性能 字符缓冲输入流新增的功能：按照行读取字符\n方法 说明 public String readLine() 读取一行数据返回，如果没有数据可读了，会返回null Bufferedwriter缓冲字符输出流 作用：自带8K的字符缓冲池，可以提高字符输出流写字符数据的性能。\n构造器 说明 public BufferedWriter(Writer r) 把低级的字符输出流包装成一个高级的缓冲字符输出流管道，从而提高字符输出流写数据的性能（把低级管道变成一个高级管道，里边包着一个高级管道） 字符缓冲输出流新增的功能：换行\n方法 说明 public void newLine() 换行 可以把低级管道的缓冲桶加大，那么这样性能就会接近高级管道，所以并不是低级管道的新能一定差，相对来说，桶越大，复制速度越快\n其他流 InputStreamReader（字节输入转换流） 解决不同编码时，字符流读取文本内容乱码的问题。\n解决思路： 先获取文件的原始字节流再将其按真实的字符集编码转成字符输入流，这样字符输入流中的字符就不乱码了。\n这也是个高级流，里边可以包着一个低级流\n构造器 说明 public InputStreamReader(InputStream is) 把原始的字节输入流，按照代码默认编码转成字符输入流（与直接用FileReader的效果一样） public InputStreamReader(InputStream is ，String charset) 把原始的字节输入流，按照指定字符集编码转成字符输入流(重点) PrintStream/PrintWriter（打印流） 作用：打印流可以实现更方便、更高效的打印数据出去，能实现打印啥出去就是啥出去，性能也高。\nPrintStream提供的打印数据的方案\n构造器 说明 public PrintStream(OutputStream/File/String) 打印流直接通向字节输出流/文件/文件路径 publicPrintStream(String fileName, Charset charset) 可以指定写出去的字符编码 publicPrintStream(OutputStream out, boolean autoFlush) 可以指定实现自动刷新 publicPrintStream(OutputStream out, boolean autoFlush, String encoding) 可以指定实现自动刷新，并可指定字符的编码 方法 说明 public void println(Xxx**** xx) 打印任意类型的数据出去，天生自带换行 public void write(int/byte[]/byte[]一部分) 可以支持写字节数据出去 PrintWriter提供的打印数据的方案\n构造器 说明 public Print****Writer(OutputStream/Writer/File/String) 打印流直接通向字节输出流/文件/文件路径 publicPrintWriter(String fileName, Charset charset) 可以指定写出去的字符编码 publicPrintWriter(OutputStream out/Writer, boolean autoFlush) 可以指定实现自动刷新 publicPrintWriter(OutputStream out, boolean autoFlush, String encoding) 可以指定实现自动刷新，并可指定字符的编码 方法 说明 public void println(Xxx**** xx) 打印任意类型的数据出去 public void write(int/String/char[]/..) 可以支持写字符数据出去 PrintStream和PrintWriter的区别 • 打印数据的功能上是一模一样的：都是使用方便，性能高效（核心优势）\n• PrintStream继承自字节输出流OutputStream，因此支持写**字节数据**的方法。\n• PrintWriter继承自**字符输出流Writer，因此支持写字符数据**出去。\nDataOutputStream（数据输出流） 允许把数据和其类型一并写出去。\n构造器 说明 public DataOutputStream(OutputStream**** out) 创建新数据输出流包装基础的字节输出流 方法 说明 public final void writeByte(int v) throws IOException 将byte类型的数据写入基础的字节输出流 public final void writeInt****(int v) throws IOException 将int类型的数据写入基础的字节输出流 public final void writeDouble(Double v) throws IOException 将double类型的数据写入基础的字节输出流 public final void writeUTF(String str) throws IOException 将字符串数据以UTF-8编码成字节写入基础的字节输出流 public void write(int/byte[]/byte[]一部分) 支持写字节数据出去 DatalnputStream（数据输入流） 用于读取数据输出流写出去的数据。\n构造器 说明 public DataInputStream(InputStream**** is) 创建新数据输入流包装基础的字节输入流 方法 说明 Public final byte readByte() throws IOException 读取字节数据返回 public final int readInt****() throws IOException 读取int类型的数据返回 public final double readDouble() throws IOException 读取double类型的数据返回 public final String readUTF****() throws IOException 读取字符串数（UTF-8）据返回 public int readInt()/read(byte[]) 支持读字节数据进来 IO框架 什么是框架？\n框架（Framework）是一个预先写好的代码库或一组工具，旨在简化和加速开发过程\n框架的形式：一般是把类、接口等编译成class形式，再压缩成一个.jar结尾的文件发行出去\n导入commons-io-2.11.0jar框架到项目的步骤\n① 在项目中创建一个文件夹：lib\n② 将commons-io-2.6.jar文件复制到1ib文件夹\n③ 在jar文件上点右键，选择 Add as Library -\u0026gt; 点击OK\n④ 在类中导包使用\nCommons-io框架\nCommons-io是apache开源基金组织提供的一组有关IO操作的小框架，目的是提高IO流的开发效率。\nFileUtils类提供的部分方法展示 说明 public static void copyFile(File srcFile, File destFile) 复制文件。 public static void copyDirectory(File srcDir, File destDir) 复制文件夹 public static void deleteDirectory(File directory) 删除文件夹 public static String readFileToString(File file, String encoding) 读数据 public static void writeStringToFile(File file, String data, String charname, boolean append) 写数据 IOUtils类提供的部分方法展示 说明 public static int copy(InputStreaminputStream, OutputStreamoutputStream) 复制文件。 public static int copy(Reader reader, Writer writer) 复制文件。 public static void write(String data, OutputStream output, String charsetName) 写数据 ","permalink":"https://wqnm1gb.github.io/posts/day13-file%E5%92%8Cio%E6%B5%81/","summary":"\u003ch2 id=\"file\"\u003eFile\u003c/h2\u003e\n\u003cp\u003eFile是java.io.包下的类，File类的对象，用于代表当前操作系统的文件（可以是文件、或文件夹）\u003c/p\u003e\n\u003cp\u003e注意：File类\u003c!-- raw HTML omitted --\u003e只能对文件本身进行操作，不能读写文件里面存储的数据\u003c!-- raw HTML omitted --\u003e\u003c/p\u003e","title":"Day13 File和IO流"},{"content":"Set系列集合：添加的元素是无序、不重复、无索引 HashSet： 无序、不重复、无索引\nLinkedHashSet： 有序、不重复、无索引\nTreeSet：排序（按照大小默认升序排序）、不重复、无索引\nSet要用到的常用方法，基本上就是Collection提供的！！\n自己几乎没有额外新增一些常用功能！\nHashSet的底层原理 哈希值：就是一个int类型的随机值，Java中每个对象都有一个哈希值。\nJava中的所有对象，都可以调用Obejct类提供的hashCode方法，返回该对象自己的哈希值。\n对象哈希值的特点 同一个对象多次调用hashCode()方法返回的哈希值是相同的。\n不同的对象，它们的哈希值大概率不相等，但也有可能会相等（哈希碰撞）。\n基于哈希表存储数据的。\n哈希表\n• JDK8之前，哈希表=数组+链表\n创建一个默认长度16的数组，默认加载因子为0.75，16*0.75=12，存的数据超过12，扩容，增加一被的容量，数组名table\n使用元素的哈希值对数组的长度做运算计算出应存入的位置\n判断当前位置是否为null，如果是null直接存入\n如果不为null，表示有元素，则调用equals方法比较相等，则不存；不相等，则存入数组\nJDK 8之前，新元素存入数组，占老元素位置，老元素挂下面\nJDK 8开始之后，新元素直接挂在老元素下面\nJDK8开始 当链表长度超过8 且数组长度\u0026gt;=64时 自动将链表转成红黑树（提高检索性能）\n• JDK8开始，哈希表=数组+链表+红黑树\n• 哈希表是一种增删改查数据，性能都较好的数据结构\nHashSet集合去重复机制\n结论：如果希望Set集合认为2个内容一样的对象是重复的，必须重写对象的hashCode()和equals()方法\nLinkHashSet的底层原理 依然是基于哈希表（数组、链表、红黑树）实现的。\n但是，它的每个元素都额外的多了一个双链表的机制记录它前后元素的位置。\nTreeSet集合 特点：不重复、无索引、可排序（默认升序排序，按照元素的大小，由小到大排序）\n底层是基于红黑树实现的排序。\n注意：\n• 对于数值类型：Integer,Double，默认按照数值本身的大小进行升序排序。\n• 对于字符串类型：默认按照首字符的编号升序排序。\n• 对于自定义类型如Student对象，TreeSet默认是无法直接排序的。\n结论：TreeSet集合默认不能 给白定义对象排序啊，因为不知道大小规则，并且一定要实现\n1、对象类实现一个Comparable比较接口，重写compareTo方法，指定大小比较规则\n@Override public int compareTo(Teacher o) { //用年龄进行比较 if(this.age\u0026gt;o.age) return 1; if(this.age\u0026lt;o.age) return -1; //如果return 0的话，两个相等的值就只会保留一个，如果想都保留，需要在相等的时候return1 return 1; // return 0; } 2、public Treeset （Comparator c）集合自带比较器Comparator对象，指定比较规则（优先级更高）\n//解决方法2、public Treeset （Comparator c）集合自带比较器Comparator对象，指定比较规则（优先级更高） // Set\u0026lt;Teacher\u0026gt; set = new TreeSet\u0026lt;\u0026gt;(new Comparator\u0026lt;Teacher\u0026gt;() { // @Override // public int compare(Teacher o1, Teacher o2) { // return o2.getAge()-o1.getAge(); // } // }); Set\u0026lt;Teacher\u0026gt; set = new TreeSet\u0026lt;\u0026gt;((o1, o2) -\u0026gt; o2.getAge()-o1.getAge()); Map-双列集合 每个元素包含两个值（键值对）\nMap集合也被叫做“键值对集合”，格式：｛keyl=valuel，key2=value2,key3=value3，\u0026hellip;｝\nMap集合的所有键是不允许重复的，但值可以重复，键和值是一一对应的，每一个键只能找到自己对应的值\n需要存储一一对应的数据时，就可以考虑使用Map集合来做\nMap集合体系的特点 注意：Map系列集合的特点都是由键决定的，值只是一个附属品，值是不做要求的\n• HashMap（由键决定特点）：无序、不重复、无索引、键值对可以都是null；（用的最多）\n• LinkedHashMap（由键决定特点）：由键决定的特点：有序、不重复、无索引、键值对可以都是null\n• TreeMap（由键决定特点）：按照大小默认升序排序、不重复、无索引\nMap集合的常用方法 方法名称 说明 public V put(K key,V value) 添加元素 public int size() 获取集合的大小 public void clear() 清空集合 public booleanisEmpty() 判断集合是否为空，为空返回true , 反之 public V get(Object key) 根据键获取对应值 public V remove(Object key) 根据键删除整个元素 public booleancontainsKey(Object key) 判断是否包含某个键 public booleancontainsValue(Object value) 判断是否包含某个值 public Set keySet() 获取全部键的集合 public Collection values() 获取Map集合的全部值 Map集合的遍历方式 方式1：键找值 先获取Map集合全部的键，再通过遍历键来找值\npublic static void main(String[] args) { //遍历方式1 键找值：通过Set集合获得键集合，然后找到所有的值集合 Map\u0026lt;String,Integer\u0026gt; m =new HashMap\u0026lt;\u0026gt;(); m.put(\u0026#34;张三\u0026#34;,18); m.put(\u0026#34;李四\u0026#34;,19); m.put(\u0026#34;王五\u0026#34;,20); m.put(\u0026#34;王五\u0026#34;,22);//键相同的情况下只会保留一个键值对 m.put(\u0026#34;赵六\u0026#34;,21); Set\u0026lt;String\u0026gt; keys = m.keySet(); for (String key : keys) { System.out.println(key+\u0026#34;--\u0026gt;\u0026#34;+m.get(key)); } } 方式2：键值对 Map****提供的方法 说明 Set\u0026laquo;/font\u0026gt;Map.Entry\u0026lt;K, V\u0026raquo; entrySet() 获取所有“键值对”的集合 Map.Entry****提供的方法 说明 K getKey() 获取键 V getValue() 获取值 public static void main(String[] args) { //遍历方式2 键值对：Set\u0026lt;Map.Entry\u0026lt;K, V\u0026gt;\u0026gt; entrySet() Map\u0026lt;String,Integer\u0026gt; m =new HashMap\u0026lt;\u0026gt;(); m.put(\u0026#34;张三\u0026#34;,18); m.put(\u0026#34;李四\u0026#34;,19); m.put(\u0026#34;王五\u0026#34;,20); m.put(\u0026#34;王五\u0026#34;,22);//键相同的情况下只会保留一个键值对 m.put(\u0026#34;赵六\u0026#34;,21); Set\u0026lt;Map.Entry\u0026lt;String,Integer\u0026gt;\u0026gt; set = m.entrySet(); // Map.Entry\u0026lt;String,Integer\u0026gt;相当于是一个类型 for (Map.Entry\u0026lt;String, Integer\u0026gt; stringIntegerEntry : set) { String s = stringIntegerEntry.getKey(); Integer i = stringIntegerEntry.getValue(); System.out.println(s+\u0026#34;---\u0026gt;\u0026#34;+i); } } 方式3：Lambda 本质也是增强for\n方法名称 说明 default void forEach(BiConsumer\u0026lt;? super K, ? super V\u0026gt; action) 结合lambda遍历Map集合 public static void main(String[] args) { //遍历方式3 Lambda Map\u0026lt;String,Integer\u0026gt; m =new HashMap\u0026lt;\u0026gt;(); m.put(\u0026#34;张三\u0026#34;,18); m.put(\u0026#34;李四\u0026#34;,19); m.put(\u0026#34;王五\u0026#34;,20); m.put(\u0026#34;王五\u0026#34;,22);//键相同的情况下只会保留一个键值对 m.put(\u0026#34;赵六\u0026#34;,21); m.forEach((k,v)-\u0026gt;System.out.println(k+\u0026#34;--\u0026gt;\u0026#34;+v)); m.forEach(new BiConsumer\u0026lt;String, Integer\u0026gt;() { @Override public void accept(String s, Integer integer) { //重写accpet方法就可以遍历 System.out.println(s+\u0026#34;--\u0026gt;\u0026#34;+integer); } }); HashMap的底层原理 实际上：原来学的Set系列集合的底层就是基于Map实现的，只是Set集合中的元素只要键数据，不要值数据而已。\nLinkHashMap的底层原理 实际上：原来学习 的LinkedHashSet集合的底层原理就是LinkedHashMap。\nTreeMap的底层原理 特点：不重复、无索引、可排序（按照键的大小默认升序排序，只能对键排序）\n原理：TreeMap跟TreeSet集合的底层原理是一样的，都是基于红黑树实现的排序。\nTreeMap集合同样也支持两种方式来指定排序规则\n• 让类实现Comparable接口，重写比较规则。\n• TreeMap集合有一个有参数构造器，支持创建Comparator比较器对象，以便用来指定比较规则。\nStream流 是Jdk8开始新增的一套API （java.util.stream.*），可以用于操作集合或者数组的数据。\n优势：Stream流大量的结合了Lambda的语法风格来编程，功能强大，性能高效，代码简洁，可读性好。\nStream流的使用步骤 获取Stream流 • 获取集合的Stream流\nCollection提供的如下方法\ndefault Streams stream()\n获取当前集合对象的stream流\n• 获取 数组的Stream流\nArrays类提供的如下方法\npublic static Streams stream(T[] array)\n获取当前数组的stream流\nStream类提供的如下方法\npublic static Streams of (T\u0026hellip; values)\n//\u0026hellip;是可变参数\n获取当前接收数据的stream流\nStream流上的常用方法 称为中间方法，用完之后会返回一个新的流，支持链式编程\npublic static void main(String[] args) { // 目标：认识Stream流的常用方法 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;张无忌\u0026#34;); list.add(\u0026#34;周芷若\u0026#34;); list.add(\u0026#34;赵敏\u0026#34;); list.add(\u0026#34;张强\u0026#34;); list.add(\u0026#34;张三丰\u0026#34;); list.add(\u0026#34;张翠山\u0026#34;); // 1、过滤方法 list.stream().filter(s -\u0026gt; s.startsWith(\u0026#34;张\u0026#34;) \u0026amp;\u0026amp; s.length() == 3).forEach(System.out::println); System.out.println(\u0026#34;=========================\u0026#34;); // 2.排序方法 List\u0026lt;Double\u0026gt; scores = new ArrayList\u0026lt;\u0026gt;(); scores.add(88.6); scores.add(66.6); scores.add(66.6); scores.add(77.6); scores.add(77.6); scores.add(99.6); scores.stream().sorted().forEach(System.out::println); // 升序 System.out.println(\u0026#34;=========================\u0026#34;); // 降序需要重写 scores.stream().sorted((o1,o2)-\u0026gt; Double.compare(o2,o1)).forEach(System.out::println); System.out.println(\u0026#34;=========================\u0026#34;); // 3、只要前两名 scores.stream().sorted((o1,o2)-\u0026gt; Double.compare(o2,o1)).limit(2).forEach(System.out::println); System.out.println(\u0026#34;=========================\u0026#34;); // 4、跳过前两名 scores.stream().sorted((o1,o2)-\u0026gt; Double.compare(o2,o1)).skip(2).forEach(System.out::println); System.out.println(\u0026#34;=========================\u0026#34;); // 5、去重 scores.stream().sorted((o1,o2)-\u0026gt; Double.compare(o2,o1)).distinct().forEach(System.out::println); // 6、映射/加工方法，把流上的数据加工后，再次放回流里边去 scores.stream().map(s -\u0026gt;\u0026#34;加十分后:\u0026#34; + s+10).forEach(System.out::println); // 7、合并流 Stream\u0026lt;String\u0026gt; s1 = Stream.of(\u0026#34;张三丰\u0026#34;, \u0026#34;张无忌\u0026#34;, \u0026#34;张翠山\u0026#34;, \u0026#34;张良\u0026#34;, \u0026#34;张学友\u0026#34;); Stream\u0026lt;Integer\u0026gt; s2 = Stream.of(111, 22, 33, 44); Stream\u0026lt;Object\u0026gt; s3 = Stream.concat(s1, s2); s3.forEach(System.out::println); // 流没有重写toString方法java.util.stream.ReferencePipeline$Head@77459877 System.out.println(s3); } Stream上的终结方法 收集Stream流：就是把Stream流操作后的结果转回到集合或者数组中去返回。\nStream流：方便操作集合/数组的手段； 集合/数组：才是开发中的目的。\n流只能收集一次\npublic static void main(String[] args) { // 目标：掌握Stream流的统计，收集操作（终结方法） List\u0026lt;Teacher\u0026gt; teachers = new ArrayList\u0026lt;\u0026gt;(); teachers.add(new Teacher(\u0026#34;张三\u0026#34;, 23, 5000)); teachers.add(new Teacher(\u0026#34;金毛狮王\u0026#34;, 54, 16000)); teachers.add(new Teacher(\u0026#34;李四\u0026#34;, 24, 6000)); teachers.add(new Teacher(\u0026#34;王五\u0026#34;, 25, 7000)); teachers.add(new Teacher(\u0026#34;白眉鹰王\u0026#34;, 66, 108000)); teachers.add(new Teacher(\u0026#34;陈昆\u0026#34;, 42, 48000)); teachers.stream().filter(t -\u0026gt; t.getSalary() \u0026gt; 15000).forEach(System.out::println); System.out.println(\u0026#34;--------------------------------------------------\u0026#34;); long count = teachers.stream().filter(t -\u0026gt; t.getSalary() \u0026gt; 15000).count(); System.out.println(count); System.out.println(\u0026#34;--------------------------------------------------\u0026#34;); // 获取薪水最高的老师对象 Optional\u0026lt;Teacher\u0026gt; max = teachers.stream().max((t1, t2) -\u0026gt; Double.compare(t1.getSalary(), t2.getSalary())); Teacher maxTeacher = max.get(); // 获取Optional对象中的元素 System.out.println(maxTeacher); Optional\u0026lt;Teacher\u0026gt; min = teachers.stream().min((t1, t2) -\u0026gt; Double.compare(t1.getSalary(), t2.getSalary())); Teacher minTeacher = min.get(); // 获取Optional对象中的元素 System.out.println(minTeacher); System.out.println(\u0026#34;---------------------------------------------------------\u0026#34;); List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;张无忌\u0026#34;); list.add(\u0026#34;周芷若\u0026#34;); list.add(\u0026#34;赵敏\u0026#34;); list.add(\u0026#34;张强\u0026#34;); list.add(\u0026#34;张三丰\u0026#34;); list.add(\u0026#34;张三丰\u0026#34;); list.add(\u0026#34;张翠山\u0026#34;); // 流只能收集一次 // 收集到集合或者数组中去。 Stream\u0026lt;String\u0026gt; s1 = list.stream().filter(s -\u0026gt; s.startsWith(\u0026#34;张\u0026#34;)); // 收集到List集合 List\u0026lt;String\u0026gt; list1 = s1.collect(Collectors.toList()); System.out.println(list1); // Set\u0026lt;String\u0026gt; set2 = new HashSet\u0026lt;\u0026gt;(); // set2.addAll(list1); // 收集到Set集合 Stream\u0026lt;String\u0026gt; s2 = list.stream().filter(s -\u0026gt; s.startsWith(\u0026#34;张\u0026#34;)); Set\u0026lt;String\u0026gt; set = s2.collect(Collectors.toSet()); System.out.println(set); // 收集到数组中去 Stream\u0026lt;String\u0026gt; s3 = list.stream().filter(s -\u0026gt; s.startsWith(\u0026#34;张\u0026#34;)); Object[] array = s3.toArray(); System.out.println(\u0026#34;数组：\u0026#34; + Arrays.toString(array)); System.out.println(\u0026#34;------------------收集到Map集合---------------------------\u0026#34;); // 收集到Map集合：键是老师名称，值是老师薪水 Map\u0026lt;String, Double\u0026gt; map = teachers.stream().collect(Collectors.toMap(Teacher::getName, Teacher::getSalary)); System.out.println(map); } 方法中的可变参数 就是一种特殊形参，定义在方法、构造器的形参列表里，格式是：数据类型⋯参数名称；\n可变参数的特点和好处 特点：可以不传数据给它；可以传一个或者同时传多个数据给它；也可以传一个数组给它。\n好处：常常用来灵活的接收数据。\n可变参数对内其实就是一个数组\n可变参数在形参列表中只能有一个，可变参数必须放在形参列表的最后面\npublic static void main(String[] args) { // 认识方法中的可变参数 show(); show(1,2,3); show(new int[]{1,2,3,4,4}); } public static void show(int... args){ // 内部怎么拿数据： // 可变参数对内实际上就是一个数组。nums就是数组 System.out.println(args.length); System.out.println(Arrays.toString(args)); System.out.println(\u0026#34;------------------------------------------------\u0026#34;); } Collections工具类 1、给集合批量加数据\n2、打乱顺序\npublic static void main(String[] args) { // 目标：Colllections工具类 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); // list.add(\u0026#34;张无忌\u0026#34;); // list.add(\u0026#34;周芷若\u0026#34;); // list.add(\u0026#34;赵敏\u0026#34;); // list.add(\u0026#34;张强\u0026#34;); // list.add(\u0026#34;张三丰\u0026#34;); // list.add(\u0026#34;张翠山\u0026#34;); // 1、Collections的方法批量加 Collections.addAll(list,\u0026#34;张无忌\u0026#34;,\u0026#34;周芷若\u0026#34;,\u0026#34;赵敏\u0026#34;,\u0026#34;张强\u0026#34;,\u0026#34;张三丰\u0026#34;,\u0026#34;张翠山\u0026#34;); System.out.println(list); // 2、打乱顺序 Collections.shuffle(list); System.out.println(list); }\t","permalink":"https://wqnm1gb.github.io/posts/day12-mapstream%E6%B5%81/","summary":"\u003ch3 id=\"set系列集合添加的元素是font-stylebackground-colorfbde28无序不重复无索引font\"\u003eSet系列集合：添加的元素是\u003c!-- raw HTML omitted --\u003e无序、不重复、无索引\u003c!-- raw HTML omitted --\u003e\u003c/h3\u003e\n\u003cp\u003eHashSet： \u003c!-- raw HTML omitted --\u003e无序\u003c!-- raw HTML omitted --\u003e、不重复、无索引\u003c/p\u003e\n\u003cp\u003eLinkedHashSet： \u003c!-- raw HTML omitted --\u003e有序\u003c!-- raw HTML omitted --\u003e、不重复、无索引\u003c/p\u003e","title":"Day12 Map、Stream流"},{"content":"异常 Error Error 代表的系统级别错误（属于严重问题），也就是说系统一旦出现问题，sun公司会把这些问题封装成Error对象给出来（说白了，Error是给sun公司自己用的，不是给我们程序员用的，因此我们开发人员不用管它）\nException 运行时异常 编译阶段不报错，运行时报错，继承自RunTimeException，一旦错误出现，程序就会结束\nNullPointException空指针\n编译时异常 提醒程序员这里的程序很容易出错，需要小心\n使用try catch解决(可以解决编译时异常，也可以解决运行时异常），提醒会更加的强烈，同时处理完异常后，程序不会结束\n异常的基本处理 throws抛出异常 在方法上使用throws关键字，可以将方法内部出现的异常抛出去给调用者处理。\ntry catch捕获异常 直接捕获可能出现的异常\n异常的作用 1、用来定位bug的关键信息\n2、作为方法内部的一种特殊的返回值，以便通知上层调用者，方法执行的问题\n自定义异常 Java无法为这个世界上全部的问题都提供异常类来代表 如果企业自己的某种问题， 想通过异常来表示，以便用异常来管理该问题，那就需要自己来定义异常类了。\n建议使用运行时异常，这样提醒没有那么强烈\n自定义运行时异常 定义一个异常类继承RuntimeException\n重写构造器\n通过throw new 异常类（xxx）来创建异常对象并拋出\n特点：编译阶段不报错，运行时才可能出现！提醒不属于激进型\n自定义编译时异常 定义一个异常类继承Exception\n重写构造器\n通过throw new 异常类（xxxx）创建异常对象并抛出\n特点：编译阶段就报错，提醒比较激进\n异常的处理方案 command option t 快捷生成try catch\n方案1 底层异常层层往上抛出，最外层捕获异常，记录下异常信息，并响应适合用户观看的信息进行提示\n有多个异常的时候，直接抛Exception，这样不用多个异常写多个异常的种类\n然后catch的时候，也就catch Exception类就行了\n方案2 最外层捕获异常后，尝试重新修复\n泛型 定义类、接口、方法时，同时声明了一个或者多个类型变量（如：）\n称为泛型类、泛型接口，泛型方法、它们统称为泛型。\npublic class ArrayList\u0026lt;E\u0026gt;{ } 作用：泛型提供了在编译阶段约束所能操作的数据类型，并自动进行检查的能力！\n泛型的本质：把具体的数据类型作为参数传给类型变量\n泛型类 修饰符 class类名\u0026lt;类型变量，类型变量，…\u0026gt;｛ ｝ 注意：类型变量建议用大写的英文字母，常用的有：E、T、K、V等\n泛型接口 修饰符 interface 接口名\u0026lt;类型变量，类型变量，...\u0026gt; ｝ 泛型方法，通配符，上下限 泛型方法 修饰符\u0026lt;类型变量，类型变量，…＞返回值类型 方法名（形参列表）｛ ｝ // 泛型方法声明都有一个类型参数声明部分（由尖括号分隔） public static \u0026lt;T\u0026gt; void test（T t）｛ ｝ 通配符 就是“？”，可以在“使用泛型”的时候代表一切类型；ET KV 是在定义泛型的时候使用。\n泛型的上下限 • 泛型上限：？extends Car：？能接收的必须是Car或者其子类。\n• 泛型下限：？super Car：？能接收的必须是Car或者其父类。\n泛型支持的类型 泛型不支持基本数据类型，只能支持对象类型（引用数据类型）\n泛型擦除：泛型工作在编译阶段，等编译后泛型就没用了，所以泛型在编译后都会被擦除。所有类型会恢复成Object类型，Object一定要指向一个对象\n包装类 包装类就是把基本类型的数据包装成对象的类型\nInteger把-128-127先缓存起来了\nInteger it1 = Integer.valueof(100); Integer it3 = 100;//和第一句一样的，自动装箱，变成对象 Integer it2 = Integer.valueof(100); System.out.println(it1==it2);//true 自动装箱：基本数据类型可以自动转换为包装类型。\n自动拆箱：包装类型可以自动转换为基本数据类型。\n包装类的其他功能 可以把基本类型的数据转换成字符串类型。\npublic static String toString(double d) public String toString() //功能比较鸡肋，一般转成字符串会用 String s1 = 123 + \u0026#34;\u0026#34;; 可以把字符串类型的数值转换成数值本身对应的真实数据类型（这个重要）\npublic static int parselnt(String s) public static Integer valueOf(String s) 集合框架 集合是一种容器，用来装数据的，类似于数组，但集合的大小可变，开发中也非常常用\n集合体系结构 集合的结构分成了两类\nCollection-单列集合 每个元素（数据）只包含一个值\n常用功能\n方法名 说明 public boolean add(E e) 把给定的对象添加到当前集合中 public void clear() 清空集合中所有的元素 public boolean remove(E e) 把给定的对象在当前集合中删除 public boolean contains(Object obj) 判断当前集合中是否包含给定的对象 public boolean isEmpty() 判断当前集合是否为空 public int size() 返回集合中元素的个数。 public Object[] toArray() 把集合中的元素，存储到数组中，默认转换成Object数组 Collection的遍历方式1：迭代器遍历\nnext() 函数默认是在第一个元素的位置，先取值在去到下一个元素位置\nhasnext() 函数是判断当前位置是否有元素\n获取迭代器\n方法名称 说明 Iterator iterator() 返回集合中的迭代器对象，该迭代器对象默认指向当前集合的第一个元素 迭代器中常用的方法\n方法名称 说明 boolean hasNext() 询问当前位置是否有元素存在，存在返回true ,不存在返回false E next() 获取当前位置的元素，并同时将迭代器对象指向下一个元素处。 Collection的遍历方式2：增强for循环\nfor (元素的数据类型 变量名 : 数组或者集合) { } 增强for可以用来遍历集合或者数组\n增强for遍历集合，本质就是迭代器遍历集合的简化写法\n快捷方式 数组/集合名.for\n底层就是基于迭代器\nCollection的遍历方式3：Lambda表达式\n要使用如下方法来完成\n方法名称 说明 default void forEach(Consumer\u0026lt;? super T\u0026gt; action) 结合lambda遍历集合 public static void main(String[] args) { //遍历方式3：使用Lambda表达式 ArrayList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;张三\u0026#34;); list.add(\u0026#34;李四\u0026#34;); list.add(\u0026#34;王五\u0026#34;); list.add(\u0026#34;赵6\u0026#34;); list.forEach(s -\u0026gt; System.out.println(s)); list.forEach(System.out::println); } 三种遍历的区别 认识并发修改异常问题\n遍历集合的同时又存在增删集合元素的行为时可能出现业务异常，这种现象被称之为并发修改异常问题。\nfor循环删除元素没删干净的本质原因是：删除一个元素后，后边一个元素立马补上来，导致了漏删\n解决方案1：删除元素后做一步i\u0026ndash;\n解决方案2：倒着遍历删除（前提是支持索引），原因是后边的元素补过来都是判断后不用删的，而顺着遍历前边的元素补上来不知道是否要删除\n1、迭代器遍历并删除存在并发修改异常问题，解决方案：使用迭代器自己的删除方法\n2、增强for和lambda都没办法解决并发修改异常问题，他们只适合做遍历，不适合做增删\n如果知道索引可以使用i\u0026ndash;的方式解决，如果不知道索引，就用迭代器的删除功能\nList系列集合：添加的元素是有序、可重复、有索引 List集合因为支持索引，所以多了很多与索引相关的方法，当然，Collection的功能List也都继承了。\n方法名称 说明 void add(int index,E element) 在此集合中的指定位置插入指定的元素 E remove(int index) 删除指定索引处的元素，返回被删除的元素 E set(int index,E element) 修改指定索引处的元素，返回被修改的元素 E get(int index) 返回指定索引处的元素 ArrayList、LinekdList：有序、可重复、有索引\nArrayList底层是基于数组存储数据的 数组的特点\n查询速度快（注意：是根据索引查询数据快）：查询数据通过地址值和索引定位，查询任意数据耗时相同。\n增删数据效率低：可能需要把后面很多的数据进行前移。\n第一次创建的时候是创建一个空数组，第一次添加的时候才扩容为初始大小为10的数组，二次添加后，会添加成之前的1.5倍\nLinkedList底层是基于链表存储数据的 链表的特点\n链表中的数据是一个一个独立的结点组成的，结点在内存中是不连续的，每个结点包含数据值和下一个结点的地址。是基于双链表实现的，特点：对首尾元素进行增删改查的速度是极快的，占用的内存更多\nLinkedList新增了：很多首尾操作的特有方法。\n链表的特点1：查询慢，无论查询哪个数据都要从头开始找。\n链表的特点2：链表增删相对快\n只需要一个的对象可以用static修饰\nSet系列集合：添加的元素是无序、不重复、无索引 HashSet： 无序、不重复、无索引\nLinkedHashSet： 有序、不重复、无索引\nTreeSet：按照大小默认升序排序、不重复、无索引\nMap-双列集合 每个元素包含两个值（键值对）\n","permalink":"https://wqnm1gb.github.io/posts/day11-%E5%BC%82%E5%B8%B8%E6%B3%9B%E5%9E%8B%E5%92%8C%E9%9B%86%E5%90%88/","summary":"\u003ch2 id=\"异常\"\u003e异常\u003c/h2\u003e\n\u003ch3 id=\"error\"\u003eError\u003c/h3\u003e\n\u003cp\u003eError 代表的系统级别错误（属于严重问题），也就是说系统一旦出现问题，sun公司会把这些问题封装成Error对象给出来（说白了，Error是给sun公司自己用的，不是给我们程序员用的，因此我们开发人员不用管它）\u003c/p\u003e","title":"Day11 异常、泛型和集合"},{"content":"ArrayList集合 数组定义完成并且启动后，长度就固定了\n集合大小可变，功能丰富，开发中用的更多\n要用泛型定义集合\n构造器 说明 public ArrayList() 创建一个空的集合对象 常用方法名 说明 public boolean add(E e) 将指定的元素添加到此集合的末尾 public void add(intindex,E element) 在此集合中的指定位置插入指定的元素 public E get(int index) 返回指定索引处的元素 public int size() 返回集合中的元素的个数 public E remove(int index) 删除指定索引处的元素，返回被删除的元素 public boolean remove(Object o) 删除指定的元素，返回删除是否成功 public E set(intindex,E element) 修改指定索引处的元素，返回被修改的元素 ","permalink":"https://wqnm1gb.github.io/posts/day10-arraylist%E9%9B%86%E5%90%88/","summary":"\u003ch2 id=\"arraylist集合\"\u003eArrayList集合\u003c/h2\u003e\n\u003cp\u003e数组定义完成并且启动后，长度就固定了\u003c/p\u003e\n\u003cp\u003e集合大小可变，功能丰富，开发中用的更多\u003c/p\u003e\n\u003cp\u003e要用泛型定义集合\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e\u003c!-- raw HTML omitted --\u003e构造器\u003c!-- raw HTML omitted --\u003e\u003c/th\u003e\n          \u003cth\u003e\u003c!-- raw HTML omitted --\u003e说明\u003c!-- raw HTML omitted --\u003e\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003epublic \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eArrayList\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e()\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003e创建一个空的集合对象\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e\u003c!-- raw HTML omitted --\u003e常用方法名\u003c!-- raw HTML omitted --\u003e\u003c/th\u003e\n          \u003cth\u003e\u003c!-- raw HTML omitted --\u003e说明\u003c!-- raw HTML omitted --\u003e\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003epublic \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eboolean\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e add(E e)\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003e将指定的元素添加到此集合的末尾\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003epublic void add(\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eint\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eindex,E\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e element)\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003e在此集合中的指定位置插入指定的元素\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003epublic E get(\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eint\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e index)\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003e返回指定索引处的元素\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003epublic \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eint\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e size()\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003e返回集合中的元素的个数\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003epublic E remove(\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eint\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e index)\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003e删除指定索引处的元素，返回被删除的元素\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003epublic \u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eboolean\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e remove(Object o)\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003e删除指定的元素，返回删除是否成功\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003epublic E set(\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eint\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003eindex,E\u003c!-- raw HTML omitted --\u003e\u003c!-- raw HTML omitted --\u003e element)\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c!-- raw HTML omitted --\u003e修改指定索引处的元素，返回被修改的元素\u003c!-- raw HTML omitted --\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e","title":"Day10 ArrayList集合"},{"content":"函数式编程 此“函数”类似于数学中的函数（强调做什么），只要输入的数据一致返回的结果也是一致的\n可以用于替代某些匿名内部类对象，从而让程序更简洁，可读性更好。\n(被重写方法的形参列表) -\u0026gt;{ 被重写方法的方法体代码 } 注意：Lambda表达式只能替代函数式接口的匿名内部类！！！\n什么是函数式接口：只有一个抽象方法的接口\n@FunctionInterface 专门用来声明函数式接口\nLambda表达式的省略规则 • 作用：用于进一步简化Lambda表达式的写法。\n具体规则\n1、参数类型全部可以省略不写。\n2、如果只有一个参数，参数类型省略的同时“（）”也可以省略，但多个参数不能省略（）”\n3、如果Lambda表达式中只有一行代码，大括号可以不写，同时要省略分号“；”如果这行代码是return\n语句，也必须去掉return。\n方法引用 静态方法引用 类名::静态方法\n使用场景\n如果某个Lambda表达式里只是调用一个静态方法，并且“-\u0026gt;”前后参数的形式一致，就可以使用静态方法引用。\nArrays.sort(students,Student::compare); 实例方法引用 对象名::实例方法。\n使用场景\n如果某个Lambda表达式里只是通过对象名称调用一个实例方法，并且“-\u0026gt;”前后参数的形式一致，就可以\n使用实例方法引用。\n特定类的方法引用 特定类的名称：方法\n使用场景\n如果某个Lambda表达式里只是调用一个特定类型的实例方法，并且前面参数列表中的第一个参数是作为方法的主调，后面的所有参数都是作为该实例方法的入参的，则此时就可以使用特定类型的方法引用。\n构造器引用 类名::new\n使用场景\n如果某个Lambda表达式里只是在创建对象，并且“-\u0026gt;”前后参数情况一致，就可以使用构造器引用。\nString类 String代表字符串，它的对象可以封装字符串数据，并提供了很多方法完成对字符串的处理。\n创建对线的区别\n只要是以\u0026quot;..\u0026ldquo;方式写出的字符串对象，会存储到字符串常量池，且相同内容的字符串只存储一份（节约内存）；\n通过new方式创建字符串对象，每new一次都会产生一个新的对象放在堆内存中。\n字符串对象的内容比较不要用==号，==号默认比较的是地址，字符串对象的内容一样时地址不一定一样\n建议使用String提供的equals方法，只关心内容，不关心地址\nsc.next()用来接收字符串对象\nString创建字符串对象的方式 构造器 说明 public String() 创建一个空白字符串对象，不含有任何内容 public String(String original) 根据传入的字符串内容，来创建字符串对象 public String(char[] chars) 根据字符数组的内容，来创建字符串对象 public String(byte[] bytes) 根据字节数组的内容，来创建字符串对象 String提供的常用方法 方法名 说明 public int length() 获取字符串的长度返回（就是字符个数） public char charAt(int index) 获取某个索引位置处的字符返回 public char[] toCharArray()： 将当前字符串转换成字符数组返回 public boolean equals(Object anObject) 判断当前字符串与另一个字符串的内容一样，一样返回true public booleanequalsIgnoreCase(String anotherString) 判断当前字符串与另一个字符串的内容是否一样(忽略大小写) public String substring(int beginIndex, int endIndex) 根据开始和结束索引进行截取，得到新的字符串（包前不包后，索引从0开始） public String substring(int beginIndex) 从传入的索引处截取，截取到末尾，得到新的字符串返回 public String replace(CharSequence target, CharSequence replacement) 使用新值，将字符串中的旧值替换，得到新的字符串 public boolean contains(CharSequence s) 判断字符串中是否包含了某个字符串 public booleanstartsWith(String prefix) 判断字符串是否以某个字符串内容开头，开头返回true，反之 public String[] split(String regex) 把字符串按照某个字符串内容分割，并返回字符串数组回来 ","permalink":"https://wqnm1gb.github.io/posts/day09-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E5%92%8Cstring%E7%B1%BB/","summary":"\u003ch2 id=\"函数式编程\"\u003e函数式编程\u003c/h2\u003e\n\u003cp\u003e此“函数”类似于数学中的函数（强调做什么），只要输入的数据一致返回的结果也是一致的\u003c/p\u003e\n\u003cp\u003e可以用于替代某些匿名内部类对象，从而让程序更简洁，可读性更好。\u003c/p\u003e","title":"Day09 函数式编程、方法引用和String类"},{"content":"接口 Java提供了一个关键字interface定义出接口\nJDK8之前，接口只能定义常量和抽象方法\n接口中定义常量，可以省略public static final不写，默认会加上去\n接口中定义方法，可以省略public abstract不写，默认会加上去\n注意：接口不能创建对象\n接口是用采被类实现（implements）的，买现接口的类称为买现类， 一个类可以同时实现**多个**接口（多实现）。\n实现类实现了多个接口，必须重写完全部接口的全部抽象方法，否则这个类要定义为抽象类\n接口的好处 弥补了类单继承的不足，一个类同时可以实现多个接口，使类的角色更多，功能更强大。\n让程序可以面向接口编程，这样程序员就可以灵活方便的切换各种业务实现（更利于程序的解耦合）\nJDK8开始接口新增了3种方法\n1、默认方法（普通实例方法）：必须加default修饰，默认会用public修饰。\n2、私有方法（JDK 9开始才支持的）私有的实例方法。如何调用？使用接口中的其他实例方法来调用它（间接调用）\n3、静态方法默认会用public修饰。如何调用？只能使用当前接口名来调用。\n类必须extend在前，implement在后\n接口的注意事项 1、接口与接口可以多继承：一个接口可以同时继承多个接口［重点］。\n类与类：单继承 一个类只能继承一个直接父类\n类与接口：多实现，一个类可以同时实现多个接口。\n接口与接口：多继承，一个接口可以同时继承多个接口（用的是extends关键字）。\n2、一个接口继承多个接口，如果多个接口中存在方法签名冲突，则此时不支持多继承，也不支持多实现。\n4、一个类继承了父类，又同时实现了接口，如果父类中和接口中有同名的方法，实现类会优先用父类的。\n5、一个类实现了多个接口，如果多个接口中存在同名的默认方法，可以不冲突，这个类重写该方法即可。\n接口和抽象类的对比 相同点：\n1、都是抽象形式，都可以有抽象方法，都**不能创建对象****。**\n2、都是派生子类形式，抽象类是被子类继承使用，接口是被实现类实现。\n3、一个类继承抽象类，或者实现接口，都必须重写完他们的抽象方法，否则自己要成为抽象类或者报错！\n4、都能支持的多态，都能够实现解耦合。\n不同点：\n1、抽象类中可以定义类的**全部普通成员****，接口只能定义常量，抽象方法（JDK8新增的三种方式）**\n2、抽象类只能被类**单继承，接口可以被类多实现****。**\n3、一个类继承抽象类就不能再继承其他类，一个类实现了接口还可以继承其他类或者实现其他接口。\n4、抽象类体现**模板思想****：更利于做父类，实现代码的复用性。最佳实践**\n5、接口更适合**做功能的解耦合****：解耦合性更强更灵活。 最佳实践**\n代码块 代码块是类的5大成分之一（成员变量、构造器、方法、代码块、内部类）\n静态代码块 格式：static{}\n特点：类加载时自动执行，由于类只会加载一次，所以静态代码块也只会执行一次。\n作用：完成类的初始化，例如：对静态变量的初始化赋值。\n比如说给静态数组赋值\nArrarys.toString(数组名) //返回数组的内容\n实例代码块： 格式：{}\n特点：属于对象，每次创建对象时，执行实例代码块，并在构造器前执行。\n作用：和构造器一样，都是用来完成对象的初始化的例如：对实例变量进行初始化赋值。\n内部类 如果一个类定义在另一个类的内部，这个类就是内部类。\n场景：当一个类的内部，包含了一个完整的事物，且这个事物没有必要单独设计时，就可以把这个事物设计成内部类。\n成员内部类 就是类中的一个普通成员，类似前面我们学过的普通的成员变量、成员方法。\n成员内部类：无stati修饰，属于外部类的对象持有的。\n外部类名.内部类名 对象名=new 外部类(\u0026hellip;).new 内部类(..)；\n成员内部类中访问其他成员的特点：\n1、成员内部类种可以直接访问外部类的实例成员、静态成员。\n2、成员内部类的实例方法中，可以直接拿到当前外部类对象，格式是：外部类名.this。\nclass OuterClass { private String outerField = \u0026#34;Outer Field\u0026#34;; class InnerClass { private String innerField = \u0026#34;Inner Field\u0026#34;; public void display() { // 访问内部类的成员 System.out.println(innerField); // 访问外部类的成员 外部类名.this System.out.println(OuterClass.this.outerField); } } } public class Test { public static void main(String[] args) { OuterClass outer = new OuterClass(); OuterClass.InnerClass inner = outer.new InnerClass(); inner.display(); } } 静态内部类 有static修饰的内部类，属于外部类自己持有。\n外部类名.内部类名 对象名=new 外部类.内部类(..)；\nOuter.Inner in = new Outer.Inner() ；\n可以直接访问外部类的静态成员，不能直接访问外部类的实例成员。\n匿名内部类 是一种特殊的局部内部类；\n所谓匿名：指的是程序员不需要为这个类声明名字，默认有个隐藏的名字。\n特点：匿名内部类本质就是一个子类，并会立即创建出一个子类对象。\n作用：用于更方便的创建一个子类对象。\n匿名内部类实际上是有名字：外部类名$编号.class\n匿名内部类在开发中的常见形式\n通常作为一个对象参数传输给方法。\n需求：学生，老师要参加游泳比赛。\n开发中不是我们要主动去写匿名内部类，而是用别人的功能的时候，别人可以让我们写一个匿名内部类吗，我们才会写！\npublic static void sort(T[] a, Comparator\u0026lt;T\u0026gt; c) 参数一：需要排序的数组 参数二： 需要给sort声明一个Comparator比较器对象（指定排序的规则） sort方法会调用匿名内部类对象的compare 方法 对数组中的学生对象进行两两比较从而实现排序 指定排序规则： 如果你认为左边对象 大于 右边对象 那么返回正整数。 如果你认为左边对象 小于 右边对象 那么返回负整数。 如果两边相等那么返回0。 // 调用排序的函数，用匿名内部类的方式实现 Arrays.sort(students, new Comparator\u0026lt;Student\u0026gt;() { @Override public int compare(Student o1, Student o2) { //规则是左边大于右边，返回正整数 // 左边小于右边，返回负整数 // 左边等于右边，返回0 // if(o1.getHight()\u0026gt;o2.getHight()){ // return 1; // }else if(o1.getHight()\u0026lt;o2.getHight()){ // return -1; // }else { // return 0; // } return (int) (o2.getHight()-o1.getHight()); } }); ","permalink":"https://wqnm1gb.github.io/posts/day08-%E6%8E%A5%E5%8F%A3%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/","summary":"\u003ch2 id=\"接口\"\u003e接口\u003c/h2\u003e\n\u003cp\u003eJava提供了一个关键字interface定义出接口\u003c/p\u003e\n\u003cp\u003eJDK8之前，接口只能定义常量和抽象方法\u003c/p\u003e\n\u003cp\u003e接口中定义常量，可以省略public static final不写，默认会加上去\u003c/p\u003e","title":"Day08 接口和面向对象编程"},{"content":"多态 有对象多态，行为多态\n编译看左，运行看右\n多态的前提 有继承/实现关系，存在父类引用子类对象，存在方法重写\n使用多态的好处 1、在多态形态下，右边对象是解耦合的，便于扩展和维护\n2、定义方法的时候，使用父类类型的形参，可以接收一切子类对象，扩展性更强，更便利\n多态产生的问题 不能调用子类独有的行为\n多态下的类型转换 可以解决多态下调用独有功能\n自动类型转换：父类 变量名 = new 子类();\nPeople p = new Teacher();\n强制类型转换：子类 变量名 = (子类)父类变量;\nTeacher t = (Teacher) p;\n注意事项 1、存在继承/实现关系就可以在编译阶段进行强制类型转换，编译阶段不会报错。\n2、运行时，如果发现对象的真实类型与强转后的类型**不同****，就会报类型转换异常（ClassCastException）的错误出来。**\n强制转换前，Java建议先判断对象的真实类型\np instanceof Student 会返回TRUE或FALSE\nfinal关键字 1、修饰类：该类称为最终类，不能再被继承（工具类）\n2、修饰方法：该方法称为最终方法，特点是不能被重写（下边的模板方法的设计模式）\n3、修饰变量：该变量有且仅能被赋值一次，第二次赋值会报错\n变量的类型\na.成员变量：\n静态成员变量\n实例成员变量\nb.局部变量\n使用final修饰后\na.成员变量：\n静态成员变量：这个变量今后被称为常量，可以记住一个固定值，并且在程序中不能修改了，通常这个值作为系统的配置信息（常量的名称建议全部大写，多个单词用下划线分隔）\n实例成员变量：一般没有意义\nb.局部变量\n注意事项\nfinal修饰**基本类型**的变量，变量存储的数据不能被改变。\nfinal修饰**引用类型的变量，变量存储的地址不能被改变，但地址所指向对象的内容是**可以被改变的。\nstatic和final的区别 final修饰的变量是不能再修改的\nstatic修饰的变量只强调加载一份，可以再修改\n常量 使用了 static final 修饰的成员变量就被称为常量.\n作用：常用于记录系统的配置信息。\n使用常量：代码可读性更好，可维护性也更好。\n程序编译后，常量会被“宏替换”：出现常量的地方全部会被替换成其记住的字面量，这样可以保证使用常量和直接用字面量的**性能是一样的****。（编译后的文件是.class文件，去out文件夹里边找）**\n单例类（设计模式） 什么是设计模式\n一个问题通常有n种解法，其中肯定有一种解法是最优的，这个最优的解法被人总结出来了，称之为设计模式。\n怎么学设计模式\n1、解决了什么问题 2、怎么写\n单例模式\n作用：确保某个类只能创建一个对象\n实现步骤\n1、把类的构造器私有化（确保单例类在外边不能创建太多的对象，单例才有了可能性）\n2、定义一个类变量记住类的一个对象\n3、定义一个类方法，返回对象\n饿汉式单例：用对象时，对象已经创建好了\n懒汉式单例：用对象时，才开始创建对象\n枚举类 枚举类是一种特殊的类\n枚举类的写法\n修饰符 enum 枚举类名{ 名称1,名称2,名称3; 其他成员... } 1、枚举都是**最终类****，不可以被继承，枚举类都是继承java.lang.Enum类的。**\n2、枚举类的第一行只能罗列一些名称，这些名称都是常量，并且每个常量会记住枚举类的一个对象。\n**3、枚举类的构造器都是私有的（写不写都只能是私有的），因此，枚举类对外不能创建对象。所以枚举类是多例模式 **\n4、编译器为枚举类新增了几个方法。\n枚举适合做信息的标志和分类\n抽象类 在Java中有一个关键字叫：abstract，它就是抽象的意思，可以用它修饰类、成员方法。\nabstract修饰类，这个类就是抽象类。\nabstract修饰方法，这个方法就是抽象方法（只能有方法签名，不能有方法体）\n抽象类的特点：\n1、抽象类中不一定要有抽象方法，有抽象方法的类必须是抽象类。\n2、类有的成员：成员变量、方法、构造器，抽象类都可以有。\n3、****抽象类最主要的特点：抽象类不能创建对象，仅作为一种特殊的父类，让子类继承并实现。\n抽象类的使命就是被继承\n4、一个类继承抽象类，必须重写完抽象类的全部抽象方法，否则这个类也必须定义成抽象类。\n**抽象方法不能使用private修饰 **\n抽象类的好处 父类知道每个子类都要做某个行为，但每个子类要做的情况不一样，父类就定义成抽象方法，交给子类去重写实现， 我们设计这样的抽象类，就是为了更好的支持多态（原因是如果不用抽象类定义方法，那么会多写无用的代码，如果不写，会无法实现多态）。\n模板方法设计模式 提供一个方法作为完成某类功能的模板，模板方法封装了每个实现步骤，但允许子类提供特定步骤的实现。\n模板方法设计模式可以：提高代码的复用、并简化子类设计。\n写法\n1、定义一个抽象类。\n2、在里面定义2个方法\n3、一个是模板方法：把共同的实现步骤放里面去。\n4、一个是抽象方法：不确定的实现步骤，交给具体的子类来完成。\n建议使用final关键字修饰模板方法，为什么？\n模板方法是给子类直接使用的，不能被子类重写。一旦子类重写了模板方法，模板方法就失效了。\n","permalink":"https://wqnm1gb.github.io/posts/day07-%E5%A4%9A%E6%80%81%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/","summary":"\u003ch2 id=\"多态\"\u003e多态\u003c/h2\u003e\n\u003cp\u003e有对象多态，行为多态\u003c/p\u003e\n\u003cp\u003e\u003c!-- raw HTML omitted --\u003e编译看左，运行看右\u003c!-- raw HTML omitted --\u003e\u003c/p\u003e\n\u003ch3 id=\"多态的前提\"\u003e多态的前提\u003c/h3\u003e\n\u003cp\u003e有\u003c!-- raw HTML omitted --\u003e继承/实现\u003c!-- raw HTML omitted --\u003e关系，存在父类引用子类对象，存在\u003c!-- raw HTML omitted --\u003e方法重写\u003c!-- raw HTML omitted --\u003e\u003c/p\u003e","title":"Day07 多态和面向对象编程"},{"content":" 不仅会退出循环，还会结束整个方法的执行\n比如说匹配id的时候，找到id就直接退出方法，没找到id的话在循环语句后边还会有一个没找到id的提示\n子类能继承父类的非私有成员（成员变量，成员方法）如果定义的变量是私有的，那么能继承公有的get，set方法\n子类对象是由子类和父类多张设计图共同创建出来的对象，所以子类对象是完整的\nprivate 只能本类 缺省 本类，同一个包中的类 protected 本类，同一个包中的类，子孙类中 public 任意位置 private\u0026lt;缺省\u0026lt;protected\u0026lt;public\n**java为什么不支持多继承 **\njava中的祖宗类object\njava中的所有类，要么直接继承object，要么默认继承object，要么间接继承object\n如果子类中，出现了重名的成员，会优先使用子类的，如果此时一定要使用父类的，需要加上super关键字\nJava的多个类中有且仅有一个可以用public修饰\n重写的时候会加上 @Override 在上边，这是方法重写的校验注解（标志），要求方法名称和形参列表必须与被重写的方法一致，否则报错\n优点：更安全，更易读\n注意事项\n1、子类方法重写时候，访问权限一定要大于等于父类方法的权限（public\u0026gt;protected\u0026gt;缺省）\n2、重写方法的返回值类型，必须与父类的返回值类型一样或者范围更小\n3、私有方法，静态方法不能被重写，如果重写会报错（原因是子类只能继承非私有的成员，所以不能重写）\n直接输出对象，会调用对象的toString()方法，返回对象的地址信息\n具体是调用父类的有参还是无参由自己决定，如果不管，默认调用无参，如果没有无参，需要自己写一个有参\n如何实现调用父类的构造器的？\n默认情况下，子类构造器的第一行都是super();（写不写都有），会调用父类的无参构造器\n如果父类没有无参构造器，则子类构造器的第一行必须手写一个super()，去指定调用父类的有参构造器\nthis调用本类中的兄弟构造器\nthis的作用是，在构造器中调用本类的其他构造器\n注意，super()和this()必须写在构造器的第一行，而且两者不能同时出现\npublic class Person { private String name; private int age; // 第一个构造器 public Person(String name) { this(name, 20); // 调用第二个构造器 } // 第二个构造器 public Person(String name, int age) { this.name = name; this.age = age; } // 其他方法 public void display() { System.out.println(\u0026#34;Name: \u0026#34; + name + \u0026#34;, Age: \u0026#34; + age); } public static void main(String[] args) { Person p1 = new Person(\u0026#34;Alice\u0026#34;); p1.display(); // 输出: Name: Alice, Age: 20 Person p2 = new Person(\u0026#34;Bob\u0026#34;, 30); p2.display(); // 输出: Name: Bob, Age: 30 } } ","permalink":"https://wqnm1gb.github.io/posts/day06-%E7%BB%A7%E6%89%BF/","summary":"\u003c!-- raw HTML omitted --\u003e\n\u003cp\u003e不仅会退出循环，还会\u003c!-- raw HTML omitted --\u003e结束整个方法的执行\u003c!-- raw HTML omitted --\u003e\u003c/p\u003e\n\u003cp\u003e比如说匹配id的时候，找到id就直接退出方法，没找到id的话在循环语句后边还会有一个没找到id的提示\u003c/p\u003e","title":"Day06 继承"},{"content":"","permalink":"https://wqnm1gb.github.io/posts/my-new-post/","summary":"","title":"My New Post"},{"content":"对象 对象是一种特殊的数据结构，可以用来记住一个事物的数据，从而代表该事物\n1、先设计一个对象的模板，也就是对象的设计图：类\n2、通过new关键字，每new一次就得到一个新的对象\n内存分成了栈内存，堆内存和方法区\n方法区存放类文件\nnew出来的东西叫做对象，会放在堆里边\n方法需要使用的时候，会被掉到栈内存中\n设计对象的关键就是设计类，对象的模板\n构造器 创建对象的时候，对象会自动的调用构造器\n常见应用场景\n构造器的作用： 创建对象时，同时完成对对象成员变量（属性）的初始化赋值、\n//构造器的语法 class Student{ public Student(){ //名字必须要和类名相同，可以带参数也可以不带参数，没有返回值 } } 构造器的注意事项 1、类默认就带了一个无参构造器\n2、如果类定义了有参构造器，类默认的无参构造器就没有了，此时如果还想用无参构造器，就要自己手写一个无参构造器\nthis关键字 this就是一个变量，可以用在方法中，来拿到当前对象（拿的对象地址）\n哪个对象调用这个方法，this就拿到哪个对象\n**this对象主要用来解决：****变量名称冲突**的问题\n成员变量与方法内部变量的名称一样的时候，导致的命名冲突的问题\n封装 面向对象的三大特征：封装，继承，多态\n类，方法就是一种封装\n封装的设计要求\n合理隐藏，合理暴露\n如何隐藏：使用private关键字进行修饰成员变量，就只能在本类中被直接访问，其他任何地方不能直接访问\n如何暴露： 使用public修饰的get和set方法合理暴露成员变量的取值和\nJavabean（实体类） 是一种特殊类，满足下列要求\n1、类中的成员变量全是私有的，并且提供public修饰的getter和setter方法\n2、需要提供一个无参数的构造器，有参数的可选\n实体类的基本作用：创建他的新对象，存取数据（封装数据）\n实体类的应用场景：\n实体类的对象只负责数据的存取，而不负责数据的处理，数据的处理交给其他类的对象来完成，已实现数据和业务处理相分离\nstatic关键字 static修饰变量 可以用来修饰成员变量和成员方法\n类在运行的时候只会被加载一次\n成员变量按照有无static修饰可以分成两种：\n1、静态变量（类变量）：有static修饰属于类，在计算机中只有一份，会被全部对象共享，以最后的改动为准\n2、实例变量（对象的变量）（实例就是对象，对象就是实例（实例化之后就会占用内存） ，类是比他们高一个等级的抽象概念（不占用内存））：无static修饰，属于每个对象的\n推荐访问静态变量的方式\n类名.静态变量（推荐）\n实例名.静态变量（不推荐）\n静态变量的应用场景\n**如果某个数据只需要一份，且希望能够被共享（访问、修改），则该数据可以定义成静态变量来记住 **\n同一个类中，访问静态成员，可以省略类名不写\nstatic修饰方法 静态方法：有static修饰的成员方法，属于类持有\n实例方法：无static修饰的成员方法，属于对象\n如果这个方法只是为了做一个功能并且不需要直接访问对象的数据，这个方法直接定义为静态方法\n如果这个方法是对象的行为，需要访问对象的数据，这个方法必须定义为实例方法\n常见应用场景：做工具类，工具类中的所有方法都是一些静态方法，每一个方法来完成一个功能\n使用工具类的好处：提高代码复用，调用方便，提高了开发效率，不会占用内存\n工具类没有必要创建对象，可以把构造器进行私有化\npublic class Tools{ private Tools(){ //别人无法创建这个类 } } public修饰和没有关键字修饰（只能用这两种修饰符来修饰类） public修饰符 类级别: 如果一个类被声明为 public，它可以被任何地方访问，无论是在同一个包内还是其他包中，只要导入了该类所在的包。\n方法/字段级别: 如果类的成员（方法或字段）被声明为 public，那么任何类都可以访问这些成员，无论它们位于哪个包。\n没有修饰符（Package-private） **类级别: **如果一个类没有使用任何修饰符（即默认情况下），它只能在同一个包内访问。其他包中的类无法访问这个类，即使它们导入了该包。\n方法/字段级别: 如果类中的方法或字段没有使用访问修饰符，它们只能在同一个包内访问，而不能被其他包中的类访问。\n静态方法，实例方法的注意事项 1、静态方法中可以**直接访问静态成员****， 不可以直接访问实例成员**\n2、实例方法中既可以直接访问静态成员，也可以直接访问实例成员\n3、实例方法中可以出现this关键字，静态方法中**不可以出现this关键字**\n","permalink":"https://wqnm1gb.github.io/posts/day05-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/","summary":"\u003ch2 id=\"对象\"\u003e对象\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e对象是一种特殊的数据结构，可以用来记住一个事物的数据，从而代表该事物\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e1、先设计一个对象的模板，也就是对象的设计图：类\u003c/p\u003e\n\u003cp\u003e2、通过new关键字，每new一次就得到一个新的对象\u003c/p\u003e","title":"Day05 面向对象编程"},{"content":" ","permalink":"https://wqnm1gb.github.io/posts/testpicture/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://cdn.nlark.com/yuque/0/2024/png/28219979/1728611073038-cdcb6289-b485-4060-9727-8c3732d22bfe.png\" alt=\"\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/image.png\" alt=\"\"  /\u003e\n\u003c/p\u003e","title":"testPicture"},{"content":"无限循环 无限循环下边不能再写其他的代码了，因为执行不到了\n//for格式的无限循环 for(;;){ } //while格式的无限循环 while(true){ } continue和break continue：跳过本次循环，继续执行下次循环\nbreak：结束整个循环\nRandom类 使用步骤：\nimport java.util.Random; Random r = new Random(); int num = r.nextInt(随机数范围); int num = r.nextInt(100);//0~99内取值 //生成任意随机数的方法 //例如我要生成1~100的随机数 //先把左边的范围变成0，然后通过加法补上 //例如要生成1~100之间的随机数 import java.util.Random; Random r = new Random(); //首先生成0~99的数字，然后再+1，变成1~100 int num = r.nextInt(100)+1; 随机数的范围，包头不包尾，包左不包右\n0-100 包括0但是不包括100\n数组 数组：是一种容器，可以存储同种数据类型的多个值\n完整格式：数据类型[] 数组名 = new 数据类型[]{元素1,元素2,元素3\u0026hellip;};\nint[] array = new int[]{11,22,33} //简化格式 int[] arrary = {11,22,33}; array.length可以快速的获取数组的长度\n二维数组中的每一个数据都是一个一维数组\nfor-each循环 public class TestArray { public static void main(String[] args) { double[] myList = {1.9, 2.9, 3.4, 3.5}; // 打印所有数组元素 for (double element: myList) { System.out.println(element); } } } 数组的动态初始化和静态初始化 静态初始化：初始化的时候直接赋值\n动态初始化：初始化的时候只指定数组的长度，由系统为数组分配初始值\nint[] array = new int[3]; 数组默认初始化值的规律\n1、整数类型：默认初始化值是0\n2、小数类型：默认初始化值是0.0\n3、字符类型：默认初始化值是\u0026rsquo;/u0000\u0026rsquo; 显示出来是一个空格\n4、布尔类型：默认初始化值是FALSE\n5、引用数据类型：默认初始化值是null\n换行输出和不换行输出 System.out.print(\u0026#34;这是不换行输出\u0026#34;); System.out.println(\u0026#34;这是换行输出\u0026#34;); 拆分数字 12345这个四位数\n拆分 12345%10=5 12345/10=1234 1234%10=4 1234/10=123 123%10=3 123/10=12 12%10=2 12/10=1 1%10=1 1/10=0 //循环结束 组合 //组合是从高位向低位组合，比如说给出的是1，2，3，4这样的顺序 sum=0; sum = 1 + sum*10; //sum=1 sum = 2 + sum*10;//sum=12 sum = 3 + sum*10//sum=123 方法 方法：是程序中最小的执行单元\n要么全都一起执行，要么全都不执行\n要先定义后调用\n方法的定义和调用 无参数无返回值的方法 定义： public static void 方法名(){ 方法体; } 调用： 方法名(); 带参数无返回值的方法 定义： public static void 方法名(类型 参数1,类型 参数2，,...){ //形参 方法体; } 调用： 方法名(参数1,参数2); //实参 带参数带返回值的方法 定义： public static 返回值类型 方法名(类型 参数1,类型 参数2，,...){ //形参 方法体; return 返回值; } 调用： 直接调用 方法名(参数1,参数2); //实参 赋值调用 整数类型 变量名= 方法名（实参）; 输出调用 System.out.println(方法名(实参)); ","permalink":"https://wqnm1gb.github.io/posts/day04-%E6%95%B0%E7%BB%84%E5%92%8C%E6%96%B9%E6%B3%95/","summary":"\u003ch2 id=\"无限循环\"\u003e无限循环\u003c/h2\u003e\n\u003cp\u003e无限循环下边不能再写其他的代码了，因为执行不到了\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e//for格式的无限循环\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003efor\u003c/span\u003e\u003cspan class=\"p\"\u003e(;;){\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"c1\"\u003e//while格式的无限循环\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003ewhile\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kc\"\u003etrue\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"continue和break\"\u003econtinue和break\u003c/h2\u003e\n\u003cp\u003econtinue：跳过本次循环，继续执行下次循环\u003c/p\u003e\n\u003cp\u003ebreak：结束整个循环\u003c/p\u003e\n\u003ch2 id=\"random类\"\u003eRandom类\u003c/h2\u003e\n\u003cp\u003e使用步骤：\u003c/p\u003e","title":"Day04 数组和方法"},{"content":"if的注意点 1、在语句中，如果只有一句代码，那么大括号可以省略不写\nint a = 100; //这不算是一句代码，算是两句代码，一句是定义变量a，另一句是赋值 2、如果对一个布尔类型的变量进行判断，不要使用==号，直接把变量写在小括号中\nswitch语句 switch (表达式){ case 值1: //case后边的值只能是字面量，不能是变量 语句体1; break; case 值2: 语句体2; break; ... default: 语句体n+1; break; } default可以省略，语法不会有问题，但是不建议省略，default可以放在程序的任意位置\ncase穿透，语句体中没有写break导致的\n如果匹配上了，就会执行对应的语句体，如果此时发现了break，那么结束switch语句，如果没有发现break，那么程序就会继续执行下一个case语句，一直到遇到break或者右大括号为止\n如果多个case的语句体重复了，那么我们考虑用case穿透去简化代码\nif else一般是对范围的判断\nswitch 把有限个数据一一列举出来，让我们任选其一\n循环语句 100.fori 可以快速的写出循环100次的\nfor和while的区别 for循环中，控制循环的变量（变量i），归属于for循环的语法结构中，在for循环结束之后，就不能再次访问了（但是改写之后，可以改变这个规则）\nwhile循环中，控制循环的变量（变量i），不归属于while的循环结构中，在while循环结束之后，该变量还能继续访问\nfor循环一般知道循环的次数和范围\nwhile循环不知道次数和范围，但是知道结束条件\n","permalink":"https://wqnm1gb.github.io/posts/day03-%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/","summary":"\u003ch2 id=\"if的注意点\"\u003eif的注意点\u003c/h2\u003e\n\u003cp\u003e1、在语句中，如果只有一句代码，那么大括号可以省略不写\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e100\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"c1\"\u003e//这不算是一句代码，算是两句代码，一句是定义变量a，另一句是赋值\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e2、如果对一个布尔类型的变量进行判断，不要使用==号，直接把变量写在小括号中\u003c/p\u003e\n\u003ch2 id=\"switch语句\"\u003eswitch语句\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eswitch\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003e表达式\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"k\"\u003ecase\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e值1\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e         \u003c/span\u003e\u003cspan class=\"c1\"\u003e//case后边的值只能是字面量，不能是变量\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"n\"\u003e语句体1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003ebreak\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"k\"\u003ecase\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e值2\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"n\"\u003e语句体2\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003ebreak\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e...\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"k\"\u003edefault\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"n\"\u003e语句体n\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"n\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"k\"\u003ebreak\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003edefault可以省略，语法不会有问题，但是不建议省略，default可以放在程序的任意位置\u003c/p\u003e","title":"Day03 循环语句"},{"content":" 1、基本数据类型\n数据类型 关键字 整数 byte 1 short 2 int 4 long 8在数据值后边加一个L作为后缀，建议使用大写的L 浮点数 float 4数据值后边也需要加一个F作为后缀 double 8 字符 char 2 布尔 boolean 1 整数和小数取值范围大小关系：\n2、引用数据类型\n之后补充\n硬性要求：1、由数字，字母，下划线和美元符号($)组成 2、不能以数字开头 3、不能是关键字 4、区分大小写\n软性建议：\n小驼峰命名法：方法、变量\n1、标识符是一个单词的时候，全部小写\n2、标识符由多个单词组成的时候，第一个单词首字母小写，其他单词首字母大写\n大坨峰命名方法：类名\n1、标识符是一个单词的时候，首字母大写\n2、标识符由多个单词组成的时候，每个单词首字母大写\nproject（项目）\nmodule（模块）\npackage（包）\nclass（类）\n加，减，乘，除，取模\n在代码中，如果有小数参与运算，结果可能不精确\n整数参与计算，结果只能得到整数\n1.1小的会先提升为大的，在进行运算\n1.2byte，short和char三种数据类型在进行运算的时候，都会直接先提升为int，然后再进行运算\nbyte a = 10; byte b = 20; c = a + b;//此时的c是int类型 适用于规则1.2 取值范围\nbyte \u0026lt; short \u0026lt; int \u0026lt; long \u0026lt; float \u0026lt;double\n2、强制转换，取值范围大的变成取值范围小的\n要强制转换的是最终的结果\n如果我想把c定义为byte型\nbyte c = a + b //报错 byte c = (byte)a + b //报错，相当于强制转换a byte c = (byte)a + (byte)b //报错，相当于强制转换a和b，并不是转换最后的结果 byte c = (byte)(a + b) //正确 在+的过程中，只要有字符串参与，做的都会是拼接的操作\n连续+从左到右依次+\n+=，-=，*=，/=，%=底层都隐藏了一个强制类型转换\nshort s = 1; s + = 1; //等同于 s = (short)(s+1); 比如第一个不满足了就直接不满足，右边的语句就不会运行了\n|| 短路非 结果与|相同，但是有短路效果\n比如第一个满足了就全满足，右边的语句就不会运行了\n注意事项\n\u0026amp;|，无论左边是TRUE还是FALSE，右边都要执行\n\u0026amp;\u0026amp; || ，如果左边能确定表达式的结果，右边不执行\n关系表达式？表达式1:表达式2\n如果关系表达式是真，那么就使用表达式1，如果为假，那就使用表达式2\n使用的时候的方法是，max = a\u0026gt;b?a:b //把a，b中的最大值赋给max\noption+command+L 会自动格式化代码\n","permalink":"https://wqnm1gb.github.io/posts/day02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/","summary":"\u003c!-- raw HTML omitted --\u003e\n\u003cp\u003e1、基本数据类型\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e数据类型\u003c/th\u003e\n          \u003cth\u003e关键字\u003c/th\u003e\n          \u003cth\u003e\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e整数\u003c/td\u003e\n          \u003ctd\u003ebyte\u003c/td\u003e\n          \u003ctd\u003e1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c/td\u003e\n          \u003ctd\u003eshort\u003c/td\u003e\n          \u003ctd\u003e2\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c/td\u003e\n          \u003ctd\u003eint\u003c/td\u003e\n          \u003ctd\u003e4\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c/td\u003e\n          \u003ctd\u003elong\u003c/td\u003e\n          \u003ctd\u003e8\u003c!-- raw HTML omitted --\u003e在数据值后边加一个L作为后缀，建议使用大写的L\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e浮点数\u003c/td\u003e\n          \u003ctd\u003efloat\u003c/td\u003e\n          \u003ctd\u003e4\u003c!-- raw HTML omitted --\u003e数据值后边也需要加一个F作为后缀\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c/td\u003e\n          \u003ctd\u003edouble\u003c/td\u003e\n          \u003ctd\u003e8\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e字符\u003c/td\u003e\n          \u003ctd\u003echar\u003c/td\u003e\n          \u003ctd\u003e2\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e布尔\u003c/td\u003e\n          \u003ctd\u003eboolean\u003c/td\u003e\n          \u003ctd\u003e1\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e整数和小数取值范围大小关系：\u003c/p\u003e","title":"Day02 数据类型和运算符"},{"content":"cmd默认操作的是用户命名的文件夹（C:\\users\\用户名）\n盘符名称 + : 能够切换到这个盘符\ndir 查询该目录下的所有文件\nwindow下的文件分隔符是\\ 注意与Linux下的/ 不同\ncls 是清屏命令\nexit 是关闭窗口命令\njava目录 bin中存放了各种工具命令\nJDK java的开发工具 里边包含了 JVM+核心类库+开发工具\nJRE java的运行环境 里边包含了 JVM+核心类库+运行工具\n多行注释是 /* */\n文档注释是/** **/\nJava会先找到main语句，从main开始运行\njavac用于编译\njava用于运行\n类是Java最基本的组成单元\n空类型的null不能直接打印\n在打印的时候，把前边字符串的长度补齐到8，或者8的整数倍，最少补1个空格，最多补8个空格\n用处：打印类似表格数据的时候，让数据对齐\n2、变量名不允许被重复定义\n3、一条语句可以定义多个变量\n4、变量在使用之前一定要进行赋值\n5、变量的作用范围\n十进制：前边不加任何前缀\n八进制：代码中以0开头\n十六进制：代码中以0x开头\n","permalink":"https://wqnm1gb.github.io/posts/day01-java%E5%9F%BA%E7%A1%80/","summary":"\u003cp\u003ecmd默认操作的是用户命名的文件夹（C:\\users\\用户名）\u003c/p\u003e\n\u003cp\u003e盘符名称 + : 能够切换到这个盘符\u003c/p\u003e\n\u003cp\u003edir 查询该目录下的所有文件\u003c/p\u003e\n\u003cp\u003ewindow下的文件分隔符是\\ 注意与Linux下的/ 不同\u003c/p\u003e","title":"Day01 Java基础"},{"content":"Hello World！ ","permalink":"https://wqnm1gb.github.io/posts/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","summary":"\u003ch1 id=\"hello-world\"\u003eHello World！\u003c/h1\u003e","title":"我的第一篇博客"},{"content":"个人学习博客\n","permalink":"https://wqnm1gb.github.io/about/","summary":"about","title":"关于"}]