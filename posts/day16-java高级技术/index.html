<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Day16 Java高级技术 | 三狗子的博客</title>
<meta name=keywords content="java基础"><meta name=description content="单元测试
就是针对最小的功能单元：方法，编写测试代码对其进行正确性测试。
咱们之前是如何进行单元测试的？有啥问题？
• 只能在main方法编写测试代码，去调用其他方法进行测试。"><meta name=author content="冷漠三狗子丶"><link rel=canonical href=https://wqnm1gb.github.io/posts/day16-java%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/><link crossorigin=anonymous href=/assets/css/stylesheet.3d688279d829dc24da48acd11f9e33ebea2f39c035e899e1bf4297d8b7aa89b9.css integrity="sha256-PWiCedgp3CTaSKzRH54z6+ovOcA16Jnhv0KX2Leqibk=" rel="preload stylesheet" as=style><link rel=icon href=https://wqnm1gb.github.io/images/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://wqnm1gb.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wqnm1gb.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wqnm1gb.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://wqnm1gb.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://wqnm1gb.github.io/posts/day16-java%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel=stylesheet><script type=text/javascript async src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["[[","]]"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=" has-jax"})</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style><meta property="og:title" content="Day16 Java高级技术"><meta property="og:description" content="单元测试
就是针对最小的功能单元：方法，编写测试代码对其进行正确性测试。
咱们之前是如何进行单元测试的？有啥问题？
• 只能在main方法编写测试代码，去调用其他方法进行测试。"><meta property="og:type" content="article"><meta property="og:url" content="https://wqnm1gb.github.io/posts/day16-java%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/"><meta property="og:image" content="https://wqnm1gb.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-02-08T10:47:42+08:00"><meta property="article:modified_time" content="2025-02-08T10:47:42+08:00"><meta property="og:site_name" content="三狗子的博客"><meta property="fb:admins" content="your-facebook-admin-id"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wqnm1gb.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Day16 Java高级技术","item":"https://wqnm1gb.github.io/posts/day16-java%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Day16 Java高级技术","name":"Day16 Java高级技术","description":"单元测试 就是针对最小的功能单元：方法，编写测试代码对其进行正确性测试。\n咱们之前是如何进行单元测试的？有啥问题？\n• 只能在main方法编写测试代码，去调用其他方法进行测试。\n","keywords":["java基础"],"articleBody":"单元测试 就是针对最小的功能单元：方法，编写测试代码对其进行正确性测试。\n咱们之前是如何进行单元测试的？有啥问题？\n• 只能在main方法编写测试代码，去调用其他方法进行测试。\n• 无法实现自动化测试，一个方法测试失败，可能影响其他方法的测试。\n• 无法得到测试的报告，需要程序员自己去观察测试是否成功。\nJunit单元测试框架 可以用来对方法进行测试，它是第三方公司开源出来的（很多开发工具已经集成了Junit框架比如IDEA）\n优点\n• 可以灵活的编写测试代码，可以针对某个方法执行测试，也支持一键完成对全部方法的自动化测试，且各自独立。\n• 不需要程序员去分析测试的结果，会自动生成测试报告出来。\nJunit单元测试的使用步骤 需求\n• 某个系统，有多个业务方法，请使用Junit单元测试框架，编写测试代码，完成对这些方法的正确性测试。\n具体步骤\n① 将Junit框架的jar包导入到项目中（注意：IDEA集成了Junit框架，不需要我们自己手工导入了）\n② 为需要测试的业务类，定义对应的测试类，并为每个业务方法，编写对应的测试方法（必须：公共、无参、无返回值）\n③ 测试方法上必须声明@Test注解，然后在测试方法中，编写代码调用被测试的业务方法进行测试\n④ 开始测试：选中测试方法，右键选择“JUnit运行”，如果测试通过则是绿色；如果测试失败，则是红色\n反射 反射就是：加载类，并允许以编程的方式解剖类中的各种成分（成员变量、方法、构造器等）\nidea中能提示各种类里边的信息就是用了反射的方式\n获取class的三种方式 Class c1=类名.class // 1、方式1：Class c1=类名.class Class c1= Student.class; System.out.println(c1); 调用Class提供方法：public static Class forName（String package） // 2、方式2：调用Class提供方法：public static Class forName（String package） Class c2 = Class.forName(\"com.demo02Reflect.Student\"); System.out.println(c1==c2); Object提供的方法：public Class getClassO； Class c3 = 对象.getClassl // 3、方式3：使用对象.getClass() Student s = new Student(); Class c3 = s.getClass(); System.out.println(c3); 获取类中的构造器 反射的第一步都是拿到类\n方法 说明 Constructor[] getConstructors() 获取全部构造器（只能获取public修饰的） Constructor[] getDeclaredConstructors() 获取全部构造器（只要存在就能拿到，私有构造器也能拿到） Constructor getConstructor(Class… parameterTypes) 获取某个构造器（只能获取public修饰的） Constructor getDeclaredConstructor(Class… parameterTypes) 获取某个构造器（只要存在就能拿到） 获取类构造器的作用：依然是初始化对象返回 Constructor****提供的方法 说明 T newInstance(Object… initargs) 调用此构造器对象表示的构造器，并传入参数，完成对象的初始化并返回 public void setAccessible(boolean flag) 设置为true，表示禁止检查访问控制（暴力反射） @Test public void getConstructor() throws Exception { Class c1 = Dog.class; // 返回一个Constructor数组 Constructor[] cons = c1.getDeclaredConstructors(); for (Constructor con : cons) { System.out.println(con); } // 获取单个构造器，里边有String和Int变量的 Constructor con1 = c1.getDeclaredConstructor(String.class, int.class); System.out.println(con1); // 创建对象并且返回 Dog d1 = (Dog)con1.newInstance(\"小黑\", 2); System.out.println(d1); } 获取类中的成员变量 方法 说明 public Field[] getFields() 获取类的全部成员变量（只能获取public修饰的） public Field[] getDeclaredFields() 获取类的全部成员变量（只要存在就能拿到） public Field getField(String name) 获取类的某个成员变量（只能获取public修饰的） public Field getDeclaredField(String name) 获取类的某个成员变量（只要存在就能拿到） 获取到成员变量的作用：依然是赋值、取值\n方法 说明 void set(Object obj, Object value)： 赋值 Object get(Object obj)s 取值 public void setAccessible(boolean flag) 设置为true，表示禁止检查访问控制（暴力反射） @Test public void getField() throws Exception { // 获取成员变量 Class c1 = Dog.class; Field[] f1 = c1.getDeclaredFields(); for (Field f : f1) { System.out.println(f.getName()+\"(\"+f.getType().getName()+\")\"); } // 获取单个成员变量 Field f2 = c1.getDeclaredField(\"hobby\"); System.out.println(f2.getName()+\"(\"+f2.getType().getName()+\")\"); // 给成员变量赋值 Dog d1 = new Dog(\"小黑\", 2); // 因为hobby是私有变量，所以需要暴力反射 f2.setAccessible(true); // 需要拿到f2（变量对象），再拿到d1（对象），才能进行修改 f2.set(d1, \"看门\"); } 获取类中的成员方法 方法 说明 Method[] getMethods() 获取类的全部成员方法（只能获取public修饰的） Method[] getDeclaredMethods() 获取类的全部成员方法（只要存在就能拿到） Method getMethod(String name, Class… parameterTypes) 获取类的某个成员方法（只能获取public修饰的） Method getDeclaredMethod(String name, Class… parameterTypes) 获取类的某个成员方法（只要存在就能拿到） 成员方法的作用：依然是执行\nMethod****提供的方法 说明 public Object invoke(Object obj, Object… args) 触发某个对象的该方法执行。 public void setAccessible(boolean flag) 设置为true，表示禁止检查访问控制（暴力反射） public void getMethod() throws Exception { // 获取类中的方法 Class c1 = Dog.class; Method[] m1 = c1.getDeclaredMethods(); for (Method m : m1) { System.out.println(m.getName() + \"(\" + m.getParameterCount() + \")\"); } // 获取单个成员方法 Method m2 = c1.getDeclaredMethod(\"eat\"); Method m3 = c1.getDeclaredMethod(\"eat\", String.class); System.out.println(m2.getName() + \"(\" + m2.getParameterCount() + \")\"); System.out.println(m3.getName() + \"(\" + m3.getParameterCount() + \")\"); // 4、获取成员方法的目的依然是调用方法。 Dog d1 = new Dog(\"小黑\", 2); m2.setAccessible(true); Object invoke = m2.invoke(d1); System.out.println(invoke); // 带回来的返回值，void参数所以是null Object invoke2 = m3.invoke(d1, \"骨头\"); System.out.println(invoke2); // 带回来的返回值：狗说：谢谢！谢谢！汪汪汪！ } 反射的作用 基本作用：可以得到一个类的全部成分然后操作\n可以破坏封装性。\n可以绕过泛型的约束（因为泛型是在编译的时候替换的，反射可以直接获得class文件，这个是运行时的文件，所以可以绕过约束）\n最重要的用途是：适合做Java的框架，基本上，主流的框架都会基于反射设计出一些通用的功能。\n使用反射做一个简易版的框架 需求：\n对于任意一个对象，该框架都可以把对象的字段名和对应的值，保存到文件中去。\n实现步骤\n① 定义一个方法，可以接收任意对象。\n② 每收到一个对象后，使用反射获取该对象的Class对象，然后获取全部的成员变量。\n③ 遍历成员变量，然后提取成员变量在该对象中的具体值。\n④ 把成员变量名、和其值，写出到文件中去即可。\n注解 就是Java代码里的特殊标记，比如：@Override、@Test等，作用是：让其他程序根据注解信息来决定怎么执行该程序\n注意：注解可以用在类上、构造器上、方法上、成员变量上、参数上、等位置处，最后边不需要加分号。\n自定义注解 就是自己定义注解\npublic @interface 注解名称 { public 属性类型 属性名() default 默认值 ; } 特殊属性名：value\n如果注解中只有一个value属性，使用注解时，value名称可以不写\n@A(10) public @interface A { int value(); int a() default 20; } 注解的原理 注解本质是一个接口，Java中所有注解都是继承了Annotation接口的。\n@注解（..）：其实就是一个实现类对象，实现了该注解以及Annotation接口。\n元注解 注解注解的注解\n@Retention(RetentionPolicy.RUNTIME) @Target({ElementType.METHOD}) public @interface Test { } @Target 作用：声明被修饰的注解只能在哪些位置使用\n@Target （ElementType.TYPE）\nTYPE，类，接口\nFIELD，成员变量\nMETHOD，成员方法\nPARAMETER，方法参数\nCONSTRUCTOR，构造器\nLOCAL_VARIABLE，局部变量\n@Retention 作用：声明注解的保留周期。\n@Retention（RetentionPolicy.RUNTIME）\nSOURCE：只作用在源码阶段，字节码文件中不存在。\nCLASS（默认值）：保留到字节码文件阶段，运行阶段不存在.\nRUNTIME（开发常用）：一直保留到运行阶段。\n注解的解析 就是判断类上、方法上、成员变量上是否存在注解，并把注解里的内容给解析出来\n如何解析注解 指导思想：要解析谁上面的注解，就应该先拿到谁。\n比如要解析类上面的注解，则应该先获取该类的Class对象，再通过Class对象解析其上面的注解。\n比如要解析成员方法上的注解，则应该获取到该成员方法的Method对象，再通过Method对象解析其上面的注解。\nClass、 Method、Field, Constructor、都实现了AnnotatedElement接口，它们都拥有解析注解的能力。\nAnnotatedElement****接口提供了解析注解的方法 说明 public Annotation[] getDeclaredAnnotations() 获取当前对象上面的注解。 public T getDeclaredAnnotation(Class annotationClass) 获取指定的注解对象 public boolean isAnnotationPresent(Class annotationClass) 判断当前对象上是否存在某个注解 使用注解开发出一个简易版的Junit框架 需求：定义若干个方法，只要加了Mytest注解，就会触发该方法执行\n① 定义一个自定义注解MyTest，只能注解方法，存活范围是一直都在\n② 定义若干个方法，部分方法加上@MyTest注解修饰，部分方法不加\n③ 模拟一个junit程序，可以触发加了@MyTest注解的方法执行\n注解里边的成员变量可以用来指示运行的次数\n动态代理设计模式 用明星的例子来理解\n对象如果嫌身上干的事太多的话，可以通过代理来转移部分职责。对象有什么方法想被代理，代理就一定要有对应的方法\n中介如何知道要派有唱歌、跳舞方法的代理呢 ？接口\njava.lang.reflect.Proxy类：提供了为对象产生代理对象的方法：\npublic static Object newProxyInstance(ClassLoader loader,Class[] interfaces, InvocationHandler h) 参数一：用于指定用哪个类加载器，去加载生成的代理类\n参数二：指定接口，这些接口用于指定生成的代理长什么，也就是有哪些方法\n参数三：用来指定生成的代理对象要干什么事情\n// 采用了多态的写法，返回一个接口，但是可以通过这个接口来创建代理对象 public static StarServer createProxy (Star s) { /** * 参数一：用于执行用哪个类加载器去加载生成的代理类。 * 参数二：用于指定代理类需要实现的接口: 明星类实现了哪些接口，代理类就实现哪些接口 * 参数三：用于指定代理类需要如何去代理（代理要做的事情）。 */ StarServer proxy =(StarServer)Proxy.newProxyInstance(ProxyUtl.class.getClassLoader(), s.getClass().getInterfaces(), new InvocationHandler() { // 用来声明代理对象要干的事情。 // 参数一： proxy接收到代理对象本身（暂时用处不大） // 参数二： method代表正在被代理的方法 // 参数三： args代表正在被代理的方法的参数 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 有两种method方法，判断一下 String name = method.getName(); if (\"sing\".equals(name)) { System.out.println(\"准备话筒，收钱20w\"); } else if (\"dance\".equals(name)) { System.out.println(\"准备场地，收钱310w\"); } // 把明星喊过来干活 Object invoke = method.invoke(s, args); return invoke; } }); return proxy; } 执行的时候，会先执行代理里边的方法\n","wordCount":"3855","inLanguage":"zh","image":"https://wqnm1gb.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-02-08T10:47:42+08:00","dateModified":"2025-02-08T10:47:42+08:00","author":{"@type":"Person","name":"冷漠三狗子丶"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wqnm1gb.github.io/posts/day16-java%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/"},"publisher":{"@type":"Organization","name":"三狗子的博客","logo":{"@type":"ImageObject","url":"https://wqnm1gb.github.io/images/favicon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wqnm1gb.github.io/ accesskey=h title="主页 (Alt + H)"><img src=https://wqnm1gb.github.io/apple-touch-icon.png alt aria-label=logo height=35>主页</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wqnm1gb.github.io/ title=三狗子的博客><span>首页</span></a></li><li><a href=https://wqnm1gb.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://wqnm1gb.github.io/categories/ title=Categories><span>分类</span></a></li><li><a href=https://wqnm1gb.github.io/tags/ title=Tags><span>标签</span></a></li><li><a href=https://wqnm1gb.github.io/search/ title=搜索><span>搜索</span></a></li><li><a href=https://wqnm1gb.github.io/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://wqnm1gb.github.io/>主页</a>&nbsp;»&nbsp;<a href=https://wqnm1gb.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Day16 Java高级技术</h1><div class=post-meta><span title='2025-02-08 10:47:42.771092 +0800 +0800'>二月 8, 2025</span>&nbsp;·&nbsp;8 分钟&nbsp;·&nbsp;3855 字&nbsp;·&nbsp;冷漠三狗子丶</div></header><div class=post-content><h1 id=单元测试>单元测试<a hidden class=anchor aria-hidden=true href=#单元测试>#</a></h1><p>就是针对最小的功能单元：方法，编写测试代码对其进行正确性测试。</p><p>咱们之前是如何进行单元测试的？有啥问题？</p><p>• 只能在main方法编写测试代码，去调用其他方法进行测试。</p><p>• 无法实现自动化测试，一个方法测试失败，可能影响其他方法的测试。</p><p>• 无法得到测试的报告，需要程序员自己去观察测试是否成功。</p><h1 id=junit单元测试框架>Junit单元测试框架<a hidden class=anchor aria-hidden=true href=#junit单元测试框架>#</a></h1><p>可以用来对方法进行测试，它是第三方公司开源出来的（很多开发工具已经集成了Junit框架比如IDEA）</p><p><strong>优点</strong></p><p>• 可以灵活的编写测试代码，可以针对某个方法执行测试，也支持一键完成对全部方法的自动化测试，且各自独立。</p><p>• 不需要程序员去分析测试的结果，会自动生成测试报告出来。</p><h2 id=junit单元测试的使用步骤>Junit单元测试的使用步骤<a hidden class=anchor aria-hidden=true href=#junit单元测试的使用步骤>#</a></h2><p>需求</p><p>• 某个系统，有多个业务方法，请使用Junit单元测试框架，编写测试代码，完成对这些方法的正确性测试。</p><p>具体步骤</p><p>① 将Junit框架的jar包导入到项目中（注意：IDEA集成了Junit框架，不需要我们自己手工导入了）</p><p>② 为需要测试的业务类，定义对应的测试类，并为每个业务方法，编写对应的测试方法（必须：公共、无参、无返回值）</p><p>③ 测试方法上必须声明@Test注解，然后在测试方法中，编写代码调用被测试的业务方法进行测试</p><p>④ 开始测试：选中测试方法，右键选择“JUnit运行”，如果测试通过则是绿色；如果测试失败，则是红色</p><h1 id=反射>反射<a hidden class=anchor aria-hidden=true href=#反射>#</a></h1><p>反射就是：加载类，并允许以编程的方式解剖类中的各种成分（成员变量、方法、构造器等）</p><p>idea中能提示各种类里边的信息就是用了反射的方式</p><p><img loading=lazy src=/images/Day16Java%e9%ab%98%e7%ba%a7%e6%8a%80%e6%9c%af/1730689412751-386b12f5-5156-47ec-af4b-b2e3a06f07ca.png alt></p><h2 id=获取class的三种方式>获取class的三种方式<a hidden class=anchor aria-hidden=true href=#获取class的三种方式>#</a></h2><ol><li>Class c1=类名.class</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=w>        </span><span class=c1>// 1、方式1：Class c1=类名.class</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Class</span><span class=w> </span><span class=n>c1</span><span class=o>=</span><span class=w> </span><span class=n>Student</span><span class=p>.</span><span class=na>class</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>c1</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><ol start=2><li>调用Class提供方法：public static Class forName（String package）</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=w>        </span><span class=c1>// 2、方式2：调用Class提供方法：public static Class forName（String package）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Class</span><span class=w> </span><span class=n>c2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Class</span><span class=p>.</span><span class=na>forName</span><span class=p>(</span><span class=s>&#34;com.demo02Reflect.Student&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>c1</span><span class=o>==</span><span class=n>c2</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><ol start=3><li>Object提供的方法：public Class getClassO； Class c3 = 对象.getClassl</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=w>        </span><span class=c1>// 3、方式3：使用对象.getClass()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Student</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Student</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Class</span><span class=w> </span><span class=n>c3</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>s</span><span class=p>.</span><span class=na>getClass</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>c3</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><h2 id=获取类中的构造器>获取类中的构造器<a hidden class=anchor aria-hidden=true href=#获取类中的构造器>#</a></h2><p><strong>反射的第一步都是拿到类</strong></p><table><thead><tr><th><strong>方法</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>Constructor[] getConstructors()</td><td>获取全部构造器（只能获取public修饰的）</td></tr><tr><td>Constructor[] getDeclaredConstructors()</td><td>获取全部构造器（只要存在就能拿到，私有构造器也能拿到）</td></tr><tr><td>Constructor getConstructor(Class&mldr; parameterTypes)</td><td>获取某个构造器（只能获取public修饰的）</td></tr><tr><td>Constructor getDeclaredConstructor(Class&mldr; parameterTypes)</td><td>获取某个构造器（只要存在就能拿到）</td></tr></tbody></table><h3 id=获取类构造器的作用依然是初始化对象返回>获取类构造器的作用：依然是初始化对象返回<a hidden class=anchor aria-hidden=true href=#获取类构造器的作用依然是初始化对象返回>#</a></h3><table><thead><tr><th><strong>Constructor****提供的方法</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>T newInstance(Object&mldr; initargs)</td><td>调用此构造器对象表示的构造器，并传入参数，完成对象的初始化并返回</td></tr><tr><td>public void setAccessible(boolean flag)</td><td>设置为true，表示禁止检查访问控制（暴力反射）</td></tr></tbody></table><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=w>    </span><span class=nd>@Test</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>getConstructor</span><span class=p>()</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>Exception</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Class</span><span class=w> </span><span class=n>c1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Dog</span><span class=p>.</span><span class=na>class</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 返回一个Constructor数组</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Constructor</span><span class=o>[]</span><span class=w> </span><span class=n>cons</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>c1</span><span class=p>.</span><span class=na>getDeclaredConstructors</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>Constructor</span><span class=w> </span><span class=n>con</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>cons</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>con</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 获取单个构造器，里边有String和Int变量的</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Constructor</span><span class=w> </span><span class=n>con1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>c1</span><span class=p>.</span><span class=na>getDeclaredConstructor</span><span class=p>(</span><span class=n>String</span><span class=p>.</span><span class=na>class</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=p>.</span><span class=na>class</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>con1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 创建对象并且返回</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Dog</span><span class=w> </span><span class=n>d1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=n>Dog</span><span class=p>)</span><span class=n>con1</span><span class=p>.</span><span class=na>newInstance</span><span class=p>(</span><span class=s>&#34;小黑&#34;</span><span class=p>,</span><span class=w> </span><span class=n>2</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>d1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=获取类中的成员变量>获取类中的成员变量<a hidden class=anchor aria-hidden=true href=#获取类中的成员变量>#</a></h2><table><thead><tr><th><strong>方法</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>public Field[] getFields()</td><td>获取类的全部成员变量（只能获取public修饰的）</td></tr><tr><td>public Field[] getDeclaredFields()</td><td>获取类的全部成员变量（只要存在就能拿到）</td></tr><tr><td>public Field getField(String name)</td><td>获取类的某个成员变量（只能获取public修饰的）</td></tr><tr><td>public Field getDeclaredField(String name)</td><td>获取类的某个成员变量（只要存在就能拿到）</td></tr></tbody></table><p><strong>获取到成员变量的作用：依然是赋值、取值</strong></p><table><thead><tr><th><strong>方法</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>void set(Object obj, Object value)：</td><td>赋值</td></tr><tr><td>Object get(Object obj)s</td><td>取值</td></tr><tr><td>public void setAccessible(boolean flag)</td><td>设置为true，表示禁止检查访问控制（暴力反射）</td></tr></tbody></table><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=w>    </span><span class=nd>@Test</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>getField</span><span class=p>()</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>Exception</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 获取成员变量</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Class</span><span class=w> </span><span class=n>c1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Dog</span><span class=p>.</span><span class=na>class</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Field</span><span class=o>[]</span><span class=w> </span><span class=n>f1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>c1</span><span class=p>.</span><span class=na>getDeclaredFields</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>Field</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>f1</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>f</span><span class=p>.</span><span class=na>getName</span><span class=p>()</span><span class=o>+</span><span class=s>&#34;(&#34;</span><span class=o>+</span><span class=n>f</span><span class=p>.</span><span class=na>getType</span><span class=p>().</span><span class=na>getName</span><span class=p>()</span><span class=o>+</span><span class=s>&#34;)&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 获取单个成员变量</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Field</span><span class=w> </span><span class=n>f2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>c1</span><span class=p>.</span><span class=na>getDeclaredField</span><span class=p>(</span><span class=s>&#34;hobby&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>f2</span><span class=p>.</span><span class=na>getName</span><span class=p>()</span><span class=o>+</span><span class=s>&#34;(&#34;</span><span class=o>+</span><span class=n>f2</span><span class=p>.</span><span class=na>getType</span><span class=p>().</span><span class=na>getName</span><span class=p>()</span><span class=o>+</span><span class=s>&#34;)&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 给成员变量赋值</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Dog</span><span class=w> </span><span class=n>d1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Dog</span><span class=p>(</span><span class=s>&#34;小黑&#34;</span><span class=p>,</span><span class=w> </span><span class=n>2</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 因为hobby是私有变量，所以需要暴力反射</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>f2</span><span class=p>.</span><span class=na>setAccessible</span><span class=p>(</span><span class=kc>true</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 需要拿到f2（变量对象），再拿到d1（对象），才能进行修改</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>f2</span><span class=p>.</span><span class=na>set</span><span class=p>(</span><span class=n>d1</span><span class=p>,</span><span class=w> </span><span class=s>&#34;看门&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=获取类中的成员方法>获取类中的成员方法<a hidden class=anchor aria-hidden=true href=#获取类中的成员方法>#</a></h2><table><thead><tr><th><strong>方法</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>Method[] getMethods()</td><td>获取类的全部成员方法（只能获取public修饰的）</td></tr><tr><td>Method[] getDeclaredMethods()</td><td>获取类的全部成员方法（只要存在就能拿到）</td></tr><tr><td>Method getMethod(String name, Class&mldr; parameterTypes)</td><td>获取类的某个成员方法（只能获取public修饰的）</td></tr><tr><td>Method getDeclaredMethod(String name, Class&mldr; parameterTypes)</td><td>获取类的某个成员方法（只要存在就能拿到）</td></tr></tbody></table><p><strong>成员方法的作用：依然是执行</strong></p><table><thead><tr><th><strong>Method****提供的方法</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>public Object invoke(Object obj, Object&mldr; args)</td><td>触发某个对象的该方法执行。</td></tr><tr><td>public void setAccessible(boolean flag)</td><td>设置为true，表示禁止检查访问控制（暴力反射）</td></tr></tbody></table><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>getMethod</span><span class=p>()</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>Exception</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 获取类中的方法</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Class</span><span class=w> </span><span class=n>c1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Dog</span><span class=p>.</span><span class=na>class</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Method</span><span class=o>[]</span><span class=w> </span><span class=n>m1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>c1</span><span class=p>.</span><span class=na>getDeclaredMethods</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>Method</span><span class=w> </span><span class=n>m</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>m1</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>m</span><span class=p>.</span><span class=na>getName</span><span class=p>()</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34;(&#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>m</span><span class=p>.</span><span class=na>getParameterCount</span><span class=p>()</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34;)&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 获取单个成员方法</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Method</span><span class=w> </span><span class=n>m2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>c1</span><span class=p>.</span><span class=na>getDeclaredMethod</span><span class=p>(</span><span class=s>&#34;eat&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Method</span><span class=w> </span><span class=n>m3</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>c1</span><span class=p>.</span><span class=na>getDeclaredMethod</span><span class=p>(</span><span class=s>&#34;eat&#34;</span><span class=p>,</span><span class=w> </span><span class=n>String</span><span class=p>.</span><span class=na>class</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>m2</span><span class=p>.</span><span class=na>getName</span><span class=p>()</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34;(&#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>m2</span><span class=p>.</span><span class=na>getParameterCount</span><span class=p>()</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34;)&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>m3</span><span class=p>.</span><span class=na>getName</span><span class=p>()</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34;(&#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>m3</span><span class=p>.</span><span class=na>getParameterCount</span><span class=p>()</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34;)&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 4、获取成员方法的目的依然是调用方法。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Dog</span><span class=w> </span><span class=n>d1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Dog</span><span class=p>(</span><span class=s>&#34;小黑&#34;</span><span class=p>,</span><span class=w> </span><span class=n>2</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>m2</span><span class=p>.</span><span class=na>setAccessible</span><span class=p>(</span><span class=kc>true</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Object</span><span class=w> </span><span class=n>invoke</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>m2</span><span class=p>.</span><span class=na>invoke</span><span class=p>(</span><span class=n>d1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>invoke</span><span class=p>);</span><span class=w> </span><span class=c1>// 带回来的返回值，void参数所以是null</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Object</span><span class=w> </span><span class=n>invoke2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>m3</span><span class=p>.</span><span class=na>invoke</span><span class=p>(</span><span class=n>d1</span><span class=p>,</span><span class=w> </span><span class=s>&#34;骨头&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>invoke2</span><span class=p>);</span><span class=w> </span><span class=c1>// 带回来的返回值：狗说：谢谢！谢谢！汪汪汪！</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=反射的作用>反射的作用<a hidden class=anchor aria-hidden=true href=#反射的作用>#</a></h2><p>基本作用：可以得到一个类的全部成分然后操作</p><p>可以破坏封装性。</p><p><strong>可以绕过泛型的约束（因为泛型是在编译的时候替换的，反射可以直接获得class文件，这个是运行时的文件，所以可以绕过约束）</strong></p><hr><p><strong>最重要的用途是：适合做Java的框架，基本上，主流的框架都会基于反射设计出一些通用的功能。</strong></p><h3 id=使用反射做一个简易版的框架>使用反射做一个简易版的框架<a hidden class=anchor aria-hidden=true href=#使用反射做一个简易版的框架>#</a></h3><p>需求：</p><p>对于任意一个对象，该框架都可以把对象的字段名和对应的值，保存到文件中去。</p><p>实现步骤</p><p>① 定义一个方法，可以接收任意对象。</p><p>② 每收到一个对象后，使用反射获取该对象的Class对象，然后获取全部的成员变量。</p><p>③ 遍历成员变量，然后提取成员变量在该对象中的具体值。</p><p>④ 把成员变量名、和其值，写出到文件中去即可。</p><h1 id=注解>注解<a hidden class=anchor aria-hidden=true href=#注解>#</a></h1><p>就是Java代码里的特殊标记，比如：@Override、@Test等，作用是：让其他程序根据注解信息来决定怎么执行该程序</p><p>注意：注解可以用在类上、构造器上、方法上、成员变量上、参数上、等位置处，最后边不需要加分号。</p><h2 id=自定义注解>自定义注解<a hidden class=anchor aria-hidden=true href=#自定义注解>#</a></h2><p>就是自己定义注解</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=nd>@interface</span><span class=w> </span><span class=n>注解名称</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>属性类型</span><span class=w> </span><span class=nf>属性名</span><span class=p>()</span><span class=w> </span><span class=k>default</span><span class=w> </span><span class=n>默认值</span><span class=w> </span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><strong>特殊属性名：value</strong></p><p>如果注解中只有一个value属性，使用注解时，value名称可以不写</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@A</span><span class=p>(</span><span class=n>10</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=nd>@interface</span><span class=w> </span><span class=n>A</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=nf>value</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=nf>a</span><span class=p>()</span><span class=w> </span><span class=k>default</span><span class=w> </span><span class=n>20</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h3 id=注解的原理>注解的原理<a hidden class=anchor aria-hidden=true href=#注解的原理>#</a></h3><p><img loading=lazy src=/images/Day16Java%e9%ab%98%e7%ba%a7%e6%8a%80%e6%9c%af/1730778171491-fe046902-2461-42ea-b341-667c27305f04.png alt></p><p>注解本质是一个接口，Java中所有注解都是继承了Annotation接口的。</p><p>@注解（..）：其实就是一个实现类对象，实现了该注解以及Annotation接口。</p><h2 id=元注解>元注解<a hidden class=anchor aria-hidden=true href=#元注解>#</a></h2><p><strong>注解注解的注解</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Retention</span><span class=p>(</span><span class=n>RetentionPolicy</span><span class=p>.</span><span class=na>RUNTIME</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@Target</span><span class=p>({</span><span class=n>ElementType</span><span class=p>.</span><span class=na>METHOD</span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=nd>@interface</span><span class=w> </span><span class=n>Test</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h3 id=target>@Target<a hidden class=anchor aria-hidden=true href=#target>#</a></h3><p>作用：声明被修饰的注解只能在哪些位置使用</p><p>@Target （ElementType.TYPE）</p><ol><li><p>TYPE，类，接口</p></li><li><p>FIELD，成员变量</p></li><li><p>METHOD，成员方法</p></li><li><p>PARAMETER，方法参数</p></li><li><p>CONSTRUCTOR，构造器</p></li><li><p>LOCAL_VARIABLE，局部变量</p></li></ol><h3 id=retention>@Retention<a hidden class=anchor aria-hidden=true href=#retention>#</a></h3><p>作用：声明注解的保留周期。</p><p>@Retention（RetentionPolicy.RUNTIME）</p><ol><li><p>SOURCE：只作用在源码阶段，字节码文件中不存在。</p></li><li><p>CLASS（默认值）：保留到字节码文件阶段，运行阶段不存在.</p></li><li><p>RUNTIME（开发常用）：一直保留到运行阶段。</p></li></ol><h2 id=注解的解析>注解的解析<a hidden class=anchor aria-hidden=true href=#注解的解析>#</a></h2><p>就是判断类上、方法上、成员变量上是否存在注解，并把注解里的内容给解析出来</p><h3 id=如何解析注解>如何解析注解<a hidden class=anchor aria-hidden=true href=#如何解析注解>#</a></h3><p>指导思想：要解析谁上面的注解，就应该先拿到谁。</p><p>比如要解析类上面的注解，则应该先获取该类的Class对象，再通过Class对象解析其上面的注解。</p><p>比如要解析成员方法上的注解，则应该获取到该成员方法的Method对象，再通过Method对象解析其上面的注解。</p><p>Class、 Method、Field, Constructor、都实现了AnnotatedElement接口，它们都拥有解析注解的能力。</p><table><thead><tr><th><strong>AnnotatedElement****接口提供了解析注解的方法</strong></th><th>说明</th></tr></thead><tbody><tr><td>public Annotation[] getDeclaredAnnotations()</td><td>获取当前对象上面的注解。</td></tr><tr><td>public T getDeclaredAnnotation(Class annotationClass)</td><td>获取指定的注解对象</td></tr><tr><td>public boolean isAnnotationPresent(Class annotationClass)</td><td>判断当前对象上是否存在某个注解</td></tr></tbody></table><h3 id=使用注解开发出一个简易版的junit框架>使用注解开发出一个简易版的Junit框架<a hidden class=anchor aria-hidden=true href=#使用注解开发出一个简易版的junit框架>#</a></h3><p>需求：定义若干个方法，只要加了Mytest注解，就会触发该方法执行</p><p>① 定义一个自定义注解MyTest，只能注解方法，存活范围是一直都在</p><p>② 定义若干个方法，部分方法加上@MyTest注解修饰，部分方法不加</p><p>③ 模拟一个junit程序，可以触发加了@MyTest注解的方法执行</p><p><strong>注解里边的成员变量可以用来指示运行的次数</strong></p><h1 id=动态代理设计模式>动态代理设计模式<a hidden class=anchor aria-hidden=true href=#动态代理设计模式>#</a></h1><p>用明星的例子来理解</p><p>对象如果嫌身上干的事太多的话，可以通过代理来转移部分职责。对象有什么方法想被代理，代理就一定要有对应的方法</p><p>中介如何知道要派有唱歌、跳舞方法的代理呢 ？接口</p><p>java.lang.reflect.Proxy类：提供了为对象产生代理对象的方法：</p><p><strong>public static </strong>Object <strong>newProxyInstance</strong>(ClassLoader loader,Class[] interfaces, InvocationHandler h)</p><p></p><p>参数一：用于指定用哪个类加载器，去加载生成的代理类</p><p></p><p>参数二：指定接口，这些接口用于指定生成的代理长什么，也就是有哪些方法</p><p></p><p>参数三：用来指定生成的代理对象要干什么事情</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=w>    </span><span class=c1>// 采用了多态的写法，返回一个接口，但是可以通过这个接口来创建代理对象</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=n>StarServer</span><span class=w> </span><span class=nf>createProxy</span><span class=w> </span><span class=p>(</span><span class=n>Star</span><span class=w> </span><span class=n>s</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>         * 参数一：用于执行用哪个类加载器去加载生成的代理类。
</span></span></span><span class=line><span class=cl><span class=cm>         * 参数二：用于指定代理类需要实现的接口: 明星类实现了哪些接口，代理类就实现哪些接口
</span></span></span><span class=line><span class=cl><span class=cm>         * 参数三：用于指定代理类需要如何去代理（代理要做的事情）。
</span></span></span><span class=line><span class=cl><span class=cm>         */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>StarServer</span><span class=w> </span><span class=n>proxy</span><span class=w> </span><span class=o>=</span><span class=p>(</span><span class=n>StarServer</span><span class=p>)</span><span class=n>Proxy</span><span class=p>.</span><span class=na>newProxyInstance</span><span class=p>(</span><span class=n>ProxyUtl</span><span class=p>.</span><span class=na>class</span><span class=p>.</span><span class=na>getClassLoader</span><span class=p>(),</span><span class=w> </span><span class=n>s</span><span class=p>.</span><span class=na>getClass</span><span class=p>().</span><span class=na>getInterfaces</span><span class=p>(),</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>InvocationHandler</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 用来声明代理对象要干的事情。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 参数一： proxy接收到代理对象本身（暂时用处不大）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 参数二： method代表正在被代理的方法</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 参数三： args代表正在被代理的方法的参数</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kd>public</span><span class=w> </span><span class=n>Object</span><span class=w> </span><span class=nf>invoke</span><span class=p>(</span><span class=n>Object</span><span class=w> </span><span class=n>proxy</span><span class=p>,</span><span class=w> </span><span class=n>Method</span><span class=w> </span><span class=n>method</span><span class=p>,</span><span class=w> </span><span class=n>Object</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>Throwable</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// 有两种method方法，判断一下</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>String</span><span class=w> </span><span class=n>name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>method</span><span class=p>.</span><span class=na>getName</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=s>&#34;sing&#34;</span><span class=p>.</span><span class=na>equals</span><span class=p>(</span><span class=n>name</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;准备话筒，收钱20w&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=s>&#34;dance&#34;</span><span class=p>.</span><span class=na>equals</span><span class=p>(</span><span class=n>name</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;准备场地，收钱310w&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// 把明星喊过来干活</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>Object</span><span class=w> </span><span class=n>invoke</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>method</span><span class=p>.</span><span class=na>invoke</span><span class=p>(</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>args</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>return</span><span class=w> </span><span class=n>invoke</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>proxy</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>执行的时候，会先执行代理里边的方法</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://wqnm1gb.github.io/tags/java%E5%9F%BA%E7%A1%80/>Java基础</a></li></ul><nav class=paginav><a class=prev href=https://wqnm1gb.github.io/posts/day01htmlcss/><span class=title>« 上一页</span><br><span>Day01 html&amp;css</span>
</a><a class=next href=https://wqnm1gb.github.io/posts/day15-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/><span class=title>下一页 »</span><br><span>Day15 网络编程</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://wqnm1gb.github.io/>三狗子的博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>