<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Day13 File和IO流 | 三狗子的博客</title>
<meta name=keywords content="java基础"><meta name=description content="File
File是java.io.包下的类，File类的对象，用于代表当前操作系统的文件（可以是文件、或文件夹）
注意：File类只能对文件本身进行操作，不能读写文件里面存储的数据"><meta name=author content="冷漠三狗子丶"><link rel=canonical href=https://wqnm1gb.github.io/posts/day13-file%E5%92%8Cio%E6%B5%81/><link crossorigin=anonymous href=/assets/css/stylesheet.3d688279d829dc24da48acd11f9e33ebea2f39c035e899e1bf4297d8b7aa89b9.css integrity="sha256-PWiCedgp3CTaSKzRH54z6+ovOcA16Jnhv0KX2Leqibk=" rel="preload stylesheet" as=style><link rel=icon href=https://wqnm1gb.github.io/images/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://wqnm1gb.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wqnm1gb.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wqnm1gb.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://wqnm1gb.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://wqnm1gb.github.io/posts/day13-file%E5%92%8Cio%E6%B5%81/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel=stylesheet><script type=text/javascript async src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["[[","]]"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=" has-jax"})</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style><meta property="og:title" content="Day13 File和IO流"><meta property="og:description" content="File
File是java.io.包下的类，File类的对象，用于代表当前操作系统的文件（可以是文件、或文件夹）
注意：File类只能对文件本身进行操作，不能读写文件里面存储的数据"><meta property="og:type" content="article"><meta property="og:url" content="https://wqnm1gb.github.io/posts/day13-file%E5%92%8Cio%E6%B5%81/"><meta property="og:image" content="https://wqnm1gb.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-02-08T10:45:56+08:00"><meta property="article:modified_time" content="2025-02-08T10:45:56+08:00"><meta property="og:site_name" content="三狗子的博客"><meta property="fb:admins" content="your-facebook-admin-id"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wqnm1gb.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Day13 File和IO流","item":"https://wqnm1gb.github.io/posts/day13-file%E5%92%8Cio%E6%B5%81/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Day13 File和IO流","name":"Day13 File和IO流","description":"File File是java.io.包下的类，File类的对象，用于代表当前操作系统的文件（可以是文件、或文件夹）\n注意：File类只能对文件本身进行操作，不能读写文件里面存储的数据\n","keywords":["java基础"],"articleBody":"File File是java.io.包下的类，File类的对象，用于代表当前操作系统的文件（可以是文件、或文件夹）\n注意：File类只能对文件本身进行操作，不能读写文件里面存储的数据\n可以使用相对路径定位文件对象\n只要带盘符的都称之为：绝对路径E:/resource/aaa.jpg\n相对路径：不带盘符，默认是到你的idea工程下直接寻找文件的，一般用来找工程下的项目文件的\n注意只能相对到工程，后边的文件夹名和src还需要手动写\n创建File对象 构造器 说明 public File(String pathname) 根据文件路径创建文件对象 public File(String parent, String child) 根据父路径和子路径名字创建文件对象 File对象既可以代表文件、也可以代表文件夹。\nFile封装的对象仅仅是一个路径名，这个路径可以是存在的，也允许是不存在的。\n可以用/，也可以用\\\nFile提供的判断文件类型、获取文件信息功能 方法名称 说明 public boolean exists() 判断当前文件对象，对应的文件路径是否存在，存在返回true public booleanisFile() 判断当前文件对象指代的是否是文件，是文件返回true，反之。 public booleanisDirectory() 判断当前文件对象指代的是否是文件夹，是文件夹返回true，反之。 public String getName() 获取文件的名称（包含后缀） public long length() 获取文件的大小，返回字节个数 public long lastModified() 获取文件的最后修改时间。 public String getPath() 获取创建文件对象时，使用的路径 public String getAbsolutePath() 获取绝对路径 File提供的创建和删除文件的方法 File类创建文件的功能 方法名称 说明 public booleancreateNewFile() 创建一个新的空的文件 public booleanmkdir() 只能创建一级文件夹 public booleanmkdirs() 可以创建多级文件夹 File类删除文件的功能 方法名称 说明 public boolean delete() 删除文件、空文件夹 注意：delete方法默认只能删除文件和空文件夹，删除后的文件不会进入回收站。\nFile提供的遍历文件夹的方法 方法名称 说明 public String[] list() 获取当前目录下所有的\"一级文件名称\"到一个字符串数组中去返回。 public File[] listFiles() 获取当前目录下所有的\"一级文件对象\"到一个文件对象数组中去返回（重点） 使用listFiles方法时的注意事项：\n• 当主调是文件，或者路径不存在时，返回null\n• 当主调是空文件夹时，返回一个长度为0的数组\n• 当主调是一个有内容的文件夹时，将里面所有一级文件和文件夹的路径放在File数组中返回\n• 当主调是一个文件夹，目里面有隐藏文件时，将里面所有文件和文件夹的路径放在File数组中返回，包含隐藏文件\n• 当主调是一个文件夹，但是没有权限访问该文件夹时，返回null\n递归的三要素 递归的公式： f(n)= f(n-1)*n；\n递归的终结点：f(1)\n递归的方向必须走向终结点\n文件搜索 先找出D:盘下的所有一级文件对象\n遍历全部一级文件对象，判断是否是文件\n如果是文件，判断是否是自己想要的\n如果是文件夹，需要继续进入到该文件夹，重复上述过程\n字符集 标准的ASCII编码 ASCII（American Standard Code for Information Interchange）：美国信息交换标准代码，包括了英文、符号等。\n标准ASCIl使用1个字节存储一个字符，首位是0因此，总共可表示128个字符，对美国佬来说完全够用。\nGBK（汉字内码扩展规范，国标） 汉字编码字符集，包含了2万多个汉字等字符，GBK中一个中文字符编码成两个字节的形式存储。\n注意：GBK兼容了ASCII字符集。\nGBK规定：汉字的第一个字节的第一位必须是1\nUnicode字符集（统一码，也叫万国码） Unicode是国际组织制定的，可以容纳世界上所有文字、符号的字符集。\nUTF-8字符集 是Unicode字符集的一种编码方案，采取可变长编码方案，共分四个长度区：1个字书，2个字节，3个字节，4个字节（不像Unicode会占用4个字节，太大了）\n英文字符、数字等只占1个字节（兼容标准ASCII编码），汉字字符占用3个字节。\n前缀码\n注意1：字符编码时使用的字符集，和解码时使用的字符集必须一致，否则会出现乱码\n注意2：英文，数字一般不会乱码，因为很多字符集都兼容了ASCII编码。\n对字符集进行编码\nString提供了如下方法 说明 byte[] getBytes() 使用平台的默认字符集将该String编码为一系列字节，将结果存储到新的字节数组中 byte[] getBytes(String charsetName) 使用指定的字符集将该 String编码为一系列字节，将结果存储到新的字节数组中 对字符的解码\nString****提供了如下方法 说明 String(byte[] bytes) 通过使用平台的默认字符集解码指定的字节数组来构造新的 String String(byte[] bytes, String charsetName) 通过指定的字符集解码指定的字节数组来构造新的 String IO流 用于读写数据的（可以读写文件，或者网络上的数据）\nIO流的分类 IO流的体系 FileInputStream（文件字节输入流） 作用：以内存为基准，可以把磁盘文件中的数据以字节的形式读入到内存中去。\n构造器 说明 public FileInputStream(File file) 创建字节输入流管道与源文件接通 public FileInputStream(String pathname) 创建字节输入流管道与源文件接通 方法名称 说明 public int read() 每次读取一个字节返回，如果发现没有数据可读会返回-1，性能较差，而且不能读中文，每次读一个字节的话，中文会乱码 public int read(byte[] buffer) 每次用一个字节数组去读取数据，返回字节数组读取了多少个字节，如果发现没有数据可读会返回-1 使用FilelnputStream每次读取一个字节，读取性能较差，并且读取汉字输出会乱码。\n使用FilelnputStream每次读取多个字节，读取性能得到了提升，但读取汉字输出还是会乱码。\n1、使用字节流读取中文，如何保证输出不乱码，怎么解决？\n定义一个与文件一样大的字节数组，一次性读取完文件的全部字节（只适合读小文件）\nJava提供了方法：\n方法名称 说明 public byte[] readAllBytes() throws IOException 直接将当前字节输入流对应的文件对象的字节数据装到一个字节数组返回 如果文件过大，创建的字节数组也会过大，可能引起内存溢出。\n读取文本适合用字符流 字节流适合做数据的转移，比如：文件复制\nFileOutputStream文件字节输出流 作用：以内存为基准，把内存中的数据以字节的形式写出到文件中去。\n用完流后都要关闭\n“\\r\\n”.getBytes(); // 写出一个换行符\n构造器 说明 public FileOutputStream(File file) 创建字节输出流管道与源文件对象接通 public FileOutputStream(String filepath) 创建字节输出流管道与源文件路径接通 public FileOutputStream(File file，boolean append) 创建字节输出流管道与源文件对象接通，可追加数据，后边跟true表示可以追加 public FileOutputStream(String filepath，boolean append) 创建字节输出流管道与源文件路径接通，可追加数据 方法名称 说明 public void write(int a) 写一个字节出去 public void write(byte[] buffer) 写一个字节数组出去 public void write(byte[] buffer , int pos , int len) 写一个字节数组的一部分出去。 public void close() throws IOException 关闭流。 资源释放的问题 try-catch-finally finally代码区的特点：无论try中的程序是正常执行了，还是出现了异常，最后都一定会执行finally区，除非JVM终止。\n作用：一般用于在程序执行完成后进行资源的释放操作（专业级做法），但是比较臃肿\ntry-with-resource try(定义资源1;定义资源2;…）{ 可能出现异常的代码; }catch(异常类名 变量名){ 异常的处理代码; } 该资源使用完毕后，会自动调用其close()方法，完成对资源的释放！\n()中只能放置资源，否则报错\n什么是资源呢？\n资源一般指的是最终实现了AutoCloseable接口。\n字符流 FileReader文件字符输入流 作用：以内存为基准，可以把文件中的数据以字符的形式读入到内存中去。\n拓展：文件字符输入流每次读取多个字符，性能较好，而且读取中文是按照字符读取，不会出现乱码！这是一种读取中文很好的方案。\n构造器 说明 public FileReader****(File file) 创建字符输入流管道与源文件接通 public FileReader****(String pathname) 创建字符输入流管道与源文件接通 方法名称 说明 public int read() 每次读取一个字符返回，如果发现没有数据可读会返回-1. public int read(char[] buffer) 每次用一个字符数组去读取数据，返回字符数组读取了多少个字符，如果发现没有数据可读会返回-1. 读文档的时候，不要需加换行符，文档中自己有换行符\n�\nFileWriter文件字符输出流 以内存为基准，把内存中的数据以字符的形式写出到文件中去。\n构造器 说明 public FileWriter(File file) 创建字节输出流管道与源文件对象接通 public FileWriter(String filepath) 创建字节输出流管道与源文件路径接通 public FileWriter(File file，boolean append) 创建字节输出流管道与源文件对象接通，可追加数据 public FileWriter(String filepath，boolean append) 创建字节输出流管道与源文件路径接通，可追加数据 方法名称 说明 void write(int c) 写一个字符 void write(String str) 写一个字符串 void write(String str, int off, int len) 写一个字符串的一部分 void write(char[] cbuf) 写入一个字符数组 字符输出流写出数据后，必须刷新流，或者关闭流，写出去的数据才能生效\n方法名称 说明 public void flush() throws IOException 刷新流，就是将内存中缓存的数据立即写到文件中去生效！ public void close() throws IOException 关闭流的操作，包含了刷新！ 使用close就会默认刷新，或者使用try with resource也会默认在关闭的时候刷新\nBufferedInputstream缓冲字节输入和输出流 作用：可以提高字节输入流读取数据的性能\n原理：缓冲字节输入流自带了8KB缓冲池；缓冲字节输出流也自带了8KB缓冲池。\n构造器 说明 public BufferedInputStream(InputStream is) 把低级的字节输入流包装成一个高级的缓冲字节输入流，从而提高读数据的性能 public BufferedOutputStream(OutputStreamos) 把低级的字节输出流包装成一个高级的缓冲字节输出流，从而提高写数据的性能 BufferedReader缓冲字符输入流 作用：自带8K（8192）的字符缓冲池，可以提高字符输入流读取字符数据的性能。\n构造器 说明 public BufferedReader(Reader r) 把低级的字符输入流包装成字符缓冲输入流管道，从而提高字符输入流读字符数据的性能 字符缓冲输入流新增的功能：按照行读取字符\n方法 说明 public String readLine() 读取一行数据返回，如果没有数据可读了，会返回null Bufferedwriter缓冲字符输出流 作用：自带8K的字符缓冲池，可以提高字符输出流写字符数据的性能。\n构造器 说明 public BufferedWriter(Writer r) 把低级的字符输出流包装成一个高级的缓冲字符输出流管道，从而提高字符输出流写数据的性能（把低级管道变成一个高级管道，里边包着一个高级管道） 字符缓冲输出流新增的功能：换行\n方法 说明 public void newLine() 换行 可以把低级管道的缓冲桶加大，那么这样性能就会接近高级管道，所以并不是低级管道的新能一定差，相对来说，桶越大，复制速度越快\n其他流 InputStreamReader（字节输入转换流） 解决不同编码时，字符流读取文本内容乱码的问题。\n解决思路： 先获取文件的原始字节流再将其按真实的字符集编码转成字符输入流，这样字符输入流中的字符就不乱码了。\n这也是个高级流，里边可以包着一个低级流\n构造器 说明 public InputStreamReader(InputStream is) 把原始的字节输入流，按照代码默认编码转成字符输入流（与直接用FileReader的效果一样） public InputStreamReader(InputStream is ，String charset) 把原始的字节输入流，按照指定字符集编码转成字符输入流(重点) PrintStream/PrintWriter（打印流） 作用：打印流可以实现更方便、更高效的打印数据出去，能实现打印啥出去就是啥出去，性能也高。\nPrintStream提供的打印数据的方案\n构造器 说明 public PrintStream(OutputStream/File/String) 打印流直接通向字节输出流/文件/文件路径 publicPrintStream(String fileName, Charset charset) 可以指定写出去的字符编码 publicPrintStream(OutputStream out, boolean autoFlush) 可以指定实现自动刷新 publicPrintStream(OutputStream out, boolean autoFlush, String encoding) 可以指定实现自动刷新，并可指定字符的编码 方法 说明 public void println(Xxx**** xx) 打印任意类型的数据出去，天生自带换行 public void write(int/byte[]/byte[]一部分) 可以支持写字节数据出去 PrintWriter提供的打印数据的方案\n构造器 说明 public Print****Writer(OutputStream/Writer/File/String) 打印流直接通向字节输出流/文件/文件路径 publicPrintWriter(String fileName, Charset charset) 可以指定写出去的字符编码 publicPrintWriter(OutputStream out/Writer, boolean autoFlush) 可以指定实现自动刷新 publicPrintWriter(OutputStream out, boolean autoFlush, String encoding) 可以指定实现自动刷新，并可指定字符的编码 方法 说明 public void println(Xxx**** xx) 打印任意类型的数据出去 public void write(int/String/char[]/..) 可以支持写字符数据出去 PrintStream和PrintWriter的区别 • 打印数据的功能上是一模一样的：都是使用方便，性能高效（核心优势）\n• PrintStream继承自字节输出流OutputStream，因此支持写**字节数据**的方法。\n• PrintWriter继承自**字符输出流Writer，因此支持写字符数据**出去。\nDataOutputStream（数据输出流） 允许把数据和其类型一并写出去。\n构造器 说明 public DataOutputStream(OutputStream**** out) 创建新数据输出流包装基础的字节输出流 方法 说明 public final void writeByte(int v) throws IOException 将byte类型的数据写入基础的字节输出流 public final void writeInt****(int v) throws IOException 将int类型的数据写入基础的字节输出流 public final void writeDouble(Double v) throws IOException 将double类型的数据写入基础的字节输出流 public final void writeUTF(String str) throws IOException 将字符串数据以UTF-8编码成字节写入基础的字节输出流 public void write(int/byte[]/byte[]一部分) 支持写字节数据出去 DatalnputStream（数据输入流） 用于读取数据输出流写出去的数据。\n构造器 说明 public DataInputStream(InputStream**** is) 创建新数据输入流包装基础的字节输入流 方法 说明 Public final byte readByte() throws IOException 读取字节数据返回 public final int readInt****() throws IOException 读取int类型的数据返回 public final double readDouble() throws IOException 读取double类型的数据返回 public final String readUTF****() throws IOException 读取字符串数（UTF-8）据返回 public int readInt()/read(byte[]) 支持读字节数据进来 IO框架 什么是框架？\n框架（Framework）是一个预先写好的代码库或一组工具，旨在简化和加速开发过程\n框架的形式：一般是把类、接口等编译成class形式，再压缩成一个.jar结尾的文件发行出去\n导入commons-io-2.11.0jar框架到项目的步骤\n① 在项目中创建一个文件夹：lib\n② 将commons-io-2.6.jar文件复制到1ib文件夹\n③ 在jar文件上点右键，选择 Add as Library -\u003e 点击OK\n④ 在类中导包使用\nCommons-io框架\nCommons-io是apache开源基金组织提供的一组有关IO操作的小框架，目的是提高IO流的开发效率。\nFileUtils类提供的部分方法展示 说明 public static void copyFile(File srcFile, File destFile) 复制文件。 public static void copyDirectory(File srcDir, File destDir) 复制文件夹 public static void deleteDirectory(File directory) 删除文件夹 public static String readFileToString(File file, String encoding) 读数据 public static void writeStringToFile(File file, String data, String charname, boolean append) 写数据 IOUtils类提供的部分方法展示 说明 public static int copy(InputStreaminputStream, OutputStreamoutputStream) 复制文件。 public static int copy(Reader reader, Writer writer) 复制文件。 public static void write(String data, OutputStream output, String charsetName) 写数据 ","wordCount":"5476","inLanguage":"zh","image":"https://wqnm1gb.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-02-08T10:45:56+08:00","dateModified":"2025-02-08T10:45:56+08:00","author":{"@type":"Person","name":"冷漠三狗子丶"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wqnm1gb.github.io/posts/day13-file%E5%92%8Cio%E6%B5%81/"},"publisher":{"@type":"Organization","name":"三狗子的博客","logo":{"@type":"ImageObject","url":"https://wqnm1gb.github.io/images/favicon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wqnm1gb.github.io/ accesskey=h title="主页 (Alt + H)"><img src=https://wqnm1gb.github.io/apple-touch-icon.png alt aria-label=logo height=35>主页</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wqnm1gb.github.io/ title=三狗子的博客><span>首页</span></a></li><li><a href=https://wqnm1gb.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://wqnm1gb.github.io/categories/ title=Categories><span>分类</span></a></li><li><a href=https://wqnm1gb.github.io/tags/ title=Tags><span>标签</span></a></li><li><a href=https://wqnm1gb.github.io/search/ title=搜索><span>搜索</span></a></li><li><a href=https://wqnm1gb.github.io/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://wqnm1gb.github.io/>主页</a>&nbsp;»&nbsp;<a href=https://wqnm1gb.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Day13 File和IO流</h1><div class=post-meta><span title='2025-02-08 10:45:56.26273 +0800 +0800'>二月 8, 2025</span>&nbsp;·&nbsp;11 分钟&nbsp;·&nbsp;5476 字&nbsp;·&nbsp;冷漠三狗子丶</div></header><div class=post-content><h2 id=file>File<a hidden class=anchor aria-hidden=true href=#file>#</a></h2><p>File是java.io.包下的类，File类的对象，用于代表当前操作系统的文件（可以是文件、或文件夹）</p><p>注意：File类只能对文件本身进行操作，不能读写文件里面存储的数据</p><p>可以使用相对路径定位文件对象</p><p>只要带盘符的都称之为：绝对路径E:/resource/aaa.jpg</p><p>相对路径：不带盘符，默认是到你的idea工程下直接寻找文件的，一般用来找工程下的项目文件的</p><p>注意只能相对到工程，后边的文件夹名和src还需要手动写</p><h3 id=创建file对象>创建File对象<a hidden class=anchor aria-hidden=true href=#创建file对象>#</a></h3><table><thead><tr><th><strong>构造器</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>public <strong>File(String pathname)</strong></td><td>根据文件路径创建文件对象</td></tr><tr><td>public File(String parent, String child)</td><td>根据父路径和子路径名字创建文件对象</td></tr></tbody></table><p>File对象既可以代表文件、也可以代表文件夹。</p><p>File封装的对象仅仅是一个路径名，这个路径可以是存在的，也允许是不存在的。</p><p>可以用/，也可以用\</p><h3 id=file提供的判断文件类型获取文件信息功能>File提供的判断文件类型、获取文件信息功能<a hidden class=anchor aria-hidden=true href=#file提供的判断文件类型获取文件信息功能>#</a></h3><table><thead><tr><th><strong>方法名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>public boolean exists()</td><td>判断当前文件对象，对应的文件路径是否存在，存在返回true</td></tr><tr><td>public booleanisFile()</td><td>判断当前文件对象指代的是否是文件，是文件返回true，反之。</td></tr><tr><td>public booleanisDirectory()</td><td>判断当前文件对象指代的是否是文件夹，是文件夹返回true，反之。</td></tr><tr><td>public String getName()</td><td>获取文件的名称（包含后缀）</td></tr><tr><td>public long length()</td><td>获取文件的大小，返回字节个数</td></tr><tr><td>public long lastModified()</td><td>获取文件的最后修改时间。</td></tr><tr><td>public String getPath()</td><td>获取创建文件对象时，使用的路径</td></tr><tr><td>public String getAbsolutePath()</td><td>获取绝对路径</td></tr></tbody></table><h3 id=file提供的创建和删除文件的方法>File提供的创建和删除文件的方法<a hidden class=anchor aria-hidden=true href=#file提供的创建和删除文件的方法>#</a></h3><h4 id=file类创建文件的功能>File类创建文件的功能<a hidden class=anchor aria-hidden=true href=#file类创建文件的功能>#</a></h4><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public booleancreateNewFile()</td><td>创建一个新的空的文件</td></tr><tr><td>public booleanmkdir()</td><td>只能创建一级文件夹</td></tr><tr><td>public booleanmkdirs()</td><td>可以创建多级文件夹</td></tr></tbody></table><h4 id=file类删除文件的功能>File类删除文件的功能<a hidden class=anchor aria-hidden=true href=#file类删除文件的功能>#</a></h4><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public boolean delete()</td><td>删除文件、空文件夹</td></tr></tbody></table><p>注意：delete方法默认只能删除文件和空文件夹，删除后的文件不会进入回收站。</p><h3 id=file提供的遍历文件夹的方法>File提供的遍历文件夹的方法<a hidden class=anchor aria-hidden=true href=#file提供的遍历文件夹的方法>#</a></h3><table><thead><tr><th><strong>方法名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>public String[] list()</td><td>获取当前目录下所有的"一级文件名称"到一个字符串数组中去返回。</td></tr><tr><td>public File[] listFiles()</td><td>获取当前目录下所有的"一级文件对象"到一个文件对象数组中去返回（重点）</td></tr></tbody></table><p>使用listFiles方法时的注意事项：</p><p>• 当主调是文件，或者路径不存在时，返回null</p><p>• 当主调是空文件夹时，返回一个长度为0的数组</p><p>• 当主调是一个有内容的文件夹时，将里面所有一级文件和文件夹的路径放在File数组中返回</p><p>• 当主调是一个文件夹，目里面有隐藏文件时，将里面所有文件和文件夹的路径放在File数组中返回，包含隐藏文件</p><p>• 当主调是一个文件夹，但是没有权限访问该文件夹时，返回null</p><h3 id=递归的三要素>递归的三要素<a hidden class=anchor aria-hidden=true href=#递归的三要素>#</a></h3><p>递归的公式： f(n)= f(n-1)*n；</p><p>递归的终结点：f(1)</p><p>递归的方向必须走向终结点</p><h3 id=文件搜索>文件搜索<a hidden class=anchor aria-hidden=true href=#文件搜索>#</a></h3><p>先找出D:盘下的所有一级文件对象</p><p>遍历全部一级文件对象，判断是否是文件</p><p>如果是文件，判断是否是自己想要的</p><p>如果是文件夹，需要继续进入到该文件夹，重复上述过程</p><h3 id=字符集>字符集<a hidden class=anchor aria-hidden=true href=#字符集>#</a></h3><h4 id=标准的ascii编码>标准的ASCII编码<a hidden class=anchor aria-hidden=true href=#标准的ascii编码>#</a></h4><p>ASCII（American Standard Code for Information Interchange）：美国信息交换标准代码，包括了英文、符号等。</p><p>标准ASCIl使用1个字节存储一个字符，首位是0因此，总共可表示128个字符，对美国佬来说完全够用。</p><h4 id=gbk汉字内码扩展规范国标>GBK（汉字内码扩展规范，国标）<a hidden class=anchor aria-hidden=true href=#gbk汉字内码扩展规范国标>#</a></h4><p>汉字编码字符集，包含了2万多个汉字等字符，GBK中一个中文字符编码成两个字节的形式存储。</p><p>注意：GBK兼容了ASCII字符集。</p><p>GBK规定：汉字的第一个字节的第一位必须是1</p><h4 id=unicode字符集统一码也叫万国码>Unicode字符集（统一码，也叫万国码）<a hidden class=anchor aria-hidden=true href=#unicode字符集统一码也叫万国码>#</a></h4><p>Unicode是国际组织制定的，可以容纳世界上所有文字、符号的字符集。</p><h4 id=utf-8字符集>UTF-8字符集<a hidden class=anchor aria-hidden=true href=#utf-8字符集>#</a></h4><p>是Unicode字符集的一种编码方案，采取可变长编码方案，共分四个长度区：1个字书，2个字节，3个字节，4个字节（不像Unicode会占用4个字节，太大了）</p><p>英文字符、数字等只占1个字节（兼容标准ASCII编码），汉字字符占用3个字节。</p><p>前缀码</p><p><img loading=lazy src=/images/Day13%20File%e5%92%8cIO%e6%b5%81.assets/1729823435901-972ccb68-e474-4b59-9b05-b967503e2987.png alt></p><p>注意1：字符编码时使用的字符集，和解码时使用的字符集必须一致，否则会出现乱码</p><p>注意2：英文，数字一般不会乱码，因为很多字符集都兼容了ASCII编码。</p><p>对字符集进行编码</p><table><thead><tr><th><strong>String<strong><strong>提供了如下</strong></strong>方法</strong></th><th>说明</th></tr></thead><tbody><tr><td>byte[] getBytes()</td><td>使用平台的默认字符集将该String编码为一系列字节，将结果存储到新的字节数组中</td></tr><tr><td>byte[] getBytes(String charsetName)</td><td>使用指定的字符集将该 String编码为一系列字节，将结果存储到新的字节数组中</td></tr></tbody></table><p>对字符的解码</p><table><thead><tr><th><strong>String****提供了如下方法</strong></th><th>说明</th></tr></thead><tbody><tr><td>String(byte[] bytes)</td><td>通过使用平台的默认字符集解码指定的字节数组来构造新的 String</td></tr><tr><td>String(byte[] bytes, String charsetName)</td><td>通过指定的字符集解码指定的字节数组来构造新的 String</td></tr></tbody></table><h2 id=io流>IO流<a hidden class=anchor aria-hidden=true href=#io流>#</a></h2><p>用于读写数据的（可以读写文件，或者网络上的数据）</p><h3 id=io流的分类>IO流的分类<a hidden class=anchor aria-hidden=true href=#io流的分类>#</a></h3><p><img loading=lazy src=/images/Day13%20File%e5%92%8cIO%e6%b5%81.assets/1729825830961-517cc21f-db5d-4c98-a694-7097d1d1ed18.png alt></p><h3 id=io流的体系>IO流的体系<a hidden class=anchor aria-hidden=true href=#io流的体系>#</a></h3><h3 id=imagesday1320file和io流assets1729825979601-15275e9f-b64c-4341-8928-28705e5bc020png><img loading=lazy src=/images/Day13%20File%e5%92%8cIO%e6%b5%81.assets/1729825979601-15275e9f-b64c-4341-8928-28705e5bc020.png alt></h3><h3 id=fileinputstream文件字节输入流>FileInputStream（文件字节输入流）<a hidden class=anchor aria-hidden=true href=#fileinputstream文件字节输入流>#</a></h3><p>作用：以内存为基准，可以把磁盘文件中的数据以字节的形式读入到内存中去。</p><table><thead><tr><th><strong>构造器</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>public <strong>FileInputStream(File file)</strong></td><td>创建字节输入流管道与源文件接通</td></tr><tr><td>public <strong>FileInputStream(String pathname)</strong></td><td>创建字节输入流管道与源文件接通</td></tr></tbody></table><table><thead><tr><th><strong>方法名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>public int <strong>read()</strong></td><td>每次读取一个字节返回，如果发现没有数据可读会返回-1，性能较差，而且不能读中文，每次读一个字节的话，中文会乱码</td></tr><tr><td>public int <strong>read(<strong><strong>byte[] buffer</strong></strong>)</strong></td><td>每次用一个字节数组去读取数据，返回字节数组读取了多少个字节，如果发现没有数据可读会返回-1</td></tr></tbody></table><p>使用FilelnputStream每次读取一个字节，读取性能较差，并且读取汉字输出会乱码。</p><p>使用FilelnputStream每次读取多个字节，读取性能得到了提升，但读取汉字输出还是会乱码。</p><p>1、使用字节流读取中文，如何保证输出不乱码，怎么解决？</p><p>定义一个与文件一样大的字节数组，一次性读取完文件的全部字节（只适合读小文件）</p><p>Java提供了方法：</p><table><thead><tr><th><strong>方法名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>public byte[] readAllBytes() throws IOException</td><td>直接将当前字节输入流对应的文件对象的字节数据装到一个字节数组返回</td></tr></tbody></table><p>如果文件过大，创建的字节数组也会过大，可能引起内存溢出。</p><p>读取文本适合用字符流 字节流适合做数据的转移，比如：文件复制</p><h3 id=fileoutputstream文件字节输出流>FileOutputStream文件字节输出流<a hidden class=anchor aria-hidden=true href=#fileoutputstream文件字节输出流>#</a></h3><p>作用：以内存为基准，把内存中的数据以字节的形式写出到文件中去。</p><p></p><p>用完流后都要关闭</p><p>&ldquo;\r\n&rdquo;.getBytes(); // 写出一个换行符</p><table><thead><tr><th><strong>构造器</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>public FileOutputStream(File file)</td><td>创建字节输出流管道与源文件对象接通</td></tr><tr><td>public FileOutputStream(String filepath)</td><td>创建字节输出流管道与源文件路径接通</td></tr><tr><td>public FileOutputStream(File file，boolean append)</td><td>创建字节输出流管道与源文件对象接通，可追加数据，后边跟true表示可以追加</td></tr><tr><td>public FileOutputStream(String filepath，boolean append)</td><td>创建字节输出流管道与源文件路径接通，可追加数据</td></tr></tbody></table><table><thead><tr><th><strong>方法名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>public void write(int a)</td><td>写一个字节出去</td></tr><tr><td>public void write(byte[] buffer)</td><td>写一个字节数组出去</td></tr><tr><td>public void write(byte[] buffer , int pos , int len)</td><td>写一个字节数组的一部分出去。</td></tr><tr><td>public void close() throws IOException</td><td>关闭流。</td></tr></tbody></table><h3 id=资源释放的问题>资源释放的问题<a hidden class=anchor aria-hidden=true href=#资源释放的问题>#</a></h3><h4 id=try-catch-finally>try-catch-finally<a hidden class=anchor aria-hidden=true href=#try-catch-finally>#</a></h4><p>finally代码区的特点：无论try中的程序是正常执行了，还是出现了异常，最后都一定会执行finally区，除非JVM终止。</p><p>作用：一般用于在程序执行完成后进行资源的释放操作（专业级做法），但是比较臃肿</p><h4 id=try-with-resource>try-with-resource<a hidden class=anchor aria-hidden=true href=#try-with-resource>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=k>try</span><span class=p>(</span><span class=n>定义资源1</span><span class=p>;</span><span class=n>定义资源2</span><span class=p>;</span><span class=err>…）</span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>可能出现异常的代码</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=k>catch</span><span class=p>(</span><span class=n>异常类名</span><span class=w> </span><span class=n>变量名</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>异常的处理代码</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>  
</span></span></span></code></pre></div><p>该资源使用完毕后，会自动调用其close()方法，完成对资源的释放！</p><p>()中只能放置资源，否则报错</p><p>什么是资源呢？</p><p>资源一般指的是最终实现了AutoCloseable接口。</p><h3 id=字符流>字符流<a hidden class=anchor aria-hidden=true href=#字符流>#</a></h3><h4 id=filereader文件字符输入流>FileReader文件字符输入流<a hidden class=anchor aria-hidden=true href=#filereader文件字符输入流>#</a></h4><p>作用：以内存为基准，可以把文件中的数据以字符的形式读入到内存中去。</p><p>拓展：文件字符输入流每次读取多个字符，性能较好，而且读取中文是按照字符读取，不会出现乱码！这是一种读取中文很好的方案。</p><table><thead><tr><th><strong>构造器</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>public <strong>FileReader****(File file)</strong></td><td>创建字符输入流管道与源文件接通</td></tr><tr><td>public <strong>FileReader****(String pathname)</strong></td><td>创建字符输入流管道与源文件接通</td></tr></tbody></table><table><thead><tr><th><strong>方法名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>public int <strong>read()</strong></td><td>每次读取一个字符返回，如果发现没有数据可读会返回-1.</td></tr><tr><td>public int <strong>read(<strong><strong>char[] buffer</strong></strong>)</strong></td><td>每次用一个字符数组去读取数据，返回字符数组读取了多少个字符，如果发现没有数据可读会返回-1.</td></tr></tbody></table><p><em>读文档的时候，<strong>不要需加换行符</strong>，文档中自己有换行符</em></p><p>�</p><h4 id=filewriter文件字符输出流>FileWriter文件字符输出流<a hidden class=anchor aria-hidden=true href=#filewriter文件字符输出流>#</a></h4><p>以内存为基准，把内存中的数据以字符的形式写出到文件中去。</p><table><thead><tr><th><strong>构造器</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>public FileWriter(File file)</td><td>创建字节输出流管道与源文件对象接通</td></tr><tr><td>public FileWriter(String filepath)</td><td>创建字节输出流管道与源文件路径接通</td></tr><tr><td>public FileWriter(File file，boolean append)</td><td>创建字节输出流管道与源文件对象接通，可追加数据</td></tr><tr><td>public FileWriter(String filepath，boolean append)</td><td>创建字节输出流管道与源文件路径接通，可追加数据</td></tr></tbody></table><table><thead><tr><th><strong>方法名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>void write(int c)</td><td>写一个字符</td></tr><tr><td>void write(String str)</td><td>写一个字符串</td></tr><tr><td>void write(String str, int off, int len)</td><td>写一个字符串的一部分</td></tr><tr><td>void write(char[] cbuf)</td><td>写入一个字符数组</td></tr></tbody></table><p>字符输出流写出数据后，必须刷新流，或者关闭流，写出去的数据才能生效</p><table><thead><tr><th><strong>方法名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>public void flush() throws IOException</td><td>刷新流，就是将内存中缓存的数据立即写到文件中去生效！</td></tr><tr><td>public void close() throws IOException</td><td>关闭流的操作，包含了刷新！</td></tr></tbody></table><p>使用close就会默认刷新，或者使用try with resource也会默认在关闭的时候刷新</p><h4 id=bufferedinputstream缓冲字节输入和输出流>BufferedInputstream缓冲字节输入和输出流<a hidden class=anchor aria-hidden=true href=#bufferedinputstream缓冲字节输入和输出流>#</a></h4><p>作用：可以提高字节输入流读取数据的性能</p><p>原理：缓冲字节输入流自带了8KB缓冲池；缓冲字节输出流也自带了8KB缓冲池。</p><table><thead><tr><th><strong>构造器</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>public BufferedInputStream(InputStream is)</td><td>把低级的字节输入流包装成一个高级的缓冲字节输入流，从而提高读数据的性能</td></tr><tr><td>public BufferedOutputStream(OutputStreamos)</td><td>把低级的字节输出流包装成一个高级的缓冲字节输出流，从而提高写数据的性能</td></tr></tbody></table><h4 id=bufferedreader缓冲字符输入流>BufferedReader缓冲字符输入流<a hidden class=anchor aria-hidden=true href=#bufferedreader缓冲字符输入流>#</a></h4><p>作用：自带8K（8192）的字符缓冲池，可以提高字符输入流读取字符数据的性能。</p><table><thead><tr><th><strong>构造器</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>public BufferedReader(Reader r)</td><td>把低级的字符输入流包装成字符缓冲输入流管道，从而提高字符输入流读字符数据的性能</td></tr></tbody></table><p><strong>字符缓冲输入流新增的功能：按照行读取字符</strong></p><table><thead><tr><th><strong>方法</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>public String readLine()</td><td>读取一行数据返回，如果没有数据可读了，会返回null</td></tr></tbody></table><h4 id=bufferedwriter缓冲字符输出流>Bufferedwriter缓冲字符输出流<a hidden class=anchor aria-hidden=true href=#bufferedwriter缓冲字符输出流>#</a></h4><p>作用：自带8K的字符缓冲池，可以提高字符输出流写字符数据的性能。</p><table><thead><tr><th><strong>构造器</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>public BufferedWriter(Writer r)</td><td>把低级的字符输出流包装成一个高级的缓冲字符输出流管道，从而提高字符输出流写数据的性能（把低级管道变成一个高级管道，里边包着一个高级管道）</td></tr></tbody></table><p><strong>字符缓冲输出流新增的功能：换行</strong></p><table><thead><tr><th><strong>方法</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>public void newLine()</td><td>换行</td></tr></tbody></table><p><strong>可以把低级管道的缓冲桶加大，那么这样性能就会接近高级管道，所以并不是低级管道的新能一定差，相对来说，桶越大，复制速度越快</strong></p><h3 id=其他流>其他流<a hidden class=anchor aria-hidden=true href=#其他流>#</a></h3><h4 id=inputstreamreader字节输入转换流>InputStreamReader（字节输入转换流）<a hidden class=anchor aria-hidden=true href=#inputstreamreader字节输入转换流>#</a></h4><p>解决不同编码时，字符流读取文本内容乱码的问题。</p><p>解决思路： 先获取文件的原始字节流再将其按真实的字符集编码转成字符输入流，这样字符输入流中的字符就不乱码了。</p><p>这也是个高级流，里边可以包着一个低级流</p><table><thead><tr><th><strong>构造器</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>public InputStreamReader(InputStream is)</td><td>把原始的字节输入流，按照代码默认编码转成字符输入流（与直接用FileReader的效果一样）</td></tr><tr><td>public <strong>InputStreamReader(InputStream is ，String charset)</strong></td><td>把原始的字节输入流，按照指定字符集编码转成字符输入流(重点)</td></tr></tbody></table><h4 id=printstreamprintwriter打印流>PrintStream/PrintWriter（打印流）<a hidden class=anchor aria-hidden=true href=#printstreamprintwriter打印流>#</a></h4><p>作用：打印流可以实现更方便、更高效的打印数据出去，能实现打印啥出去就是啥出去，性能也高。</p><p><strong>PrintStream提供的打印数据的方案</strong></p><table><thead><tr><th><strong>构造器</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>public <strong>PrintStream</strong>(OutputStream/File/<strong>String</strong>)</td><td>打印流直接通向字节输出流/文件/文件路径</td></tr><tr><td>publicPrintStream(String fileName, Charset charset)</td><td>可以指定写出去的字符编码</td></tr><tr><td>publicPrintStream(OutputStream out, boolean autoFlush)</td><td>可以指定实现自动刷新</td></tr><tr><td>publicPrintStream(OutputStream out, boolean autoFlush, String encoding)</td><td>可以指定实现自动刷新，并可指定字符的编码</td></tr></tbody></table><table><thead><tr><th><strong>方法</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>public void <strong>println<strong><strong>(</strong></strong>Xxx**** xx)</strong></td><td>打印任意类型的数据出去，天生自带换行</td></tr><tr><td>public void write(int/byte[]/byte[]一部分)</td><td>可以支持写<strong>字节</strong>数据出去</td></tr></tbody></table><p><strong>PrintWriter提供的打印数据的方案</strong></p><table><thead><tr><th><strong>构造器</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>public <strong>Print****Writer</strong>(OutputStream/Writer/File/<strong>String</strong>)</td><td>打印流直接通向字节输出流/文件/文件路径</td></tr><tr><td>publicPrintWriter(String fileName, Charset charset)</td><td>可以指定写出去的字符编码</td></tr><tr><td>publicPrintWriter(OutputStream out/Writer, boolean autoFlush)</td><td>可以指定实现自动刷新</td></tr><tr><td>publicPrintWriter(OutputStream out, boolean autoFlush, String encoding)</td><td>可以指定实现自动刷新，并可指定字符的编码</td></tr></tbody></table><table><thead><tr><th><strong>方法</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>public void <strong>println<strong><strong>(</strong></strong>Xxx**** xx)</strong></td><td>打印任意类型的数据出去</td></tr><tr><td>public void write(int/String/char[]/..)</td><td>可以支持写字符数据出去</td></tr></tbody></table><h4 id=printstream和printwriter的区别>PrintStream和PrintWriter的区别<a hidden class=anchor aria-hidden=true href=#printstream和printwriter的区别>#</a></h4><p><strong>• 打印数据的功能上是一模一样的：都是使用方便，性能高效（核心优势）</strong></p><p><strong>• PrintStream继承自字节输出流OutputStream，因此支持写</strong>**字节数据**<strong>的方法。</strong></p><p><strong>• PrintWriter继承自</strong>**字符输出<strong><strong>流Writer，因此支持</strong></strong>写字符数据**<strong>出去。</strong></p><h4 id=dataoutputstream数据输出流>DataOutputStream（数据输出流）<a hidden class=anchor aria-hidden=true href=#dataoutputstream数据输出流>#</a></h4><p>允许把数据和其类型一并写出去。</p><table><thead><tr><th><strong>构造器</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>public <strong>DataOutputStream<strong><strong>(</strong></strong>OutputStream**** out)</strong></td><td>创建新数据输出流包装基础的字节输出流</td></tr></tbody></table><table><thead><tr><th><strong>方法</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>public final void writeByte(int v) throws IOException</td><td>将byte类型的数据写入基础的字节输出流</td></tr><tr><td>public final void <strong>writeInt****(int v) </strong>throws IOException</td><td>将int类型的数据写入基础的字节输出流</td></tr><tr><td>public final void<strong> <strong><strong>writeDouble</strong></strong>(Double v) </strong>throws IOException</td><td>将double类型的数据写入基础的字节输出流</td></tr><tr><td>public final void<strong> <strong><strong>writeUTF</strong></strong>(String str)</strong> throws IOException</td><td>将字符串数据以UTF-8编码成字节写入基础的字节输出流</td></tr><tr><td>public void write(int/byte[]/byte[]一部分)</td><td>支持写字节数据出去</td></tr></tbody></table><h4 id=datalnputstream数据输入流>DatalnputStream（数据输入流）<a hidden class=anchor aria-hidden=true href=#datalnputstream数据输入流>#</a></h4><p>用于读取数据输出流写出去的数据。</p><table><thead><tr><th><strong>构造器</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>public <strong>DataInputStream<strong><strong>(</strong></strong>InputStream**** is)</strong></td><td>创建新数据输入流包装基础的字节输入流</td></tr></tbody></table><table><thead><tr><th><strong>方法</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>Public final byte readByte() throws IOException</td><td>读取字节数据返回</td></tr><tr><td>public final int <strong>readInt****() </strong>throws IOException</td><td>读取int类型的数据返回</td></tr><tr><td>public final double<strong> <strong><strong>readDouble</strong></strong>() </strong>throws IOException</td><td>读取double类型的数据返回</td></tr><tr><td>public final String<strong> <strong><strong>read</strong></strong>UTF****()</strong> throws IOException</td><td>读取字符串数（UTF-8）据返回</td></tr><tr><td>public int readInt()/read(byte[])</td><td>支持读字节数据进来</td></tr></tbody></table><h3 id=io框架>IO框架<a hidden class=anchor aria-hidden=true href=#io框架>#</a></h3><p>什么是框架？</p><p>框架（Framework）是一个预先写好的代码库或一组工具，旨在简化和加速开发过程</p><p>框架的形式：一般是把类、接口等编译成class形式，再压缩成一个.jar结尾的文件发行出去</p><p>导入commons-io-2.11.0jar框架到项目的步骤</p><p>① 在项目中创建一个文件夹：lib</p><p>② 将commons-io-2.6.jar文件复制到1ib文件夹</p><p>③ 在jar文件上点右键，选择 Add as Library -> 点击OK</p><p>④ 在类中导包使用</p><p>Commons-io框架</p><p>Commons-io是apache开源基金组织提供的一组有关IO操作的小框架，目的是提高IO流的开发效率。</p><table><thead><tr><th>FileUtils类提供的部分方法展示</th><th>说明</th></tr></thead><tbody><tr><td>public static void <strong>copyFile</strong>(File srcFile, File destFile)</td><td>复制文件。</td></tr><tr><td>public static void <strong>copyDirectory</strong>(File srcDir, File destDir)</td><td>复制文件夹</td></tr><tr><td>public static void <strong>deleteDirectory</strong>(File directory)</td><td>删除文件夹</td></tr><tr><td>public static String <strong>readFileToString</strong>(File file, String encoding)</td><td>读数据</td></tr><tr><td>public static void <strong>writeStringToFile</strong>(File file, String data, String charname, boolean append)</td><td>写数据</td></tr></tbody></table><table><thead><tr><th>IOUtils类提供的部分方法展示</th><th>说明</th></tr></thead><tbody><tr><td>public static int <strong>copy</strong>(InputStreaminputStream, OutputStreamoutputStream)</td><td>复制文件。</td></tr><tr><td>public static int <strong>copy</strong>(Reader reader, Writer writer)</td><td>复制文件。</td></tr><tr><td>public static void <strong>write</strong>(String data, OutputStream output, String charsetName)</td><td>写数据</td></tr></tbody></table></div><footer class=post-footer><ul class=post-tags><li><a href=https://wqnm1gb.github.io/tags/java%E5%9F%BA%E7%A1%80/>Java基础</a></li></ul><nav class=paginav><a class=prev href=https://wqnm1gb.github.io/posts/day14-thread/><span class=title>« 上一页</span><br><span>Day14 Thread</span>
</a><a class=next href=https://wqnm1gb.github.io/posts/day12-mapstream%E6%B5%81/><span class=title>下一页 »</span><br><span>Day12 Map、Stream流</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://wqnm1gb.github.io/>三狗子的博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>