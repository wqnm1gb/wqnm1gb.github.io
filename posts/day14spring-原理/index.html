<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Day14 Spring-原理 | 三狗子的博客</title>
<meta name=keywords content="java Web"><meta name=description content="SpringBoot原理
配置优先级


虽然springboot支持多种格式配置文件，但是在项目开发时，推荐统一使用一种格式的配置 （yml是主流）
SpringBoot 除了支持配置文件属性配置，还支持Java系统属性和命令行参数的方式进行属性配置。"><meta name=author content="冷漠三狗子丶"><link rel=canonical href=https://wqnm1gb.github.io/posts/day14spring-%E5%8E%9F%E7%90%86/><link crossorigin=anonymous href=/assets/css/stylesheet.3d688279d829dc24da48acd11f9e33ebea2f39c035e899e1bf4297d8b7aa89b9.css integrity="sha256-PWiCedgp3CTaSKzRH54z6+ovOcA16Jnhv0KX2Leqibk=" rel="preload stylesheet" as=style><link rel=icon href=https://wqnm1gb.github.io/images/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://wqnm1gb.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wqnm1gb.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wqnm1gb.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://wqnm1gb.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://wqnm1gb.github.io/posts/day14spring-%E5%8E%9F%E7%90%86/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel=stylesheet><script type=text/javascript async src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["[[","]]"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=" has-jax"})</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style><meta property="og:title" content="Day14 Spring-原理"><meta property="og:description" content="SpringBoot原理
配置优先级


虽然springboot支持多种格式配置文件，但是在项目开发时，推荐统一使用一种格式的配置 （yml是主流）
SpringBoot 除了支持配置文件属性配置，还支持Java系统属性和命令行参数的方式进行属性配置。"><meta property="og:type" content="article"><meta property="og:url" content="https://wqnm1gb.github.io/posts/day14spring-%E5%8E%9F%E7%90%86/"><meta property="og:image" content="https://wqnm1gb.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-03-06T10:11:11+08:00"><meta property="article:modified_time" content="2025-03-06T10:11:11+08:00"><meta property="og:site_name" content="三狗子的博客"><meta property="fb:admins" content="your-facebook-admin-id"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wqnm1gb.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Day14 Spring-原理","item":"https://wqnm1gb.github.io/posts/day14spring-%E5%8E%9F%E7%90%86/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Day14 Spring-原理","name":"Day14 Spring-原理","description":"SpringBoot原理 配置优先级 虽然springboot支持多种格式配置文件，但是在项目开发时，推荐统一使用一种格式的配置 （yml是主流）\nSpringBoot 除了支持配置文件属性配置，还支持Java系统属性和命令行参数的方式进行属性配置。\n","keywords":["java Web"],"articleBody":"SpringBoot原理 配置优先级 虽然springboot支持多种格式配置文件，但是在项目开发时，推荐统一使用一种格式的配置 （yml是主流）\nSpringBoot 除了支持配置文件属性配置，还支持Java系统属性和命令行参数的方式进行属性配置。\n打包成jar包之后如何指定配置\nSpringboot项目进行打包时，需要引入插件** spring-boot-maven-plugin**（基于官网骨架创建项目，会自动添加该插件）\n配置属性中，命令行属性的优先级是最高的，其次是java系统属性，其次是application.prope，其次是application.yml，最后是application.yaml\n外部配置项的优先级是优于内部配置文件的\nBean管理 Bean作用域 Spring支持五种作用域，后三种在web环境才生效：\n作用域 说明 singleton 容器内同 名称的 bean 只有一个实例（单例）（默认） prototype 每次使用该 bean 时会创建新的实例（非单例/多例） request 每个请求范围内会创建新的实例（web环境中，了解） session 每个会话范围内会创建新的实例（web环境中，了解） application 每个应用范围内会创建新的实例（web环境中，了解） 没有为bean指定类名，默认是类名首字母小写\n单例的bean默认是在项目启动时，就创建，然后会将bean对象存入IOC容器\n@Lazy可以延迟实例化，第一次使用的时候实例化\n// 注意要加SpringBootTest注解，用于在测试环境中加载 Spring 应用上下文 @SpringBootTest public class ScopeTest { @Autowired private ApplicationContext applicationContext; // 获取IOC容器对象 @Test public void testScope(){ for (int i = 0; i \u003c 100; i++) { DeptController deptController = applicationContext.getBean(DeptController.class); System.out.println(deptController); } } } 作用域设置成了 prototype 所以运行的时候产生的DeptController对象是不一样的\n第三方Bean 如果要管理的bean对象来自于第三方（不是自定义的），是无法用@Component 及衍生注解声明bean的，就需要用到 @Bean注解。\n若要管理的第三方bean对象，建议对这些bean进行集中分类配置（推荐），可以通过@Configuration注解声明一个配置类。\n有两种声明方法，一个是放在启动类中，一个是集中分类配置\n如果第三方bean需要依赖其它bean对象，直接在bean定义方法中设置形参即可，容器会根据类型自动装配。如果声明的方法的参数中调用的对象，没有在IOC容器中，那么就会报错\n@Configuration 这个注解记得要加！\n@Configuration public class OSSconfig { @Bean // 黄色的这个必须在IOC容器中，相当于省略了@Autowired public AliyunOSSOperator aliyunOSSOperator(AliyunOSSProperties aliyunOSSProperties){ return new AliyunOSSOperator(aliyunOSSProperties); } } 通过@Bean注解的name或value属性可以声明bean的名称，如果不指定，默认bean的名称就是方法名。\nSpringBoot原理 起步依赖的原理是Maven依赖传递\n一旦声明了@ComponentScan这个注解，默认的扫描范围（启动类所在包及其子包）就不再生效了，需要添加上原来扫描的包\n自动配置 SpringBoot的自动配置就是当spring项目启动后，一些配置类、bean对象就自动存入到了IOC容器中，不需要我们手动去声明，从而简化了开发，省去了繁琐的配置操作。\n比如说谷歌的这Gson类，可以把数据转化成Json格式，我们并没有手动引入，但是aliyun的一个依赖中引入，所以我们也可以调用\n@Test public void testGson(){ System.out.println(gson.toJson(Result.success(\"hello,world!\"))); } 运行结果：\n实现方案1：@Conponent+@ConponentScan 想要在@ComponentScan中被扫描到，需要在pom.xml中引入依赖\n\u003cdependency\u003e \u003cgroupId\u003ecom.example\u003c/groupId\u003e \u003cartifactId\u003eitheima-utils\u003c/artifactId\u003e \u003cversion\u003e0.0.1-SNAPSHOT\u003c/version\u003e \u003c/dependency\u003e 手动配置扫描范围，具有使用繁琐，性能低的缺点\n@ComponentScan({\"com.example\",\"com.zzzzyj\"}) @SpringBootApplication public class SpringbootAopQuickstartApplication { public static void main(String[] args) { SpringApplication.run(SpringbootAopQuickstartApplication.class, args); } } 实现方案2：@Import类导入 @Import导入。@Import导入的类会被Spring加载到IOC容器中，导入形式主要有以下几种：\n导入普通类 导入配置类 导入 ImportSelector 接口实现类 返回一个数组，可以里边添加很多类 实现selectImport方法 public class MyImportSelector implements ImportSelector { public String[] selectImports(AnnotationMetadata importingClassMetadata) { return new String[]{\"com.example.HeaderConfig\"}; } } @EnableXxxx注解，封装@Import注解（方便 优雅） // 导入普通类或者配置类 @Import(HeaderConfig.class) // 导入 ImportSelector 接口实现类 @Import(MyImportSelector.class) // @EnableXxxx注解，封装@Import注解 @EnableHeaderConfig 自动配置-源码跟踪 @SpringBootApplication public class SpringbootAopQuickstartApplication { public static void main(String[] args) { SpringApplication.run(SpringbootAopQuickstartApplication.class, args); } } @SpringBootApplication\n该注解标识在SpringBoot工程引导类上，是SpringBoot中最最最重要的注解。该注解由三个部分组成：\n@SpringBootConfiguration：该注解与 @Configuration 注解作用相同，用来声明当前也是一个配置类。启动类也是一个配置类，所以可以声明第三方，底层封装了@Configuration @ComponentScan：组件扫描，默认扫描当前引导类所在包及其子包。 @EnableAutoConfiguration：SpringBoot实现自动化配置的核心注解。 自动配置的原理，可以看https://heuqqdmbyk.feishu.cn/wiki/P8fNwBnSRiA6wWksjExcUZ4YnFe里边的飞书云文档\n这里还是分析一下\n点进去，里边出了元注解还有另外三个注解，接下来一个一个分析\n**@SpringBootConfiguration**\n也就是里边关键的就两个\n@Configuration 这个上边讲过了，这就是一个说明这是个集中配置类的注解\n@Indexed 这个是用来加速启动的，不需要关心\n**@ComponentScan**\n@ComponentScan 注解是用来进行组件扫描的，扫描启动类所在的包及其子包下所有被@Component及其衍生注解声明的类。\nSpringBoot启动类，之所以具备扫描包功能，就是因为包含了@ComponentScan注解\n**@EnableAutoConfiguration**** 自动配置核心注解**\n里边包含了这些：\n使用@Import注解，导入了实现ImportSelector接口的实现类。\nAutoConfigurationImportSelector类是ImportSelector接口的实现类。\n里边重写了ImportSelector中的selectImports()方法\n我们现在来分析一下这个方法\nselectImports()方法底层调用getAutoConfigurationEntry()方法，获取可自动配置的配置类信息集合\n所以说我们来分析一下getAutoConfigurationEntry()方法\ngetAutoConfigurationEntry()方法通过调用getCandidateConfigurations(annotationMetadata, attributes)方法获取在配置文件中配置的所有自动配置类的集合\n再来分析一下getCandidateConfigurations()这个方法\ngetCandidateConfigurations方法的功能：\n获取所有基于 META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports文件中配置类的集合\nMETA-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports文件这两个文件在哪里呢？\n通常在引入的起步依赖中，都有包含以上文件\n在前面演示自动配置的时候，我们直接在测试类当中注入了一个叫gson的bean对象，进行JSON格式转换。虽然我们没有配置bean对象，但是我们是可以直接注入使用的。原因就是因为在自动配置类当中做了自动配置。到底是在哪个自动配置类当中做的自动配置呢？我们通过搜索来查询一下。\n打开上面的第三方依赖中提供的 GsonAutoConfiguration类（双击shift实现）\n打开@AutoConfiguration\n原理就是在配置类中定义一个@Bean标识的方法，而Spring会自动调用配置类中使用@Bean标识的方法，并把方法的返回值注册到IOC容器中。\n小结\n@SpringBootConfiguration\n- **声明当前类是一个配置类** @ComponentScan\n- **进行组件扫描（SpringBoot中默认扫描的是启动类所在的当前包及其子包）** @EnableAutoConfiguration\n- **封装了@Import注解（Import注解中指定了一个ImportSelector接口的实现类）** - 在实现类重写的selectImports()方法，读取当前项目下所有依赖jar包中`META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports`两个文件里面定义的配置类（配置类中定义了@Bean注解标识的方法）。 当SpringBoot程序启动时，就会加载配置文件当中所定义的配置类，并将这些配置类信息(类的全限定名)封装到String类型的数组中，最终通过@Import注解将这些配置类全部加载到Spring的IOC容器中，交给IOC容器管理。\n在 META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports 文件中定义的配置类非常多，而且每个配置类中又可以定义很多的bean，那这些bean都会注册到Spring的IOC容器中吗？\n答案：并不是。 在声明bean对象时，上面有加一个以 @Conditional 开头的注解，这种注解的作用就是按照条件进行装配，只有满足条件之后，才会将bean注册到Spring的IOC容器中（下面会详细来讲解）\n@Conditional 作用：按照一定的条件进行判断，在满足给定条件后才会注册对应的bean对象到Spring的IOC容器中。\n位置：方法、类\n@Conditional本身是一个父注解，派生出大量的子注解：\n@ConditionalOnClass：判断环境中有对应字节码文件，才注册bean到IOC容器。 @ConditionalOnMissingBean：判断环境中没有对应的bean（类型或名称），才注册bean到IOC容器。 @ConditionalOnProperty：判断配置文件中有对应属性和值，才注册bean到IOC容器。 笔记文档中有详细的代码判断。\n自定义starter 场景：在实际开发中，经常会定义一些公共组件，提供给各个项目团队使用。而在SpringBoot的项目中，一般会将这些公共组件封装为SpringBoot的starter（包含了起步依赖和自动配置的功能）。\nstarter就是一个一个的依赖\n需求：自定义aliyun-oss-spring-boot-starter，完成阿里云OSS操作工具类 Aliyunossoperator 的自动配置。 目标：引入起步依赖引入之后，要想使用阿里云OSS，注入 AliyunOSSOperator 直接使用即可。 步骤： 创建aliyun-oss-spring-boot-starter模块 创建aliyun-oss-spring-boot-autoconfigure模块，在starter中引入该模块 在aliyun-oss-spring-boot-autoconfigure模块中的定义自动配置功能，并定义自动配置文件 META-INF/spring/xxxx.imports 下边详细分析一下自定义starter的实现步骤\n首先定义两个模块，其中starter模块只需要保留pom.xml文件，里边引用autoconfigure，代码等功能的实现都在autoconfigure模块中\n接下来分析一下autoconfigure模块\n其中后两个类是用来实现文件上传功能的，但是里边的@Component注解没有用了，在SpringBoot项目中，并不会去扫描com.aliyun.oss这个包，不扫描这个包那类上的注解也就失去了作用。\n就可以删除里边的Component和Autowired注解，同时需要按照 starter 的定义规范，定义一个自动配置类，在自动配置类中声明bean。\npackage com.aliyun.oss; import org.springframework.boot.context.properties.EnableConfigurationProperties; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration @EnableConfigurationProperties(AliyunOSSProperties.class) public class AliyunOSSAutoConfiguration { @Bean public AliyunOSSOperator aliyunOSSOperator(AliyunOSSProperties aliyunOSSProperties) { return new AliyunOSSOperator(aliyunOSSProperties); } } 之前思考的问题，为什么不能new一个AliyunOSSProperties，是因为他没有在IOC容器中，不能new一个，找不到这个对象，所以需要传进来，那么会问，怎么传，不也要在IOC容器中才能传递吗，所以我需要@EnableConfigurationProperties(AliyunOSSProperties.class) 这个注解里边包括了@Import注解，可以直接导入数据\n文件里边是全类名\ncom.aliyun.oss.AliyunOSSAutoConfiguration 思考的一个问题\n为什么在本地配置的yml文件是可行的\n其实这个问题很简单，因为我们引入了IOC，相当于是把之前写的那些类也就是放在了本地运行，所以在本地配置就可以了。\nMaven高级 分模块设计与开发 如果全都写在一个模块里，不便于维护，难以复用\n分模块设计示例图：\n将一个大项目拆分成若干个子模块，方便项目的管理维护、扩展，也方便模块间的相互引用，资源共享。\n分模块设计的策略 策略一：按照功能模块拆分，比如：公共组件、商品模块、搜索模块、购物车模块、订单模块等。 策略二：按层拆分，比如：公共组件、实体类、控制层、业务层、数据访问层。 策略三：按照功能模块 + 层拆分。 实战 分模块开发需要先针对模块功能进行设计，再进行编码。不会先将工程开发完毕，然后进行拆分。\n创建项目后，需要检查jdk的版本是否正确，还有就是Maven的环境是否正确\n拆分之后，因为原来的项目中有引入SpringBoot所以里边的Lombok没有指定版本，但是拆分pojo的时候，并不需要引入SpringBoot所以需要指定版本\n在Maven的控制面板里边可以看到之前的版本号\n还用到了，这个是Spring的核心包，只需要引入Spring的核心包就行\n核心包就叫做spring-boot-start\n原项目还需要引入pojo\n继承与聚合 提出的原因是：\n如果多个模块都要引用同一个依赖，每个模块都写会很复杂，所以抽取成为父模块\n概念：继承描述的是两个工程间的关系，与java中的继承相似，子工程可以继承父工程中的配置信息，常见于依赖关系的继承。\n作用：简化依赖配置、统一管理依赖\n实现：…\nmaven和java一样不支持多继承，但支持多重继承\n继承关系实现 创建maven模块tlias-parent，该工程为父工程，设置打包方式pom（默认jar）。 在子工程的pom.xml文件中，配置继承关系。 在父工程中配置各个工程共有的依赖（子工程会自动继承父工程的依赖）。 **jar：**普通模块打包，SR ngoot项目基本都是jar包（内嵌tomcat运行）\n**war：**普通web程序打包，需要部署在外部的tomcat服务器中运行\n**pom：**父工程或聚合工程，该模块不写代码，仅进行依赖管理\n父工程需要配置相对路径，如果自闭合，就是不配置相对路径的话，会先从本地仓库中寻找，如果没有，再从中央仓库中寻找\n在子工程中，配置了继承关系之后，坐标中的groupId是可以省略的，因为会自动继承父工程的。\nrelativePath指定父工程的pom文件的相对位置（如果不指定，将从本地仓库/远程仓库查找）。\n若父子工程都配置了同一个依赖的不同版本，以子工程的为准。\n配置的时候从当前项目开始，找到xml文件\n不是公共的依赖，不建议在父工程中引入，会耗费资源\n版本锁定 在maven中，可以在父工程的pom文件中通过 来统一管理依赖版本，注意这里边还需要标签\n属性配置 解决了什么问题：\n因为实际的项目中会有很多的如果需要一个一个查找会很麻烦，一个会占用很多行，所以直接在中定义版本号\n名字需要保持一致\n聚合 聚合\n将多个模块组织成一个整体，同时进行项目的构建。\n聚合工程\n一个不具有业务功能的“空”工程（有且仅有一个pom文件）\n作用\n快速构建项目（无需根据依赖关系手动构建，直接在聚合工程上构建即可）\n实现\nmaven中可以通过设置当前聚合工程所包含的子模块名称\n\u003cmodules\u003e \u003cmodule\u003e../tlias-pojo\u003c/module\u003e \u003cmodule\u003e../tlias-utils\u003c/module\u003e \u003cmodule\u003e../tlias-web-management\u003c/module\u003e \u003c/modules\u003e 聚合工程中所包含的模块，在构建时，会自动根据模块间的依赖关系设置构建顺序，与聚合工程中模块的配置书写位置无关。\nmaven中继承与聚合的区别\n联系：继承与聚合都属于设计型模块，打包方式都为pom，常将两种关系制作到同一个pom文件中\n区别：\n继承用于简化依赖配置、统一管埋依赖版本，是在子工程中配置继承关系 聚合用于快速构建项目，是在父工程（聚合工程）中配置聚合的模块 私服 私服是一种特殊的远程仓库，它是架设在局域网内的仓库服务，用来代理位于外部的中央仓库，用于解决团队内部的资源共享与资源同步问题。\n私服在企业项目开发中，一个项目/公司，只需要一台即可（无需我们自己搭建，会使用即可）。\n依赖查找顺序：\n本地仓库 -\u003e 私服 -\u003e 中央仓库\n资源的上传与下载\n项目版本：\nRELEASE（发行版本）：功能趋于稳定、当前更新停止，可以用于发行的版本，存储在私服中的RELEASE仓库中。\nSNAPSHOT（快照版本）：功能不稳定、尚处于开发中的版本，即快照版本，存储在私服的SNAPSHOT仓库中。\n步骤：\n1、设置私服的访问用户名/密码（settings.xmL中的servers中配置）\n2、IDEA的maven工程的pom文件中配置上传（发布）地址\n3、设置私服依赖下载的仓库组地址（settings.xml中的mirrors、profiles中配置）\nWeb后端开发总结 阿里云OSS - 对象存储的解决方案\nJWT - 会话跟踪的解决方案\nSpringMVC 是Spring框架的一部分\n","wordCount":"7018","inLanguage":"zh","image":"https://wqnm1gb.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-03-06T10:11:11+08:00","dateModified":"2025-03-06T10:11:11+08:00","author":{"@type":"Person","name":"冷漠三狗子丶"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wqnm1gb.github.io/posts/day14spring-%E5%8E%9F%E7%90%86/"},"publisher":{"@type":"Organization","name":"三狗子的博客","logo":{"@type":"ImageObject","url":"https://wqnm1gb.github.io/images/favicon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wqnm1gb.github.io/ accesskey=h title="主页 (Alt + H)"><img src=https://wqnm1gb.github.io/apple-touch-icon.png alt aria-label=logo height=35>主页</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wqnm1gb.github.io/ title=三狗子的博客><span>首页</span></a></li><li><a href=https://wqnm1gb.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://wqnm1gb.github.io/categories/ title=Categories><span>分类</span></a></li><li><a href=https://wqnm1gb.github.io/tags/ title=Tags><span>标签</span></a></li><li><a href=https://wqnm1gb.github.io/search/ title=搜索><span>搜索</span></a></li><li><a href=https://wqnm1gb.github.io/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://wqnm1gb.github.io/>主页</a>&nbsp;»&nbsp;<a href=https://wqnm1gb.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Day14 Spring-原理</h1><div class=post-meta><span title='2025-03-06 10:11:11 +0800 +0800'>三月 6, 2025</span>&nbsp;·&nbsp;15 分钟&nbsp;·&nbsp;7018 字&nbsp;·&nbsp;冷漠三狗子丶</div></header><div class=post-content><h1 id=springboot原理>SpringBoot原理<a hidden class=anchor aria-hidden=true href=#springboot原理>#</a></h1><h2 id=配置优先级>配置优先级<a hidden class=anchor aria-hidden=true href=#配置优先级>#</a></h2><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735439988115-b6256d2b-42e0-498c-bf99-d470cad28ad5.png alt></p><p>虽然springboot支持多种格式配置文件，但是在项目开发时，推荐统一使用一种格式的配置 （yml是主流）</p><p>SpringBoot 除了支持配置文件属性配置，还支持<strong>Java系统属性和命令行参数</strong>的方式进行属性配置。</p><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735440555730-dbe1b00f-6519-48cf-a566-fb537d08bebd.png alt></p><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735440589891-b2c439ec-cb88-472b-9d63-b8ae512fc8ed.png alt></p><p>打包成jar包之后如何指定配置</p><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735440624049-accfb797-c681-4eae-aebf-3afa9297bb64.png alt></p><p>Springboot项目进行打包时，需要引入插件** spring-boot-maven-plugin**（基于官网骨架创建项目，会自动添加该插件）</p><p>配置属性中，<strong>命令行属性</strong>的优先级是最高的，其次是<strong>java系统属性</strong>，其次是<strong>application.prope</strong>，其次是<strong>application.yml</strong>，最后是<strong>application.yaml</strong></p><p><strong>外部配置项的优先级是优于内部配置文件的</strong></p><hr><h2 id=bean管理>Bean管理<a hidden class=anchor aria-hidden=true href=#bean管理>#</a></h2><h3 id=bean作用域>Bean作用域<a hidden class=anchor aria-hidden=true href=#bean作用域>#</a></h3><p><strong>Spring支持五种作用域，后三种在web环境才生效：</strong></p><table><thead><tr><th style=text-align:center><strong>作用域</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td style=text-align:center>singleton</td><td>容器内同 名称的 bean 只有一个实例（单例）（默认）</td></tr><tr><td style=text-align:center>prototype</td><td>每次使用该 bean 时会创建新的实例（非单例/多例）</td></tr><tr><td style=text-align:center>request</td><td>每个请求范围内会创建新的实例（web环境中，了解）</td></tr><tr><td style=text-align:center>session</td><td>每个会话范围内会创建新的实例（web环境中，了解）</td></tr><tr><td style=text-align:center>application</td><td>每个应用范围内会创建新的实例（web环境中，了解）</td></tr></tbody></table><p>没有为bean指定类名，默认是类名首字母小写</p><p>单例的bean默认是在项目启动时，就创建，然后会将bean对象存入IOC容器</p><p>@Lazy可以延迟实例化，第一次使用的时候实例化</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// 注意要加SpringBootTest注解，用于在测试环境中加载 Spring 应用上下文</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@SpringBootTest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>ScopeTest</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Autowired</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>ApplicationContext</span><span class=w> </span><span class=n>applicationContext</span><span class=p>;</span><span class=w> </span><span class=c1>// 获取IOC容器对象</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Test</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>testScope</span><span class=p>(){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>100</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>DeptController</span><span class=w> </span><span class=n>deptController</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>applicationContext</span><span class=p>.</span><span class=na>getBean</span><span class=p>(</span><span class=n>DeptController</span><span class=p>.</span><span class=na>class</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>deptController</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>作用域设置成了 prototype 所以运行的时候产生的DeptController对象是不一样的</p><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735521239969-a34126d3-1d02-447b-8a1d-8e4b83dc3c82.png alt>
<img loading=lazy src=/images/https://cdn.nlark.com/yuque/0/2024/png/28219979/1735521215528-4b0bbcef-4d3f-47a9-8f71-bbe9abf37d43.png alt></p><h3 id=第三方bean>第三方Bean<a hidden class=anchor aria-hidden=true href=#第三方bean>#</a></h3><p>如果要管理的bean对象来自于第三方（不是自定义的），是无法用@Component 及衍生注解声明bean的，就需要用到 @Bean注解。</p><p>若要管理的第三方bean对象，建议对这些bean进行集中分类配置（推荐），可以通过@Configuration注解声明一个配置类。</p><p>有两种声明方法，一个是放在启动类中，一个是集中分类配置</p><p>如果第三方bean需要依赖其它bean对象，直接在bean定义方法中设置形参即可，容器会根据类型自动装配。如果声明的方法的参数中调用的对象，没有在IOC容器中，那么就会报错</p><p>@Configuration 这个注解记得要加！</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Configuration</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>OSSconfig</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Bean</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 黄色的这个必须在IOC容器中，相当于省略了@Autowired</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>AliyunOSSOperator</span><span class=w> </span><span class=nf>aliyunOSSOperator</span><span class=p>(</span><span class=n>AliyunOSSProperties</span><span class=w> </span><span class=n>aliyunOSSProperties</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>AliyunOSSOperator</span><span class=p>(</span><span class=n>aliyunOSSProperties</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>通过@Bean注解的name或value属性可以声明bean的名称，如果不指定，默认bean的名称就是方法名。</p><h2 id=springboot原理-1>SpringBoot原理<a hidden class=anchor aria-hidden=true href=#springboot原理-1>#</a></h2><p>起步依赖的原理是Maven依赖传递</p><p>一旦声明了@ComponentScan这个注解，默认的扫描范围（启动类所在包及其子包）就不再生效了，需要添加上原来扫描的包</p><h3 id=自动配置>自动配置<a hidden class=anchor aria-hidden=true href=#自动配置>#</a></h3><p>SpringBoot的自动配置就是当spring项目启动后，一些配置类、bean对象就自动存入到了IOC容器中，不需要我们手动去声明，从而简化了开发，省去了繁琐的配置操作。</p><p>比如说谷歌的这Gson类，可以把数据转化成Json格式，我们并没有手动引入，但是aliyun的一个依赖中引入，所以我们也可以调用</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=w>    </span><span class=nd>@Test</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>testGson</span><span class=p>(){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>gson</span><span class=p>.</span><span class=na>toJson</span><span class=p>(</span><span class=n>Result</span><span class=p>.</span><span class=na>success</span><span class=p>(</span><span class=s>&#34;hello,world!&#34;</span><span class=p>)));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>运行结果：</p><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735525230017-2d042633-a1ad-43ab-b976-a412279992ce.png alt></p><h4 id=实现方案1conponentconponentscan>实现方案1：@Conponent+@ConponentScan<a hidden class=anchor aria-hidden=true href=#实现方案1conponentconponentscan>#</a></h4><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735526852026-c189ecb1-04a2-488d-9741-6da0d5a35d82.png alt></p><p>想要在@ComponentScan中被扫描到，需要在pom.xml中引入依赖</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=w>        </span><span class=o>&lt;</span><span class=n>dependency</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=o>&lt;</span><span class=n>groupId</span><span class=o>&gt;</span><span class=n>com</span><span class=p>.</span><span class=na>example</span><span class=o>&lt;/</span><span class=n>groupId</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=o>&lt;</span><span class=n>artifactId</span><span class=o>&gt;</span><span class=n>itheima</span><span class=o>-</span><span class=n>utils</span><span class=o>&lt;/</span><span class=n>artifactId</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=o>&lt;</span><span class=n>version</span><span class=o>&gt;</span><span class=n>0</span><span class=p>.</span><span class=na>0</span><span class=p>.</span><span class=na>1</span><span class=o>-</span><span class=n>SNAPSHOT</span><span class=o>&lt;/</span><span class=n>version</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=o>&lt;/</span><span class=n>dependency</span><span class=o>&gt;</span><span class=w>
</span></span></span></code></pre></div><p>手动配置扫描范围，具有使用繁琐，性能低的缺点</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@ComponentScan</span><span class=p>({</span><span class=s>&#34;com.example&#34;</span><span class=p>,</span><span class=s>&#34;com.zzzzyj&#34;</span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@SpringBootApplication</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>SpringbootAopQuickstartApplication</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>SpringApplication</span><span class=p>.</span><span class=na>run</span><span class=p>(</span><span class=n>SpringbootAopQuickstartApplication</span><span class=p>.</span><span class=na>class</span><span class=p>,</span><span class=w> </span><span class=n>args</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h4 id=实现方案2import类导入>实现方案2：@Import类导入<a hidden class=anchor aria-hidden=true href=#实现方案2import类导入>#</a></h4><p>@Import导入。@Import导入的类会被Spring加载到IOC容器中，导入形式主要有以下几种：</p><ol><li>导入普通类</li><li>导入配置类</li><li>导入 ImportSelector 接口实现类 返回一个数组，可以里边添加很多类 实现selectImport方法</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>MyImportSelector</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>ImportSelector</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=nf>selectImports</span><span class=p>(</span><span class=n>AnnotationMetadata</span><span class=w> </span><span class=n>importingClassMetadata</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>String</span><span class=o>[]</span><span class=p>{</span><span class=s>&#34;com.example.HeaderConfig&#34;</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ol start=4><li>@EnableXxxx注解，封装@Import注解（方便 优雅）</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// 导入普通类或者配置类</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@Import</span><span class=p>(</span><span class=n>HeaderConfig</span><span class=p>.</span><span class=na>class</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 导入 ImportSelector 接口实现类</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@Import</span><span class=p>(</span><span class=n>MyImportSelector</span><span class=p>.</span><span class=na>class</span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// @EnableXxxx注解，封装@Import注解</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@EnableHeaderConfig</span><span class=w>
</span></span></span></code></pre></div><h2 id=自动配置-源码跟踪>自动配置-源码跟踪<a hidden class=anchor aria-hidden=true href=#自动配置-源码跟踪>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@SpringBootApplication</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>SpringbootAopQuickstartApplication</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>SpringApplication</span><span class=p>.</span><span class=na>run</span><span class=p>(</span><span class=n>SpringbootAopQuickstartApplication</span><span class=p>.</span><span class=na>class</span><span class=p>,</span><span class=w> </span><span class=n>args</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>@SpringBootApplication</p><p>该注解标识在SpringBoot工程引导类上，是SpringBoot中最最最重要的注解。该注解由三个部分组成：</p><ol><li>@SpringBootConfiguration：该注解与 @Configuration 注解作用相同，用来声明当前也是一个配置类。启动类也是一个配置类，所以可以声明第三方，底层封装了@Configuration</li><li>@ComponentScan：组件扫描，默认扫描当前引导类所在包及其子包。</li><li>@EnableAutoConfiguration：SpringBoot实现自动化配置的核心注解。</li></ol><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735535283447-a4cec0b2-8203-41c1-92c9-7f3284b05d88.png alt></p><p>自动配置的原理，可以看<a href=https://heuqqdmbyk.feishu.cn/wiki/P8fNwBnSRiA6wWksjExcUZ4YnFe>https://heuqqdmbyk.feishu.cn/wiki/P8fNwBnSRiA6wWksjExcUZ4YnFe</a>里边的飞书云文档</p><p><strong>这里还是分析一下</strong></p><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735540127508-432c5f3b-7f3f-4c18-9efe-a925890e0397.png alt></p><p>点进去，里边出了元注解还有另外三个注解，接下来一个一个分析</p><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735540213633-8fbe6367-3ddf-4afb-8adb-8b669d08abba.png alt></p><p><code>**@SpringBootConfiguration**</code></p><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735540307112-9555baf7-f2bf-4951-a1f1-c541ddcc853c.png alt></p><p>也就是里边关键的就两个</p><p>@Configuration 这个上边讲过了，这就是一个说明这是个集中配置类的注解</p><p>@Indexed 这个是用来加速启动的，不需要关心</p><p><code>**@ComponentScan**</code></p><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735540531662-c458fe59-cecc-4fe2-ba2d-2959e8fe0a0f.png alt></p><p>@ComponentScan 注解是用来<strong>进行组件扫描</strong>的，扫描<strong>启动类所在的包及其子包</strong>下所有被@Component及其衍生注解声明的类。</p><p>SpringBoot启动类，之所以具备扫描包功能，就是因为包含了@ComponentScan注解</p><p><code>**@EnableAutoConfiguration**</code>** 自动配置核心注解**</p><p><strong>里边包含了这些：</strong></p><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735540682448-a726dd99-1eef-4d11-936a-71303fea4225.png alt></p><p>使用<code>@Import</code>注解，导入了实现<code>ImportSelector</code>接口的实现类。</p><p><code>AutoConfigurationImportSelector</code>类是<code>ImportSelector</code>接口的实现类。</p><p>里边重写了ImportSelector中的selectImports()方法</p><p>我们现在来分析一下这个方法</p><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735540908805-8a566731-4fea-4fea-9111-aae0201db013.png alt></p><p>selectImports()方法底层调用getAutoConfigurationEntry()方法，获取可自动配置的配置类信息集合</p><p>所以说我们来分析一下getAutoConfigurationEntry()方法</p><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735540953188-ec43a742-c2fd-48fc-b953-7dc2a26f2070.png alt></p><p>getAutoConfigurationEntry()方法通过调用getCandidateConfigurations(annotationMetadata, attributes)方法获取在配置文件中配置的所有自动配置类的集合</p><p>再来分析一下getCandidateConfigurations()这个方法</p><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735541082846-3673e34d-1f16-4c7e-9623-256bdea6241e.png alt>
<code>getCandidateConfigurations</code>方法的功能：</p><p>获取所有基于 <code>&lt;font style="color:rgb(222,120,2);">META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports&lt;/font></code>文件中配置类的集合</p><p><code>&lt;font style="color:rgb(222,120,2);">META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports&lt;/font></code>文件这两个文件在哪里呢？</p><p>通常在引入的起步依赖中，都有包含以上文件</p><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735541382072-da36239d-a577-422e-bc09-1d27c977011a.png alt></p><p>在前面演示自动配置的时候，我们直接在测试类当中注入了一个叫<code>gson</code>的bean对象，进行JSON格式转换。虽然我们没有配置bean对象，但是我们是可以直接注入使用的。原因就是因为在自动配置类当中做了自动配置。到底是在哪个自动配置类当中做的自动配置呢？我们通过搜索来查询一下。</p><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735541651519-4766f14d-a5af-422b-b148-c40a8a9f24ba.png alt></p><p>打开上面的第三方依赖中提供的 <code>&lt;font style="color:rgb(222,120,2);">GsonAutoConfiguration&lt;/font></code>类（双击shift实现）</p><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735541745067-102718ae-c7ca-4cd4-90bc-c0d21dcd97ed.png alt></p><p>打开@AutoConfiguration</p><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735541782494-6214d17f-d9dc-4f5b-98b8-3391e5b3c4a6.png alt></p><p>原理就是在配置类中定义一个<code>@Bean</code>标识的方法，而Spring会自动调用配置类中使用<code>@Bean</code>标识的方法，并把方法的返回值注册到IOC容器中。</p><p><strong>小结</strong></p><p><strong>@SpringBootConfiguration</strong></p><pre><code>- **声明当前类是一个配置类**
</code></pre><p><strong>@ComponentScan</strong></p><pre><code>- **进行组件扫描（SpringBoot中默认扫描的是启动类所在的当前包及其子包）**
</code></pre><p><strong>@EnableAutoConfiguration</strong></p><pre><code>- **封装了@Import注解（Import注解中指定了一个ImportSelector接口的实现类）**
- 在实现类重写的selectImports()方法，读取当前项目下所有依赖jar包中`&lt;font style=&quot;color:rgb(222,120,2);&quot;&gt;META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports&lt;/font&gt;`两个文件里面定义的配置类（配置类中定义了@Bean注解标识的方法）。
</code></pre><p>当SpringBoot程序启动时，就会加载配置文件当中所定义的配置类，并将这些配置类信息(类的全限定名)封装到String类型的数组中，最终通过@Import注解将这些配置类全部加载到Spring的IOC容器中，交给IOC容器管理。</p><p>在 <code>&lt;font style="color:rgb(46,161,33);">META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports&lt;/font></code> 文件中定义的配置类非常多，而且每个配置类中又可以定义很多的bean，那这些bean都会注册到Spring的IOC容器中吗？</p><p>答案：<strong>并不是</strong>。 在声明bean对象时，上面有加一个以 <code>&lt;font style="color:rgb(46,161,33);">@Conditional&lt;/font></code> 开头的注解，这种注解的作用就是按照条件进行装配，只有满足条件之后，才会将bean注册到Spring的IOC容器中（下面会详细来讲解）</p><h2 id=conditional>@Conditional<a hidden class=anchor aria-hidden=true href=#conditional>#</a></h2><p>作用：按照一定的条件进行判断，在满足给定条件后才会注册对应的bean对象到Spring的IOC容器中。</p><p>位置：方法、类</p><p><strong>@Conditional本身是一个父注解，派生出大量的子注解：</strong></p><ul><li>@ConditionalOnClass：判断环境中有对应字节码文件，才注册bean到IOC容器。</li><li>@ConditionalOnMissingBean：判断环境中没有对应的bean（类型或名称），才注册bean到IOC容器。</li><li>@ConditionalOnProperty：判断配置文件中有对应属性和值，才注册bean到IOC容器。</li></ul><p>笔记文档中有详细的代码判断。</p><h2 id=自定义starter>自定义starter<a hidden class=anchor aria-hidden=true href=#自定义starter>#</a></h2><p>场景：在实际开发中，经常会定义一些公共组件，提供给各个项目团队使用。而在SpringBoot的项目中，一般会将这些公共组件封装为SpringBoot的starter（包含了起步依赖和自动配置的功能）。</p><p><strong>starter就是一个一个的依赖</strong></p><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735607553439-3f8be286-6295-472b-a4f8-b416f1909c22.png alt></p><ul><li>需求：自定义aliyun-oss-spring-boot-starter，完成阿里云OSS操作工具类 Aliyunossoperator 的自动配置。</li><li>目标：引入起步依赖引入之后，要想使用阿里云OSS，注入 AliyunOSSOperator 直接使用即可。</li><li>步骤：</li></ul><ol><li>创建aliyun-oss-spring-boot-starter模块</li><li>创建aliyun-oss-spring-boot-autoconfigure模块，在starter中引入该模块</li><li>在aliyun-oss-spring-boot-autoconfigure模块中的定义自动配置功能，并定义自动配置文件 META-INF/spring/xxxx.imports</li></ol><p><strong>下边详细分析一下自定义starter的实现步骤</strong></p><p>首先定义两个模块，其中starter模块只需要保留pom.xml文件，里边引用autoconfigure，代码等功能的实现都在autoconfigure模块中</p><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735610625402-516ac305-fb05-418b-a4a8-7995bc502c19.png alt></p><p>接下来分析一下autoconfigure模块</p><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735610714462-c63824d2-aa8c-45bd-8351-f97cb9d5abe3.png alt></p><p>其中后两个类是用来实现文件上传功能的，但是里边的@Component注解没有用了，在SpringBoot项目中，并不会去扫描com.aliyun.oss这个包，不扫描这个包那类上的注解也就失去了作用。</p><p>就可以删除里边的Component和Autowired注解，同时需要按照 starter 的定义规范，定义一个自动配置类，在自动配置类中声明bean。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kn>package</span><span class=w> </span><span class=nn>com.aliyun.oss</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kn>import</span><span class=w> </span><span class=nn>org.springframework.boot.context.properties.EnableConfigurationProperties</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kn>import</span><span class=w> </span><span class=nn>org.springframework.context.annotation.Bean</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kn>import</span><span class=w> </span><span class=nn>org.springframework.context.annotation.Configuration</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@Configuration</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@EnableConfigurationProperties</span><span class=p>(</span><span class=n>AliyunOSSProperties</span><span class=p>.</span><span class=na>class</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>AliyunOSSAutoConfiguration</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Bean</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>AliyunOSSOperator</span><span class=w> </span><span class=nf>aliyunOSSOperator</span><span class=p>(</span><span class=n>AliyunOSSProperties</span><span class=w> </span><span class=n>aliyunOSSProperties</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>AliyunOSSOperator</span><span class=p>(</span><span class=n>aliyunOSSProperties</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>之前思考的问题，为什么不能new一个AliyunOSSProperties，是因为他没有在IOC容器中，不能new一个，找不到这个对象，所以需要传进来，那么会问，怎么传，不也要在IOC容器中才能传递吗，所以我需要@EnableConfigurationProperties(AliyunOSSProperties.class) 这个注解里边包括了@Import注解，可以直接导入数据</p><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735611090816-d34c3ffb-0c14-4b18-9716-8482f989e974.png alt></p><p>文件里边是全类名</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>com</span><span class=p>.</span><span class=na>aliyun</span><span class=p>.</span><span class=na>oss</span><span class=p>.</span><span class=na>AliyunOSSAutoConfiguration</span><span class=w>
</span></span></span></code></pre></div><p>思考的一个问题</p><p>为什么在本地配置的yml文件是可行的</p><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735612730683-01e4bffb-3b5a-4f02-8b6b-72b3a744f4a1.png alt></p><p>其实这个问题很简单，因为我们引入了IOC，相当于是把之前写的那些类也就是放在了本地运行，所以在本地配置就可以了。</p><h1 id=maven高级>Maven高级<a hidden class=anchor aria-hidden=true href=#maven高级>#</a></h1><h2 id=分模块设计与开发>分模块设计与开发<a hidden class=anchor aria-hidden=true href=#分模块设计与开发>#</a></h2><p>如果全都写在一个模块里，不便于维护，难以复用</p><p>分模块设计示例图：</p><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735779877439-6a9ccb0e-4b3d-41a1-ad3e-32ff9109f088.png alt></p><p>将一个大项目拆分成若干个子模块，方便项目的管理维护、扩展，也方便模块间的相互引用，资源共享。</p><h3 id=分模块设计的策略>分模块设计的策略<a hidden class=anchor aria-hidden=true href=#分模块设计的策略>#</a></h3><ol><li>策略一：按照功能模块拆分，比如：公共组件、商品模块、搜索模块、购物车模块、订单模块等。</li><li>策略二：按层拆分，比如：公共组件、实体类、控制层、业务层、数据访问层。</li><li>策略三：按照功能模块 + 层拆分。</li></ol><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735779949309-c79826d7-f28b-473a-8d76-741e274ff807.png alt></p><h3 id=实战>实战<a hidden class=anchor aria-hidden=true href=#实战>#</a></h3><p>分模块开发需要<strong>先针对模块功能进行设计</strong>，<strong>再进行编码</strong>。不会先将工程开发完毕，然后进行拆分。</p><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735779977739-b8176ab0-472d-4c71-b56b-264554d00789.png alt></p><p>创建项目后，需要检查jdk的版本是否正确，还有就是Maven的环境是否正确</p><p>拆分之后，因为原来的项目中有引入SpringBoot所以里边的Lombok没有指定版本，但是拆分pojo的时候，并不需要引入SpringBoot所以需要指定版本</p><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735780591327-ee9a235f-cb6d-4afd-aaf0-fe37034c2fef.png alt></p><p>在Maven的控制面板里边可以看到之前的版本号</p><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735780675020-b4554cc9-559f-42cc-a04a-2ed6318fb9c8.png alt></p><p>还用到了，这个是Spring的核心包，只需要引入Spring的核心包就行</p><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735780710075-5c0c403b-b7b2-41d3-9e18-dfa33dd635f2.png alt></p><p>核心包就叫做spring-boot-start</p><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735780890763-81351e3d-1a90-41d0-b410-6f71069fa3df.png alt></p><p>原项目还需要引入pojo</p><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735780964614-34346db5-9541-41bc-af57-a8ad46653b3f.png alt></p><h2 id=继承与聚合>继承与聚合<a hidden class=anchor aria-hidden=true href=#继承与聚合>#</a></h2><p><strong>提出的原因是：</strong></p><p>如果多个模块都要引用同一个依赖，每个模块都写会很复杂，所以抽取成为父模块</p><p><strong>概念：继承描述的是两个工程间的关系，与java中的继承相似，子工程可以继承父工程中的配置信息，常见于依赖关系的继承。</strong></p><p>作用：<strong>简化依赖配置、统一管理依赖</strong></p><p>实现：&mldr;</p><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735782826385-7adac2d5-b57b-4875-9d4f-d0f9716e8c9d.png alt></p><p>maven和java一样不支持多继承，但支持多重继承</p><h3 id=继承关系实现>继承关系实现<a hidden class=anchor aria-hidden=true href=#继承关系实现>#</a></h3><ol><li>创建maven模块tlias-parent，该工程为父工程，<strong>设置打包方式pom</strong>（默认jar）。</li><li>在子工程的pom.xml文件中，配置继承关系。</li><li>在父工程中配置各个工程共有的依赖（子工程会自动继承父工程的依赖）。</li></ol><p>**jar：**普通模块打包，SR ngoot项目基本都是jar包（内嵌tomcat运行）</p><p>**war：**普通web程序打包，需要部署在外部的tomcat服务器中运行</p><p>**pom：**父工程或聚合工程，该模块不写代码，仅进行依赖管理</p><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735782911770-6e7d298d-329c-4644-99ce-12a68f08e297.png alt></p><p>父工程需要配置相对路径，如果自闭合，就是不配置相对路径的话，会先从本地仓库中寻找，如果没有，再从中央仓库中寻找</p><p>在子工程中，配置了继承关系之后，坐标中的groupId是可以省略的，因为<strong>会自动继承父工程</strong>的。</p><p>relativePath指定父工程的pom文件的相对位置（如果不指定，将从本地仓库/远程仓库查找）。</p><p>若父子工程都配置了同一个依赖的不同版本，以<strong>子工程</strong>的为准。</p><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735783236317-010cf230-956a-45a7-be59-6b7da5ce024f.png alt></p><p>配置的时候从当前项目开始，找到xml文件</p><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735783381275-2e6c885a-2263-4cf2-9c6d-06d4a7c7b8f4.png alt></p><p>不是公共的依赖，不建议在父工程中引入，会耗费资源</p><h4 id=版本锁定>版本锁定<a hidden class=anchor aria-hidden=true href=#版本锁定>#</a></h4><p>在maven中，可以在父工程的pom文件中通过 来统一管理依赖版本，注意这里边还需要标签</p><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735786202234-13b685a4-3eb1-4aa2-98bb-f3bcdd05d207.png alt></p><h4 id=属性配置>属性配置<a hidden class=anchor aria-hidden=true href=#属性配置>#</a></h4><p><strong>解决了什么问题：</strong></p><p>因为实际的项目中会有很多的如果需要一个一个查找会很麻烦，一个会占用很多行，所以直接在中定义版本号</p><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735786315200-6ce2bf03-d468-41b8-b25c-a1fc9d3c044a.png alt></p><p>名字需要保持一致</p><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735786512730-4ed0f7a2-edb7-4b67-b83c-09eb241f8ef9.png alt></p><h3 id=聚合>聚合<a hidden class=anchor aria-hidden=true href=#聚合>#</a></h3><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735787734533-294cb91d-51fe-423f-90bf-8a6e747bcf46.png alt></p><p><strong>聚合</strong></p><p>将多个模块组织成一个整体，同时进行项目的构建。</p><p><strong>聚合工程</strong></p><p>一个不具有业务功能的“空”工程（有且仅有一个pom文件）</p><p><strong>作用</strong></p><p>快速构建项目（无需根据依赖关系手动构建，直接在聚合工程上构建即可）</p><p><strong>实现</strong></p><p>maven中可以通过设置当前聚合工程所包含的子模块名称</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=o>&lt;!--</span><span class=n>聚合</span><span class=o>--&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>&lt;</span><span class=n>modules</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>&lt;</span><span class=n>module</span><span class=o>&gt;</span><span class=p>..</span><span class=o>/</span><span class=n>tlias</span><span class=o>-</span><span class=n>pojo</span><span class=o>&lt;/</span><span class=n>module</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>&lt;</span><span class=n>module</span><span class=o>&gt;</span><span class=p>..</span><span class=o>/</span><span class=n>tlias</span><span class=o>-</span><span class=n>utils</span><span class=o>&lt;/</span><span class=n>module</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>&lt;</span><span class=n>module</span><span class=o>&gt;</span><span class=p>..</span><span class=o>/</span><span class=n>tlias</span><span class=o>-</span><span class=n>web</span><span class=o>-</span><span class=n>management</span><span class=o>&lt;/</span><span class=n>module</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>&lt;/</span><span class=n>modules</span><span class=o>&gt;</span><span class=w>
</span></span></span></code></pre></div><p>聚合工程中所包含的模块，在构建时，会自动根据模块间的依赖关系设置构建顺序，与聚合工程中模块的配置<strong>书写位置无关</strong>。</p><p><strong>maven中继承与聚合的区别</strong></p><p>联系：继承与聚合都属于设计型模块，打包方式都为pom，常将两种关系制作到同一个pom文件中</p><p>区别：</p><ol><li>继承用于简化依赖配置、统一管埋依赖版本，是在子工程中配置继承关系</li><li>聚合用于快速构建项目，是在父工程（聚合工程）中配置聚合的模块</li></ol><h2 id=私服>私服<a hidden class=anchor aria-hidden=true href=#私服>#</a></h2><p>私服是一种特殊的远程仓库，它是架设在局域网内的仓库服务，用来代理位于外部的中央仓库，用于解决团队内部的资源共享与资源同步问题。</p><p>私服在企业项目开发中，一个项目/公司，只需要一台即可（无需我们自己搭建，会使用即可）。</p><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735792015970-05980abd-4284-468d-8f63-aa3c19704658.png alt></p><p>依赖查找顺序：</p><p>本地仓库 -> 私服 -> 中央仓库</p><p><strong>资源的上传与下载</strong></p><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735792075495-a6347464-1bba-4374-a3b8-67c5c90f1c0d.png alt></p><p><strong>项目版本：</strong></p><p>RELEASE（发行版本）：功能趋于<strong>稳定</strong>、当前更新停止，可以用于发行的版本，存储在私服中的RELEASE仓库中。</p><p>SNAPSHOT（快照版本）：功能<strong>不稳定、尚处于开发中</strong>的版本，即快照版本，存储在私服的SNAPSHOT仓库中。</p><p><strong>步骤：</strong></p><p><strong>1、设置私服的访问用户名/密码（settings.xmL中的servers中配置）</strong></p><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735792194653-2b2e600e-c603-4a7a-a6a5-6b6e5a999c98.png alt></p><p><strong>2、IDEA的maven工程的pom文件中配置上传（发布）地址</strong></p><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735792229730-7fe1076b-0eed-4e40-95ec-f6f168745aee.png alt></p><p><strong>3、设置私服依赖下载的仓库组地址（settings.xml中的mirrors、profiles中配置）</strong></p><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735792288430-4c8c5a50-3320-4efa-9a1a-ef51c47a25c4.png alt></p><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735792309753-e557f292-f693-43a9-bee4-e682d3b7c2ca.png alt></p><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735792341699-59df2493-ba02-44f5-8507-b49b81bc4712.png alt></p><h1 id=web后端开发总结>Web后端开发总结<a hidden class=anchor aria-hidden=true href=#web后端开发总结>#</a></h1><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735792707412-e6565a53-e993-480d-ad42-474f35775242.png alt></p><p>阿里云OSS - 对象存储的解决方案</p><p>JWT - 会话跟踪的解决方案</p><p>SpringMVC 是Spring框架的一部分</p><p><img loading=lazy src=/images/Day14Spring-%e5%8e%9f%e7%90%86.assets/1735792750330-8b0e9689-cdb4-4257-8a8f-e77e111e1394.png alt></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://wqnm1gb.github.io/tags/java-web/>Java Web</a></li></ul><nav class=paginav><a class=prev href=https://wqnm1gb.github.io/posts/day16%E5%89%8D%E7%AB%AFweb%E5%AE%9E%E6%88%98/><span class=title>« 上一页</span><br><span>Day16 前端Web实战</span>
</a><a class=next href=https://wqnm1gb.github.io/posts/day13spring-aop/><span class=title>下一页 »</span><br><span>Day13 Spring-AOP</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://wqnm1gb.github.io/>三狗子的博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>