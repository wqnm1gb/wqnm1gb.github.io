<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Day13 Spring-AOP | 三狗子的博客</title>
<meta name=keywords content="java Web"><meta name=description content="什么是AOP？
**AOP：**Aspect Oriented Programming（面向切面编程、面向方面编程），可简单理解为就是面向特定方法编程。"><meta name=author content="冷漠三狗子丶"><link rel=canonical href=https://wqnm1gb.github.io/posts/day13spring-aop/><link crossorigin=anonymous href=/assets/css/stylesheet.3d688279d829dc24da48acd11f9e33ebea2f39c035e899e1bf4297d8b7aa89b9.css integrity="sha256-PWiCedgp3CTaSKzRH54z6+ovOcA16Jnhv0KX2Leqibk=" rel="preload stylesheet" as=style><link rel=icon href=https://wqnm1gb.github.io/images/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://wqnm1gb.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wqnm1gb.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wqnm1gb.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://wqnm1gb.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://wqnm1gb.github.io/posts/day13spring-aop/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel=stylesheet><script type=text/javascript async src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["[[","]]"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=" has-jax"})</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style><meta property="og:title" content="Day13 Spring-AOP"><meta property="og:description" content="什么是AOP？
**AOP：**Aspect Oriented Programming（面向切面编程、面向方面编程），可简单理解为就是面向特定方法编程。"><meta property="og:type" content="article"><meta property="og:url" content="https://wqnm1gb.github.io/posts/day13spring-aop/"><meta property="og:image" content="https://wqnm1gb.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-03-06T10:10:36+08:00"><meta property="article:modified_time" content="2025-03-06T10:10:36+08:00"><meta property="og:site_name" content="三狗子的博客"><meta property="fb:admins" content="your-facebook-admin-id"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wqnm1gb.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Day13 Spring-AOP","item":"https://wqnm1gb.github.io/posts/day13spring-aop/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Day13 Spring-AOP","name":"Day13 Spring-AOP","description":"什么是AOP？ **AOP：**Aspect Oriented Programming（面向切面编程、面向方面编程），可简单理解为就是面向特定方法编程。\n","keywords":["java Web"],"articleBody":"什么是AOP？ **AOP：**Aspect Oriented Programming（面向切面编程、面向方面编程），可简单理解为就是面向特定方法编程。\n**场景：**案例中部分业务方法运行较慢，定位执行耗时较长的接口，此时需要统计每一个业务方法的执行耗时。\n优势：\n减少重复代码（用计算运行时间的代码示例，不需要每个方法里边都写检测时间逻辑） 代码无侵入（不需要改变原来的方法的代码） 提高开发效率（不需要修改一个一个方法） 维护方便（直接注释掉AOP的方法，就可以进行维护） AOP是一种思想，而在Spring框架中对这种思根进行的实现，那我们要学习的就是Spring AOP。\nAOP基础 AOP快速入门 需求：统计所有业务层方法的执行耗时。\n步骤：\n1、导入依赖：在pom.xml中引入AOP的依赖\n\u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-aop\u003c/artifactId\u003e \u003c/dependency\u003e 父工程用了Spring框架，所以不需要指定版本\n2、编写AOP程序：针对于特定的方法根据业务需要进行编程\n@Component @Slf4j @Aspect // 当前类是切面类 public class RecordTimeAspect { // 还得记得配置生效的范围 @Around(\"execution(* com.itheima.service.impl.*.*(..))\") public Object recordTime(ProceedingJoinPoint pjp) throws Throwable { // 1、记录方法的开始时间 long begin = System.currentTimeMillis(); // 2、执行目标方法 执行方法需要有ProceedingJoinPoint这个类，调用proceed方法 Object result = pjp.proceed(); // 3、记录方法执行时长 long end = System.currentTimeMillis(); // pjp.getSignature()可以获得执行方法的名字 log.info(\"{}方法执行耗时{}ms\",pjp.getSignature(),end - begin); return result; } } AOP中的核心概念 **连接点：**JoinPoint，可以被AOP控制的方法（暗含方法执行时的相关信息） 通知：Advice，指那些重复的逻辑，也就是共性功能（最终体现为一个方法） 切入点：PointCut，匹配连接点的条件，通知仅会在切入点方法执行时被应用 **切面：**Aspect，描述通知与切入点的对应关系（通知＋切入点） **目标对象：**Target，通知所应用的对象 连接点：可以被AOP控制的方法\n切入点：实际被AOP控制的方法\n切入点一定是连接点，但是连接点不一定是切入点\nAOP的执行流程 AOP是基于动态代理技术，为目标对象生成一个代理对象，然后实际调用的时候是调用的代理对象\nAOP进阶 通知类型 根据通知方法执行时机的不同，将通知类型分为以下常见的五类：\n@Around：环绕通知，此注解标注的通知方法在目标方法前、后都被执行 @Around环绕通知需要自己调用 ProceedingJoinPoint.proceed()来让原始方法执行，其他通知不需要考虑目标方法执行\n@Around环绕通知方法的返回值，必须指定为Object，来接收原始方法的返回值\n@Before：前置通知，此注解标注的通知方法在目标方法前被执行 @After：后置通知，此注解标注的通知方法在目标方法后被执行，无论是否有异常都会执行 @AfterReturning： 返回后通知，此注解标注的通知方法在目标方法后被执行，有异常不会执行 @AfterThrowdng：异常后通知，此注解标注的通知方法发生异常后执行 @PointCut注解\n该注解的作用是将公共的切点表达式抽取出来，需要用到时引用该切点表达式即可。\n@Aspect @Component @Slf4j public class DemoAspect { // 定义一个pt函数，都可以调用pt来获得切入点 @Pointcut(\"execution(* com.itheima.service.impl.*.*(..))\") public void pt(){} // 前置通知 @Before(\"pt()\") public void before(){ log.info(\"before....\"); } // 后置通知 @After(\"pt()\") public void after(){ log.info(\"after....\"); } // 环绕通知 @Around(\"pt()\") public Object around(ProceedingJoinPoint pjp) throws Throwable { log.info(\"around before....\"); Object result = pjp.proceed(); log.info(\"around after....\"); return result; } // 返回后通知 @AfterReturning(\"pt()\") public void afterReturning(){ log.info(\"afterReturning....\"); } // 异常后通知 @AfterThrowing(\"pt()\") public void afterThrowing(){ log.info(\"afterThrowing....\"); } } 通知顺序 当有多个切面的切入点都匹配到了目标方法，目标方法运行时，多个通知方法都会被执行。\n执行顺序：\n不同切面类中，默认按照切面类的类名字母排序：\n目标方法前的通知方法：字母排名靠前的先执行 目标方法后的通知方法：字母排名靠前的后执行 用 @Order（数字）加在切面类上来控制顺序\n目标方法前的通知方法：数字小的先执行 目标方法后的通知方法：数字小的后执行 切入点表达式 介绍：描述切入点方法的一种表达式。\n作用：用来决定项目中的哪些方法需要加入通知。\n可以匹配到接口，会匹配所有接口的实现类方法，可以基于接口来匹配\n常见形式：\nexecution（….）：根据方法的签名来匹配 @annotation（….）：根据注解匹配 切入点表达式-execution @Before(\"execution(void com.itheima.service.impl.DeptServiceImpl.delete(java.lang.Integer))\") @Before(\"execution(* com.itheima.service.impl.*.*(..) )\") 语法：\nexecution(访问修饰符? 返回值 包名.类名.?方法名(方法参数) throws 异常?)\n其中带？的表示可以省略的部分\n访问修饰符：可省略（比如：public、protected） 包名，类名：可省略（不建议省略） throws 异常：可省略（注意是方法上声明抛出的异常，不是实际抛出的异常） 可以使用通配符描述切入点\n*：单个独立的任意符号，可以通配任意返回值、包名、类名、方法名、任意类型的一个参数，也可以通配包、类、方法名的一部分\nexecution(* com.*.service.*.update*(*)) ..：多个连续的任意符号，可以通配任意层级的包，或任意类型、任意个数的参数\nexecution(* com.itheima..DeptService.*(..)) 根据业务需要，可以使用且（\u0026\u0026）、或（II）、非（！）来组合比较复杂的切入点表达式。\n可以使用逻辑运算符来匹配\n切入点表达式-Annotation @Before(\"@annotation(com.itheima.anno.LogOperation)\") // 这里边写的是定义的注解的全类名 public void before(){ log.info(\"MyAspect4 -\u003e before ...\"); } // 在需要使用切入点的地方添加自定义的注解 @Override @LogOperation public void save(Dept dept) { dept.setCreateTime(LocalDateTime.now()); dept.setUpdateTime(LocalDateTime.now()); deptMapper.save(dept); } 如果execution切入点表达式方便描述指定的方法，就使用execution表达式\n否则，就使用@annotation切入点表达式\n连接点 在Spring中用JoinPoint抽象了连接点，用它可以获得方法执行时的相关信息，如目标类名、方法名、方法参数等。\n对于 @Around 通知，获取连接点信息只能使用 ProceedingJoinPoint（这个是JoinPoint的子类）\n对于其它四种通知，获取连接点信息只能使用 JoinPoint，它是 ProceedingJoinPoint 的父类型\n@Before(\"execution(* com.itheima.service.impl.*.*(..))\") public void before(JoinPoint joinPoint){ // 获取目标类名 String className = joinPoint.getTarget().getClass().getName(); log.info(\"目标类名：{}\",className); // 获取目标方法签名 Signature signature = joinPoint.getSignature(); log.info(\"方法签名：{}\",signature); // 获取目标方法名 String methodName = joinPoint.getSignature().getName(); log.info(\"目标方法名：{}\",methodName); // 获取参数 Object[] args = joinPoint.getArgs(); log.info(\"参数：{}\", Arrays.toString(args)); } 运行结果：\nAOP案例 将案例中增、删、改相关接口的操作日志记录到数据库表中\n日志信息包含：操作人、操作时间、执行方法的全类名、执行方法名、方法运行时参数、返回值、方法执行时长\n采用哪种通知类型？ @Around环绕通知\n切入点表达式该怎么写？\n由于增、删、改 方法名我们定义的比较规范，分别为save、delete、update\n用execution比较复杂\n@Around(\"execution(* com.itheima.controller.*.save(..)) ||\" + \"execution(* com.itheima.controller.*.delete(..)) ||\" + \"execution(* com.itheima.controller.*.update(..))\") 用annotation比较方便\n@Around(\"@annotation(com.itheima.anno.Log)\") @Around(\"@annotation(com.zzzzyj.anno.Log)\") public Object around(ProceedingJoinPoint joinPoint) throws Throwable { // 记录开始时间 long startTime = System.currentTimeMillis(); // 执行方法 Object result = joinPoint.proceed(); // 当前时间 long endTime = System.currentTimeMillis(); // 耗时 long costTime = endTime - startTime; // 构建日志对象 OperateLog operateLog = new OperateLog(); operateLog.setOperateEmpId(getCurrentUserId()); // 需要实现 getCurrentUserId 方法 operateLog.setOperateTime(LocalDateTime.now()); operateLog.setClassName(joinPoint.getTarget().getClass().getName()); operateLog.setMethodName(joinPoint.getSignature().getName()); operateLog.setMethodParams(Arrays.toString(joinPoint.getArgs())); operateLog.setReturnValue(result.toString()); operateLog.setCostTime(costTime); log.info(\"日志信息{}\",operateLog); // 插入日志 operateLogMapper.insert(operateLog); return result; } // 示例方法，获取当前用户ID private int getCurrentUserId() { // 这里应该根据实际情况从认证信息中获取当前登录用户的ID return 1; // 示例返回值 } 获取当前用户ID没有实现\n获取当前用户ID 思考一下：用户ID存在哪里，其实是存在了jwt令牌里边，通过服务器构造的jwt令牌，里边有着ID和用户名信息\n1、员工登录成功后，哪里存储的有当前登录员工的信息？\n给客户端浏览器下发的jwt令牌中\n**2、如何从jwt令牌中获取到当前登录的员工信息？ **\n获取请求头中传递的jwt令牌，并解析\n**3. TokenFilter中已经解析了令牌的信息，如何将其传递给AOP程序、Controller、Service呢？ **ThreadLocal\n在令牌校验过滤器TokenFilter中获取了jwt令牌，并对其进行解析获取当了当前登录员工的ID，如何将这个ID传递给AOP程序、Controller、Service中呢？\nThreadLocal ThreadLocal并不是一个Thread，而是Thread的局部变量。\nThreadLocal为每个线程提供一份单独的存储空间，具有线程隔离的效果，不同的线程之间不会相互干扰。\nThreadLocal常用方法：（一共只有3个方法）\n• public void set （T value） 设置当前线程的线程局部变量的值\n• public T get（） 返回当前线程所对应的线程局部变量的值\n• public void remove（） 移除当前线程的线程局部变量\npublic class ThreadLocalTest { // 泛型指定往本地存储空间存储的是什么类型的数据 public static ThreadLocal\u003cString\u003e local = new ThreadLocal\u003c\u003e(); public static void main(String[] args) { local.set(\"Main Message\"); System.out.println(local.get()); new Thread(() -\u003e { local.set(\"Thread Message\"); System.out.println(local.get()); }).start(); local.remove(); System.out.println(local.get()); } } 哪个线程存的只能哪个线程取，哪个线程删\n一次请求对应一个线程\n具体操作步骤：\n定义ThreadLocal操作的工具类，用于操作当前登录员工ID。 public class CurrentHolder { private static final ThreadLocal\u003cInteger\u003e CURRENT_LOCAL = new ThreadLocal\u003c\u003e(); public static void setCurrentId(Integer employeeId) { CURRENT_LOCAL.set(employeeId); } public static Integer getCurrentId() { return CURRENT_LOCAL.get(); } public static void remove() { CURRENT_LOCAL.remove(); } } 里边就是定义了一个静态变量ThreadLocal\n在TokenFilter中，解析完当前登录员工ID，将其存入ThreadLocal（用完之后需将其删除）。 在AOP程序中，从ThreadLocal中获取当前登录员工的ID。 用完删除这个逻辑的困惑分析 困惑产生的原因：为什么里边没有调用Aop的方法，却需要在放行之后把他删除，其实对于Filter过滤器，他的执行步骤是这样的：\n注意这两个问题，还会回到Filter中，所以在放行之后的逻辑就是用来执行清楚内容的，放行之后不是直接执行清楚操作，而是进去了Controller层\n那么我用Interceptor为什么同样的操作却不行呢\n原因：\nInterceptor里边有三个函数可以重写，我一直写在preHandle中，当然不行，他永远只是会在放行前执行，即使使用了try-finally代码块，还是不可以\n但是如果我用postHandle函数处理的话，就可以成功，因为的执行时间相当于在放行回来后\n代码如下：\n验证token的时候，将jwt令牌的id信息存在ThreadLocal中\nClaims claims = JwtUtils.parseJWT(token); String id = claims.get(\"id\").toString(); CurrentHolder.setCurrentId(Integer.valueOf(id)); 在Interceptor中进行删除\n@Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { CurrentHolder.remove(); } 在Filter中进行删除\nlog.info(\"令牌通过校验，放行\"); filterChain.doFilter(servletRequest,servletResponse); CurrentHolder.remove(); 作业里边的日志记录遇到的bug\n这个bug的原因是用了@Controller而没有用@RestController这个注解，导致会递归访问/log/log/page这个路径\n@Controller：这是一个通用的注解，用于定义一个Spring MVC控制器。它不会提供任何额外的功能，只是告诉Spring框架这个类是一个控制器。 @RestController：这是一个特定于返回值的注解，它是@Controller和@ResponseBody的组合。这意味着任何在@RestController注解的类中定义的方法都会自动应用@ResponseBody注解，这会导致Spring框架将方法的返回值写入HTTP响应体中，而不是返回一个视图。 **\n**在Spring MVC中，@Controller和@RestController注解都用于定义控制器，但它们在处理请求路径时的行为有所不同。当你使用@Controller注解时，Spring MVC会尝试使用视图解析器来解析路径，这意味着如果你的路径中包含斜杠（/），Spring MVC可能会将其解释为视图的路径，而不是URL的一部分。这就是为什么当你使用@Controller注解并访问/log/page路径时，Spring MVC会尝试寻找/log/log/page的原因，因为它将/log解释为视图的前缀，然后继续寻找/log/page作为视图名称。\n相比之下，@RestController注解是@Controller和@ResponseBody的组合，它通常用于创建RESTful风格的Web服务。当使用@RestController时，Spring MVC不会尝试使用视图解析器来解析路径，因为@ResponseBody注解告诉Spring MVC直接将方法的返回值写入HTTP响应体中，而不是返回一个视图名称。因此，当你使用@RestController注解并访问/log/page路径时，Spring MVC会直接将请求映射到对应的处理方法，而不会尝试进一步解析视图路径。\n总结来说，@Controller注解可能会引起Spring MVC对路径的视图解析，而@RestController注解则避免了这一行为，直接将返回值作为响应体返回，这就是为什么在使用@Controller时会出现路径继续寻找的问题，而在@RestController中不会出现。\n","wordCount":"5087","inLanguage":"zh","image":"https://wqnm1gb.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-03-06T10:10:36+08:00","dateModified":"2025-03-06T10:10:36+08:00","author":{"@type":"Person","name":"冷漠三狗子丶"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wqnm1gb.github.io/posts/day13spring-aop/"},"publisher":{"@type":"Organization","name":"三狗子的博客","logo":{"@type":"ImageObject","url":"https://wqnm1gb.github.io/images/favicon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wqnm1gb.github.io/ accesskey=h title="主页 (Alt + H)"><img src=https://wqnm1gb.github.io/apple-touch-icon.png alt aria-label=logo height=35>主页</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wqnm1gb.github.io/ title=三狗子的博客><span>首页</span></a></li><li><a href=https://wqnm1gb.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://wqnm1gb.github.io/categories/ title=Categories><span>分类</span></a></li><li><a href=https://wqnm1gb.github.io/tags/ title=Tags><span>标签</span></a></li><li><a href=https://wqnm1gb.github.io/search/ title=搜索><span>搜索</span></a></li><li><a href=https://wqnm1gb.github.io/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://wqnm1gb.github.io/>主页</a>&nbsp;»&nbsp;<a href=https://wqnm1gb.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Day13 Spring-AOP</h1><div class=post-meta><span title='2025-03-06 10:10:36 +0800 +0800'>三月 6, 2025</span>&nbsp;·&nbsp;11 分钟&nbsp;·&nbsp;5087 字&nbsp;·&nbsp;冷漠三狗子丶</div></header><div class=post-content><h1 id=什么是aop>什么是AOP？<a hidden class=anchor aria-hidden=true href=#什么是aop>#</a></h1><p>**AOP：**Aspect Oriented Programming（面向切面编程、面向方面编程），可简单理解为就是面向特定方法编程。</p><p>**场景：**案例中部分业务方法运行较慢，定位执行耗时较长的接口，此时需要统计每一个业务方法的执行耗时。</p><p><strong>优势：</strong></p><ol><li>减少重复代码（用计算运行时间的代码示例，不需要每个方法里边都写检测时间逻辑）</li><li>代码无侵入（不需要改变原来的方法的代码）</li><li>提高开发效率（不需要修改一个一个方法）</li><li>维护方便（直接注释掉AOP的方法，就可以进行维护）</li></ol><p>AOP是一种思想，而在Spring框架中对这种思根进行的实现，那我们要学习的就是Spring AOP。</p><h1 id=aop基础>AOP基础<a hidden class=anchor aria-hidden=true href=#aop基础>#</a></h1><h2 id=aop快速入门>AOP快速入门<a hidden class=anchor aria-hidden=true href=#aop快速入门>#</a></h2><p>需求：统计所有业务层方法的执行耗时。</p><p><img loading=lazy src=/images/Day13Spring-AOP.assets/1735094732132-c9313c99-4732-4049-849a-6a893ce1fe08.png alt></p><p><strong>步骤：</strong></p><p><strong>1、导入依赖：在pom.xml中引入AOP的依赖</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=w>        </span><span class=o>&lt;!--</span><span class=w> </span><span class=n>AOP起步依赖</span><span class=w> </span><span class=o>--&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=o>&lt;</span><span class=n>dependency</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=o>&lt;</span><span class=n>groupId</span><span class=o>&gt;</span><span class=n>org</span><span class=p>.</span><span class=na>springframework</span><span class=p>.</span><span class=na>boot</span><span class=o>&lt;/</span><span class=n>groupId</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=o>&lt;</span><span class=n>artifactId</span><span class=o>&gt;</span><span class=n>spring</span><span class=o>-</span><span class=n>boot</span><span class=o>-</span><span class=n>starter</span><span class=o>-</span><span class=n>aop</span><span class=o>&lt;/</span><span class=n>artifactId</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=o>&lt;/</span><span class=n>dependency</span><span class=o>&gt;</span><span class=w>
</span></span></span></code></pre></div><p>父工程用了Spring框架，所以不需要指定版本</p><p><strong>2、编写AOP程序：针对于特定的方法根据业务需要进行编程</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Component</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@Slf4j</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@Aspect</span><span class=w> </span><span class=c1>// 当前类是切面类</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>RecordTimeAspect</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 还得记得配置生效的范围</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Around</span><span class=p>(</span><span class=s>&#34;execution(* com.itheima.service.impl.*.*(..))&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>Object</span><span class=w> </span><span class=nf>recordTime</span><span class=p>(</span><span class=n>ProceedingJoinPoint</span><span class=w> </span><span class=n>pjp</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>Throwable</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 1、记录方法的开始时间</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>long</span><span class=w> </span><span class=n>begin</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>System</span><span class=p>.</span><span class=na>currentTimeMillis</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 2、执行目标方法 执行方法需要有ProceedingJoinPoint这个类，调用proceed方法</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Object</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>pjp</span><span class=p>.</span><span class=na>proceed</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 3、记录方法执行时长</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>long</span><span class=w> </span><span class=n>end</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>System</span><span class=p>.</span><span class=na>currentTimeMillis</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// pjp.getSignature()可以获得执行方法的名字</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>log</span><span class=p>.</span><span class=na>info</span><span class=p>(</span><span class=s>&#34;{}方法执行耗时{}ms&#34;</span><span class=p>,</span><span class=n>pjp</span><span class=p>.</span><span class=na>getSignature</span><span class=p>(),</span><span class=n>end</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>begin</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>result</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=aop中的核心概念>AOP中的核心概念<a hidden class=anchor aria-hidden=true href=#aop中的核心概念>#</a></h2><ul><li>**连接点：**JoinPoint，<strong>可以被AOP控制的方法</strong>（暗含方法执行时的相关信息）</li><li><strong>通知：<strong>Advice，指那些</strong>重复的逻辑</strong>，也就是<strong>共性功能</strong>（最终<strong>体现为一个方法</strong>）</li><li><strong>切入点：<strong>PointCut，匹配</strong>连接点的条件</strong>，通知仅会在切入点方法执行时被应用</li><li>**切面：**Aspect，描述通知与切入点的对应关系（<strong>通知＋切入点</strong>）</li><li>**目标对象：**Target，<strong>通知所应用的对象</strong></li></ul><p>连接点：可以被AOP控制的方法</p><p>切入点：实际被AOP控制的方法</p><p><strong>切入点一定是连接点，但是连接点不一定是切入点</strong></p><p><img loading=lazy src=/images/Day13Spring-AOP.assets/1735095916253-76c91b33-19c6-422f-8c56-bb74c9150ce4.png alt></p><p><img loading=lazy src=/images/Day13Spring-AOP.assets/1735095936998-dcb3cc5b-8ecb-4ee7-b663-21cd9fbc9c99.png alt></p><h2 id=aop的执行流程>AOP的执行流程<a hidden class=anchor aria-hidden=true href=#aop的执行流程>#</a></h2><p><img loading=lazy src=/images/Day13Spring-AOP.assets/1735095978877-b9274194-1c1a-48c0-8ff1-cfd81fdd9ada.png alt></p><p>AOP是基于动态代理技术，为目标对象生成一个代理对象，然后实际调用的时候是调用的代理对象</p><h1 id=aop进阶>AOP进阶<a hidden class=anchor aria-hidden=true href=#aop进阶>#</a></h1><h2 id=通知类型>通知类型<a hidden class=anchor aria-hidden=true href=#通知类型>#</a></h2><p>根据通知方法执行时机的不同，将通知类型分为以下常见的五类：</p><ol><li>@Around：<strong>环绕通知</strong>，此注解标注的通知方法在<strong>目标方法前、后</strong>都被执行</li></ol><p>@Around环绕通知<strong>需要自己调用 ProceedingJoinPoint.proceed()来</strong>让原始方法执行，其他通知不需要考虑目标方法执行</p><p>@Around环绕通知方法的返回值，<strong>必须指定为Object</strong>，来接收原始方法的返回值</p><ol start=2><li>@Before：<strong>前置通知</strong>，此注解标注的通知方法在<strong>目标方法前</strong>被执行</li><li>@After：<strong>后置通知</strong>，此注解标注的通知方法在<strong>目标方法后</strong>被执行，<strong>无论是否有异常都会执行</strong></li><li>@AfterReturning： <strong>返回后通知</strong>，此注解标注的通知方法在目标方法后被执行，<strong>有异常不会执行</strong></li><li>@AfterThrowdng：<strong>异常后通知</strong>，此注解标注的通知方法<strong>发生异常后执行</strong></li></ol><hr><p><strong>@PointCut注解</strong></p><p><strong>该注解的作用是将公共的切点表达式抽取出来，需要用到时引用该切点表达式即可。</strong></p><p><img loading=lazy src=/images/Day13Spring-AOP.assets/1735101029594-9cc22eb8-e36e-4ebc-940f-7f82a3838475.png alt></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Aspect</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@Component</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@Slf4j</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>DemoAspect</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 定义一个pt函数，都可以调用pt来获得切入点</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Pointcut</span><span class=p>(</span><span class=s>&#34;execution(* com.itheima.service.impl.*.*(..))&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>pt</span><span class=p>(){}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 前置通知</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Before</span><span class=p>(</span><span class=s>&#34;pt()&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>before</span><span class=p>(){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>log</span><span class=p>.</span><span class=na>info</span><span class=p>(</span><span class=s>&#34;before....&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 后置通知</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@After</span><span class=p>(</span><span class=s>&#34;pt()&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>after</span><span class=p>(){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>log</span><span class=p>.</span><span class=na>info</span><span class=p>(</span><span class=s>&#34;after....&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 环绕通知</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Around</span><span class=p>(</span><span class=s>&#34;pt()&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>Object</span><span class=w> </span><span class=nf>around</span><span class=p>(</span><span class=n>ProceedingJoinPoint</span><span class=w> </span><span class=n>pjp</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>Throwable</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>log</span><span class=p>.</span><span class=na>info</span><span class=p>(</span><span class=s>&#34;around before....&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Object</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>pjp</span><span class=p>.</span><span class=na>proceed</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>log</span><span class=p>.</span><span class=na>info</span><span class=p>(</span><span class=s>&#34;around after....&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>result</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 返回后通知</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@AfterReturning</span><span class=p>(</span><span class=s>&#34;pt()&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>afterReturning</span><span class=p>(){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>log</span><span class=p>.</span><span class=na>info</span><span class=p>(</span><span class=s>&#34;afterReturning....&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 异常后通知</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@AfterThrowing</span><span class=p>(</span><span class=s>&#34;pt()&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>afterThrowing</span><span class=p>(){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>log</span><span class=p>.</span><span class=na>info</span><span class=p>(</span><span class=s>&#34;afterThrowing....&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=通知顺序>通知顺序<a hidden class=anchor aria-hidden=true href=#通知顺序>#</a></h2><p>当有多个切面的切入点都匹配到了目标方法，目标方法运行时，多个通知方法都会被执行。</p><p>执行顺序：</p><p>不同切面类中，默认按照切面类的类名字母排序：</p><ul><li>目标方法前的通知方法：字母排名靠前的先执行</li><li>目标方法后的通知方法：字母排名靠前的后执行</li></ul><p>用 @Order（数字）加在切面类上来控制顺序</p><ul><li>目标方法前的通知方法：数字小的先执行</li><li>目标方法后的通知方法：数字小的后执行</li></ul><p><img loading=lazy src=/images/Day13Spring-AOP.assets/1735103584063-8f2209ae-81aa-4a3d-ac21-591391361f1d.png alt></p><h2 id=切入点表达式>切入点表达式<a hidden class=anchor aria-hidden=true href=#切入点表达式>#</a></h2><p>介绍：描述<strong>切入点方法的一种表达式</strong>。</p><p>作用：用来决定项目中的<strong>哪些方法需要加入通知。</strong></p><p><strong>可以匹配到接口，会匹配所有接口的实现类方法，可以基于接口来匹配</strong></p><p>常见形式：</p><ol><li>execution（&mldr;.）：根据方法的签名来匹配</li><li>@annotation（&mldr;.）：根据注解匹配</li></ol><h3 id=切入点表达式-execution>切入点表达式-execution<a hidden class=anchor aria-hidden=true href=#切入点表达式-execution>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Before</span><span class=p>(</span><span class=s>&#34;execution(void com.itheima.service.impl.DeptServiceImpl.delete(java.lang.Integer))&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@Before</span><span class=p>(</span><span class=s>&#34;execution(* com.itheima.service.impl.*.*(..) )&#34;</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></div><p>语法：</p><p>execution(访问修饰符? 返回值 包名.类名.?方法名(方法参数) throws 异常?)</p><p>其中带？的表示可以省略的部分</p><ol><li>访问修饰符：可省略（比如：public、protected）</li><li>包名，类名：可省略（不建议省略）</li><li>throws 异常：可省略（注意是方法上声明抛出的异常，不是实际抛出的异常）</li></ol><p>可以使用通配符描述切入点</p><p>*：单个独立的任意符号，可以通配任意返回值、包名、类名、方法名、任意类型的一个参数，也可以通配包、类、方法名的一部分</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>execution</span><span class=p>(</span><span class=o>*</span><span class=w> </span><span class=n>com</span><span class=p>.</span><span class=o>*</span><span class=p>.</span><span class=na>service</span><span class=p>.</span><span class=o>*</span><span class=p>.</span><span class=na>update</span><span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=p>))</span><span class=w>
</span></span></span></code></pre></div><p>..：多个连续的任意符号，可以通配任意层级的包，或任意类型、任意个数的参数</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>execution</span><span class=p>(</span><span class=o>*</span><span class=w> </span><span class=n>com</span><span class=p>.</span><span class=na>itheima</span><span class=p>..</span><span class=na>DeptService</span><span class=p>.</span><span class=o>*</span><span class=p>(..))</span><span class=w>
</span></span></span></code></pre></div><p>根据业务需要，可以使用且（&&）、或（II）、非（！）来组合比较复杂的切入点表达式。</p><p>可以使用逻辑运算符来匹配</p><h3 id=切入点表达式-annotation>切入点表达式-Annotation<a hidden class=anchor aria-hidden=true href=#切入点表达式-annotation>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=w>    </span><span class=nd>@Before</span><span class=p>(</span><span class=s>&#34;@annotation(com.itheima.anno.LogOperation)&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 这里边写的是定义的注解的全类名</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>before</span><span class=p>(){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>log</span><span class=p>.</span><span class=na>info</span><span class=p>(</span><span class=s>&#34;MyAspect4 -&gt; before ...&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// 在需要使用切入点的地方添加自定义的注解</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@LogOperation</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>save</span><span class=p>(</span><span class=n>Dept</span><span class=w> </span><span class=n>dept</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>dept</span><span class=p>.</span><span class=na>setCreateTime</span><span class=p>(</span><span class=n>LocalDateTime</span><span class=p>.</span><span class=na>now</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>dept</span><span class=p>.</span><span class=na>setUpdateTime</span><span class=p>(</span><span class=n>LocalDateTime</span><span class=p>.</span><span class=na>now</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>deptMapper</span><span class=p>.</span><span class=na>save</span><span class=p>(</span><span class=n>dept</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>如果execution切入点表达式方便描述指定的方法，就使用execution表达式</p><p>否则，就使用@annotation切入点表达式</p><h2 id=连接点>连接点<a hidden class=anchor aria-hidden=true href=#连接点>#</a></h2><p>在Spring中用JoinPoint抽象了连接点，用它可以获得方法执行时的相关信息，如目标类名、方法名、方法参数等。</p><p>对于 @Around 通知，获取连接点信息只能使用 ProceedingJoinPoint（这个是JoinPoint的子类）</p><p>对于其它四种通知，获取连接点信息只能使用 JoinPoint，它是 ProceedingJoinPoint 的父类型</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=w>    </span><span class=nd>@Before</span><span class=p>(</span><span class=s>&#34;execution(* com.itheima.service.impl.*.*(..))&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>before</span><span class=p>(</span><span class=n>JoinPoint</span><span class=w> </span><span class=n>joinPoint</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 获取目标类名</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>String</span><span class=w> </span><span class=n>className</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>joinPoint</span><span class=p>.</span><span class=na>getTarget</span><span class=p>().</span><span class=na>getClass</span><span class=p>().</span><span class=na>getName</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>log</span><span class=p>.</span><span class=na>info</span><span class=p>(</span><span class=s>&#34;目标类名：{}&#34;</span><span class=p>,</span><span class=n>className</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 获取目标方法签名</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Signature</span><span class=w> </span><span class=n>signature</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>joinPoint</span><span class=p>.</span><span class=na>getSignature</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>log</span><span class=p>.</span><span class=na>info</span><span class=p>(</span><span class=s>&#34;方法签名：{}&#34;</span><span class=p>,</span><span class=n>signature</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 获取目标方法名</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>String</span><span class=w> </span><span class=n>methodName</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>joinPoint</span><span class=p>.</span><span class=na>getSignature</span><span class=p>().</span><span class=na>getName</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>log</span><span class=p>.</span><span class=na>info</span><span class=p>(</span><span class=s>&#34;目标方法名：{}&#34;</span><span class=p>,</span><span class=n>methodName</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 获取参数</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Object</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>joinPoint</span><span class=p>.</span><span class=na>getArgs</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>log</span><span class=p>.</span><span class=na>info</span><span class=p>(</span><span class=s>&#34;参数：{}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>Arrays</span><span class=p>.</span><span class=na>toString</span><span class=p>(</span><span class=n>args</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>运行结果：</p><p><img loading=lazy src=/images/Day13Spring-AOP.assets/1735261538492-bc094d5d-875e-4fd3-8a54-6f07802a16ed.png alt></p><h1 id=aop案例>AOP案例<a hidden class=anchor aria-hidden=true href=#aop案例>#</a></h1><p>将案例中增、删、改相关接口的操作日志记录到数据库表中</p><p>日志信息包含：操作人、操作时间、执行方法的全类名、执行方法名、方法运行时参数、返回值、方法执行时长</p><p>采用哪种通知类型？ @Around环绕通知</p><p>切入点表达式该怎么写？</p><p>由于增、删、改 方法名我们定义的比较规范，分别为save、delete、update</p><p><strong>用execution比较复杂</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Around</span><span class=p>(</span><span class=s>&#34;execution(* com.itheima.controller.*.save(..)) ||&#34;</span><span class=w> </span><span class=o>+</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=s>&#34;execution(* com.itheima.controller.*.delete(..)) ||&#34;</span><span class=w> </span><span class=o>+</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=s>&#34;execution(* com.itheima.controller.*.update(..))&#34;</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></div><p><strong>用annotation比较方便</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Around</span><span class=p>(</span><span class=s>&#34;@annotation(com.itheima.anno.Log)&#34;</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=w>    </span><span class=nd>@Around</span><span class=p>(</span><span class=s>&#34;@annotation(com.zzzzyj.anno.Log)&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>Object</span><span class=w> </span><span class=nf>around</span><span class=p>(</span><span class=n>ProceedingJoinPoint</span><span class=w> </span><span class=n>joinPoint</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>Throwable</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 记录开始时间</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>long</span><span class=w> </span><span class=n>startTime</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>System</span><span class=p>.</span><span class=na>currentTimeMillis</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 执行方法</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Object</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>joinPoint</span><span class=p>.</span><span class=na>proceed</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 当前时间</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>long</span><span class=w> </span><span class=n>endTime</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>System</span><span class=p>.</span><span class=na>currentTimeMillis</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 耗时</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>long</span><span class=w> </span><span class=n>costTime</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>endTime</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>startTime</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 构建日志对象</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>OperateLog</span><span class=w> </span><span class=n>operateLog</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>OperateLog</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>operateLog</span><span class=p>.</span><span class=na>setOperateEmpId</span><span class=p>(</span><span class=n>getCurrentUserId</span><span class=p>());</span><span class=w> </span><span class=c1>// 需要实现 getCurrentUserId 方法</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>operateLog</span><span class=p>.</span><span class=na>setOperateTime</span><span class=p>(</span><span class=n>LocalDateTime</span><span class=p>.</span><span class=na>now</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>operateLog</span><span class=p>.</span><span class=na>setClassName</span><span class=p>(</span><span class=n>joinPoint</span><span class=p>.</span><span class=na>getTarget</span><span class=p>().</span><span class=na>getClass</span><span class=p>().</span><span class=na>getName</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>operateLog</span><span class=p>.</span><span class=na>setMethodName</span><span class=p>(</span><span class=n>joinPoint</span><span class=p>.</span><span class=na>getSignature</span><span class=p>().</span><span class=na>getName</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>operateLog</span><span class=p>.</span><span class=na>setMethodParams</span><span class=p>(</span><span class=n>Arrays</span><span class=p>.</span><span class=na>toString</span><span class=p>(</span><span class=n>joinPoint</span><span class=p>.</span><span class=na>getArgs</span><span class=p>()));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>operateLog</span><span class=p>.</span><span class=na>setReturnValue</span><span class=p>(</span><span class=n>result</span><span class=p>.</span><span class=na>toString</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>operateLog</span><span class=p>.</span><span class=na>setCostTime</span><span class=p>(</span><span class=n>costTime</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>log</span><span class=p>.</span><span class=na>info</span><span class=p>(</span><span class=s>&#34;日志信息{}&#34;</span><span class=p>,</span><span class=n>operateLog</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 插入日志</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>operateLogMapper</span><span class=p>.</span><span class=na>insert</span><span class=p>(</span><span class=n>operateLog</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>result</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 示例方法，获取当前用户ID</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>getCurrentUserId</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 这里应该根据实际情况从认证信息中获取当前登录用户的ID</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w> </span><span class=c1>// 示例返回值</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>获取当前用户ID没有实现</p><h2 id=获取当前用户id>获取当前用户ID<a hidden class=anchor aria-hidden=true href=#获取当前用户id>#</a></h2><p>思考一下：用户ID存在哪里，其实是存在了jwt令牌里边，通过服务器构造的jwt令牌，里边有着ID和用户名信息</p><p><strong>1、员工登录成功后，哪里存储的有当前登录员工的信息？</strong></p><p>给客户端浏览器下发的jwt令牌中</p><p>**2、如何从jwt令牌中获取到当前登录的员工信息？ **</p><p>获取请求头中传递的jwt令牌，并解析</p><p>**3. TokenFilter中已经解析了令牌的信息，如何将其传递给AOP程序、Controller、Service呢？ **ThreadLocal</p><p>在令牌校验过滤器TokenFilter中获取了jwt令牌，并对其进行解析获取当了当前登录员工的ID，如何将这个ID传递给AOP程序、Controller、Service中呢？</p><p></p><h2 id=threadlocal>ThreadLocal<a hidden class=anchor aria-hidden=true href=#threadlocal>#</a></h2><p>ThreadLocal并不是一个Thread，而是Thread的局部变量。</p><p>ThreadLocal为每个线程提供一份单独的存储空间，具有线程隔离的效果，不同的线程之间不会相互干扰。</p><p><img loading=lazy src=/images/Day13Spring-AOP.assets/1735267466740-50efa7ca-a144-46b5-901f-36eb3584ef92.png alt></p><p>ThreadLocal常用方法：（一共只有3个方法）</p><p>• public void set （T value） 设置当前线程的线程局部变量的值</p><p>• public T get（） 返回当前线程所对应的线程局部变量的值</p><p>• public void remove（） 移除当前线程的线程局部变量</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>ThreadLocalTest</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 泛型指定往本地存储空间存储的是什么类型的数据</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=n>ThreadLocal</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>local</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ThreadLocal</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>local</span><span class=p>.</span><span class=na>set</span><span class=p>(</span><span class=s>&#34;Main Message&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>local</span><span class=p>.</span><span class=na>get</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>new</span><span class=w> </span><span class=n>Thread</span><span class=p>(()</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>local</span><span class=p>.</span><span class=na>set</span><span class=p>(</span><span class=s>&#34;Thread Message&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>local</span><span class=p>.</span><span class=na>get</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}).</span><span class=na>start</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>local</span><span class=p>.</span><span class=na>remove</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>local</span><span class=p>.</span><span class=na>get</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><img loading=lazy src=/images/Day13Spring-AOP.assets/1735268401881-238222a3-c34f-49fa-b0ac-86c25bfb387b.png alt></p><p>哪个线程存的只能哪个线程取，哪个线程删</p><p><img loading=lazy src=/images/Day13Spring-AOP.assets/1735268563141-925a596a-5a82-4c6a-8889-0fafb551844b.png alt></p><p><strong>一次请求对应一个线程</strong></p><p>具体操作步骤：</p><ol><li>定义ThreadLocal操作的工具类，用于操作当前登录员工ID。</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>CurrentHolder</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>ThreadLocal</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>CURRENT_LOCAL</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ThreadLocal</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>setCurrentId</span><span class=p>(</span><span class=n>Integer</span><span class=w> </span><span class=n>employeeId</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>CURRENT_LOCAL</span><span class=p>.</span><span class=na>set</span><span class=p>(</span><span class=n>employeeId</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=n>Integer</span><span class=w> </span><span class=nf>getCurrentId</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>CURRENT_LOCAL</span><span class=p>.</span><span class=na>get</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>remove</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>CURRENT_LOCAL</span><span class=p>.</span><span class=na>remove</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>里边就是定义了一个<strong>静态变量ThreadLocal</strong></p><ol start=2><li>在TokenFilter中，解析完当前登录员工ID，将其存入ThreadLocal（<strong>用完之后需将其删除</strong>）。</li><li>在AOP程序中，从ThreadLocal中获取当前登录员工的ID。</li></ol><h3 id=用完删除这个逻辑的困惑分析>用完删除这个逻辑的困惑分析<a hidden class=anchor aria-hidden=true href=#用完删除这个逻辑的困惑分析>#</a></h3><p>困惑产生的原因：为什么里边没有调用Aop的方法，却需要在放行之后把他删除，其实对于Filter过滤器，他的执行步骤是这样的：</p><p><img loading=lazy src=/images/Day13Spring-AOP.assets/1735275229382-30879189-7a42-4ef1-8ad2-366030a975ec.png alt></p><p>注意这两个问题，还会回到Filter中，所以在放行之后的逻辑就是用来执行清楚内容的，放行之后不是直接执行清楚操作，而是进去了Controller层</p><p>那么我用Interceptor为什么同样的操作却不行呢</p><p>原因：</p><p>Interceptor里边有三个函数可以重写，我一直写在preHandle中，当然不行，他永远只是会在放行前执行，即使使用了try-finally代码块，还是不可以</p><p>但是如果我用postHandle函数处理的话，就可以成功，因为的执行时间相当于在放行回来后</p><p></p><p>代码如下：<br>验证token的时候，将jwt令牌的id信息存在ThreadLocal中</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Claims</span><span class=w> </span><span class=n>claims</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>JwtUtils</span><span class=p>.</span><span class=na>parseJWT</span><span class=p>(</span><span class=n>token</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>String</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>claims</span><span class=p>.</span><span class=na>get</span><span class=p>(</span><span class=s>&#34;id&#34;</span><span class=p>).</span><span class=na>toString</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>CurrentHolder</span><span class=p>.</span><span class=na>setCurrentId</span><span class=p>(</span><span class=n>Integer</span><span class=p>.</span><span class=na>valueOf</span><span class=p>(</span><span class=n>id</span><span class=p>));</span><span class=w>
</span></span></span></code></pre></div><p>在Interceptor中进行删除</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>postHandle</span><span class=p>(</span><span class=n>HttpServletRequest</span><span class=w> </span><span class=n>request</span><span class=p>,</span><span class=w> </span><span class=n>HttpServletResponse</span><span class=w> </span><span class=n>response</span><span class=p>,</span><span class=w> </span><span class=n>Object</span><span class=w> </span><span class=n>handler</span><span class=p>,</span><span class=w> </span><span class=n>ModelAndView</span><span class=w> </span><span class=n>modelAndView</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>Exception</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>CurrentHolder</span><span class=p>.</span><span class=na>remove</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>在Filter中进行删除</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=w>        </span><span class=n>log</span><span class=p>.</span><span class=na>info</span><span class=p>(</span><span class=s>&#34;令牌通过校验，放行&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>filterChain</span><span class=p>.</span><span class=na>doFilter</span><span class=p>(</span><span class=n>servletRequest</span><span class=p>,</span><span class=n>servletResponse</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>CurrentHolder</span><span class=p>.</span><span class=na>remove</span><span class=p>();</span><span class=w>
</span></span></span></code></pre></div><p><strong>作业里边的日志记录遇到的bug</strong></p><hr><p><strong>这个bug的原因是用了@Controller而没有用@RestController这个注解，导致会递归访问/log/log/page这个路径</strong></p><hr><ul><li><code>@Controller</code>：这是一个通用的注解，用于定义一个Spring MVC控制器。它不会提供任何额外的功能，只是告诉Spring框架这个类是一个控制器。</li><li><code>@RestController</code>：这是一个特定于返回值的注解，它是<code>@Controller</code>和<code>@ResponseBody</code>的组合。这意味着任何在<code>@RestController</code>注解的类中定义的方法都会自动应用<code>@ResponseBody</code>注解，这会导致Spring框架将方法的返回值写入HTTP响应体中，而不是返回一个视图。</li></ul><p>**<br>**在Spring MVC中，<code>@Controller</code>和<code>@RestController</code>注解都用于定义控制器，但它们在处理请求路径时的行为有所不同。当你使用<code>@Controller</code>注解时，Spring MVC会尝试使用视图解析器来解析路径，这意味着如果你的路径中包含斜杠（<code>/</code>），Spring MVC可能会将其解释为视图的路径，而不是URL的一部分。这就是为什么当你使用<code>@Controller</code>注解并访问<code>/log/page</code>路径时，Spring MVC会尝试寻找<code>/log/log/page</code>的原因，因为它将<code>/log</code>解释为视图的前缀，然后继续寻找<code>/log/page</code>作为视图名称。</p><p>相比之下，<code>@RestController</code>注解是<code>@Controller</code>和<code>@ResponseBody</code>的组合，它通常用于创建RESTful风格的Web服务。当使用<code>@RestController</code>时，Spring MVC不会尝试使用视图解析器来解析路径，因为<code>@ResponseBody</code>注解告诉Spring MVC直接将方法的返回值写入HTTP响应体中，而不是返回一个视图名称。因此，当你使用<code>@RestController</code>注解并访问<code>/log/page</code>路径时，Spring MVC会直接将请求映射到对应的处理方法，而不会尝试进一步解析视图路径。</p><p>总结来说，<code>@Controller</code>注解可能会引起Spring MVC对路径的视图解析，而<code>@RestController</code>注解则避免了这一行为，直接将返回值作为响应体返回，这就是为什么在使用<code>@Controller</code>时会出现路径继续寻找的问题，而在<code>@RestController</code>中不会出现。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://wqnm1gb.github.io/tags/java-web/>Java Web</a></li></ul><nav class=paginav><a class=prev href=https://wqnm1gb.github.io/posts/day14spring-%E5%8E%9F%E7%90%86/><span class=title>« 上一页</span><br><span>Day14 Spring-原理</span>
</a><a class=next href=https://wqnm1gb.github.io/posts/day12%E5%90%8E%E7%AB%AFweb%E5%AE%9E%E6%88%98%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81/><span class=title>下一页 »</span><br><span>Day12 后端Web实战（登录认证）</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://wqnm1gb.github.io/>三狗子的博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>