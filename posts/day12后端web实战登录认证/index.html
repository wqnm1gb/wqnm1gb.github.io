<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Day12 后端Web实战（登录认证） | 三狗子的博客</title>
<meta name=keywords content="java Web"><meta name=description content='登录功能


Controller层
    //    接收登录信息
    @PostMapping("/login")
    public Result login(@RequestBody Emp emp) {
        log.info("员工登录：{}", emp);
        LoginInfo loginInfo = empService.login(emp);
        if (loginInfo != null) {
            return Result.success();
        } else {
            return Result.error("用户名或密码错误");
        }
    }
返回的信息中有token，最好重新定一个专门用来返回的类，不要直接使用Emp'><meta name=author content="冷漠三狗子丶"><link rel=canonical href=https://wqnm1gb.github.io/posts/day12%E5%90%8E%E7%AB%AFweb%E5%AE%9E%E6%88%98%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81/><link crossorigin=anonymous href=/assets/css/stylesheet.3d688279d829dc24da48acd11f9e33ebea2f39c035e899e1bf4297d8b7aa89b9.css integrity="sha256-PWiCedgp3CTaSKzRH54z6+ovOcA16Jnhv0KX2Leqibk=" rel="preload stylesheet" as=style><link rel=icon href=https://wqnm1gb.github.io/images/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://wqnm1gb.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wqnm1gb.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wqnm1gb.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://wqnm1gb.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://wqnm1gb.github.io/posts/day12%E5%90%8E%E7%AB%AFweb%E5%AE%9E%E6%88%98%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel=stylesheet><script type=text/javascript async src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["[[","]]"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=" has-jax"})</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style><meta property="og:title" content="Day12 后端Web实战（登录认证）"><meta property="og:description" content='登录功能


Controller层
    //    接收登录信息
    @PostMapping("/login")
    public Result login(@RequestBody Emp emp) {
        log.info("员工登录：{}", emp);
        LoginInfo loginInfo = empService.login(emp);
        if (loginInfo != null) {
            return Result.success();
        } else {
            return Result.error("用户名或密码错误");
        }
    }
返回的信息中有token，最好重新定一个专门用来返回的类，不要直接使用Emp'><meta property="og:type" content="article"><meta property="og:url" content="https://wqnm1gb.github.io/posts/day12%E5%90%8E%E7%AB%AFweb%E5%AE%9E%E6%88%98%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81/"><meta property="og:image" content="https://wqnm1gb.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-03-06T10:10:08+08:00"><meta property="article:modified_time" content="2025-03-06T10:10:08+08:00"><meta property="og:site_name" content="三狗子的博客"><meta property="fb:admins" content="your-facebook-admin-id"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wqnm1gb.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Day12 后端Web实战（登录认证）","item":"https://wqnm1gb.github.io/posts/day12%E5%90%8E%E7%AB%AFweb%E5%AE%9E%E6%88%98%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Day12 后端Web实战（登录认证）","name":"Day12 后端Web实战（登录认证）","description":"登录功能 Controller层 // 接收登录信息 @PostMapping(\u0026#34;/login\u0026#34;) public Result login(@RequestBody Emp emp) { log.info(\u0026#34;员工登录：{}\u0026#34;, emp); LoginInfo loginInfo = empService.login(emp); if (loginInfo != null) { return Result.success(); } else { return Result.error(\u0026#34;用户名或密码错误\u0026#34;); } } 返回的信息中有token，最好重新定一个专门用来返回的类，不要直接使用Emp\n","keywords":["java Web"],"articleBody":"登录功能 Controller层 // 接收登录信息 @PostMapping(\"/login\") public Result login(@RequestBody Emp emp) { log.info(\"员工登录：{}\", emp); LoginInfo loginInfo = empService.login(emp); if (loginInfo != null) { return Result.success(); } else { return Result.error(\"用户名或密码错误\"); } } 返回的信息中有token，最好重新定一个专门用来返回的类，不要直接使用Emp\nService层 public LoginInfo login(Emp emp) { // 1、查询用户密码信息 Emp e = empMapper.selectUsernameAndPassword(emp); log.info(\"登录信息{}\",e); // 2、检查信息是否匹配，并且创建一个LoginInfo对象，因为里边的token信息是不会在数据库中查询到的， // 需要在Service层进行补全 if (e != null){ return new LoginInfo(e.getId(),e.getUsername(),e.getName(),e.getPassword(),\"\"); }else { // 3、返回结果 return null; } } Mapper层取的方法的名字可以不用和业务挂钩，直接见名知义即可\nSQL语句太简单了，就不复制过来了。\n登录校验功能 因为刚刚设置的登录功能其实是假的，因为我们可以直接绕过，并没有进行认证，就像是安全里边说的登录绕过\n登录认证的思路如下：\n因为定义的接口很多，不可能每个里边都加一个验证功能，所以加一个统一拦截的功能，这个想法很细节\n登录标记：用户登录成功之后，在后续的每一次请求中，都可以获取到该标记。【会话技术】\n统一拦截：过滤器Filter、拦截器Interceptor\n会话技术 会话：用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以包含多次请求和响应。\n会话跟踪：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间共享数据（课上举的是验证码的例子，首先客户端请求服务器响应验证码，然后登录之后，服务器响应的是新的登录请求，但是这次登录请求需要与上一次的验证码的响应进行比对，看看验证码是否输入正确）。\n会话跟踪方案：\n客户端会话跟踪技术：Cookie 服务端会话跟踪技术：Session 令牌技术 Cookie技术 优点：HTTP协议中支持的技术\nhttp支持cookie，在请求数据中包含了请求头Cookie，在响应数据中包含了响应头Set-Cookie\n在同一次会话的多次请求之间共享数据，只需要把需要共享的数据放在Cookie中\n缺点：\n移动端APP无法使用Cookie（安卓和iOS不支持） 不安全，用户可以自己禁用Cookie Cookie不能跨域（如下图所示）访问前端服务器的时候可以有Cookie，但是请求后端数据的时候，Cookie就失效了 Sessions技术 优点：存储在服务端，安全\n缺点：\n服务器集群环境下无法直接使用Session Cookie的缺点 Nginx可以做负载均衡服务器，不同的服务器没有存sessions，所以分布式的环境不适用\n访问s1，会有响应set-cookie\n访问s2，会有Cookie数据返回\n令牌技术 令牌技术是现在的主流技术\n优点：\n支持PC端、移动端 解决集群环境下的认证问题 减轻服务器端存储压力 缺点：需要自己实现\nJWT令牌 全称：JSON web Token （https://jwt.io/）\n定义了一种简洁的、自包含的格式，用于在通信双方以json数据格式安全的传输信息。\n组成：\n第一部分：Header（头），记录令牌类型、签名算法等。例如｛“alg”：“HS256”，“type”：“JWT”｝ 第二部分：Payload（有效载荷），携带一些自定义信息、默认信息等。例如：｛“id”：“1”，“username\"：“Tom”｝ 第三部分：Signature（签名），防止Token被篡改、确保安全性。将header、payload融入，并加入指定秘钥，通过指定签名算法计算而来。 = 是base64编码中的补位符号\n签名不是 base64编码，而是基于一定的加密规则加密出来的字符串\n令牌的长度不是固定的\n生成令牌 // 生成的令牌：\"eyJhbGciOiJIUzI1NiJ9.eyJpZCI6NSwidXNlcm5hbWUiOiJhZG1pbiIsImV4cCI6MTczNDkyNDYyNX0.qJbvnksEHOmoE-OvNDuOUVjuCG0y4EDa1Ad_jDfhYs8\" @Test public void testJwtGenerate() { Map\u003cString, Object\u003e dataMap = new HashMap\u003c\u003e(); dataMap.put(\"id\",5); dataMap.put(\"username\",\"admin\"); String jwt = Jwts.builder(). // 生成一个jwt令牌 signWith(SignatureAlgorithm.HS256, \"enp6enlq\"). // 设置签名算法和密钥 addClaims(dataMap). // 设置自定义数据 setExpiration(new Date(System.currentTimeMillis() + 3600 * 1000)). // 设置过期时间，先获取现在的时间戳，再添加3600毫秒的1000倍就是一个小时 compact(); // 生成jwt令牌 System.out.println(jwt); } 解析令牌 @Test public void testJwtParse() { String token = \"eyJhbGciOiJIUzI1NiJ9.eyJpZCI6NSwidXNlcm5hbWUiOiJhZG1pbiIsImV4cCI6MTczNDkyNDY4Nn0._nJwP9_V7Z6vaTC_nWeubmaF9W58QXHtLdOtrKuGkG0\"; Claims claims = Jwts.parser(). setSigningKey(\"enp6enlq\"). parseClaimsJws(token). // 这里是s不是t 导致了错误的原因 getBody(); System.out.println(claims); } **parseClaimsJwt**方法： 这个方法适用于解析未签名的JWT。它不验证JWT的签名，只是简单地解析JWT字符串并返回一个包含载荷（Payload）的Claims对象。因此，如果你的JWT没有签名，或者你不需要验证签名，可以使用这个方法。 代码示例：Jwts.parser().parseClaimsJwt(jwt).getBody(); **parseClaimsJws**方法： 这个方法用于解析已签名的JWT。它会验证JWT的结构和签名，确保JWT是有效的。如果签名验证失败，会抛出异常。这个方法返回一个Jws对象，其中包含了JWT的头部（Header）、载荷（Payload）和签名（Signature）。 代码示例：Jwts.parser().parseClaimsJws(token).getBody(); 令牌被篡改或者令牌过期，都会报错\nJWT校验时使用的签名秘钥，必须和生成JWT令牌时使用的秘钥是配套的\n登录成功后-生成令牌 分析：令牌是怎么来的？\n是第一次登录成功的时候，从服务器生成一个令牌传回来给客户端的，然后客户端会一直保存着\n1、定义JWT令牌操作工具类。（基于AI）\n2、登录完成后，调用工具类生成JWT令牌，并返回。\n过滤器-Filter 概念：Filter过滤器，是Javaweb三大组件（Servlet、Filter、Listener）之一。（现在只有Filter还有人用）\n过滤器可以把对资源的请求拦截下来，从而实现一些特殊的功能。\n过滤器一般完成一些通用的操作，比如：登录校验、统一编码处理、敏感字符处理等。\nFilter是在servlet下的包\n使用步骤 定义Filter：定义一个类，实现 Filter 接口，并实现其所有方法。 配置Filter：Filter类上加@WebFilter注解，配置拦截路径。引导类上加 @ServletComponentScan 开启Servlet组件支持。 @Slf4j @WebFilter public class DemoFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { log.info(\"init方法执行了...\"); } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { log.info(\"doFilter方法执行了...\"); filterChain.doFilter(servletRequest,servletResponse); } @Override public void destroy() { log.info(\"destroy方法执行了...\"); } } filterChain中只包含了一个方法，就是doFilter方法，用于放行\n思考：\n所有的请求，拦截到了之后，都需要校验令牌吗？有一个例外，登录请求，或者注册请求 拦截到请求后，什么情况下才可以放行，执行业务操作？有令牌，且令牌校验通过（合法）；否则都返回未登录错误结果 令牌校验Filter-流程 获取请求url。 判断请求url中是否包含login，如果包含，说明是登录操作，放行。 获取请求头中的令牌（token）。 判断令牌是否存在，如果不存在，响应401。 解析token，如果解析失败，响应401。 放行。 代码实现：\n@Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { // 1、获取请求路径 // 1.1 先把Request对象转换为HttpServletRequest对象 HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; String requestURI = request.getRequestURI(); // 2、判断是否包含登录请求 if (requestURI.contains(\"login\")){ log.info(\"登录请求，放行\"); // 放行 filterChain.doFilter(servletRequest,servletResponse); return; } // 3、不是登录请求，就判断是否携带token String token = request.getHeader(\"token\"); if (token==null || token.isEmpty()){ log.info(\"请求头中不存在token，响应401...\"); // 4、没有携带token，就响应401 response.setStatus(HttpServletResponse.SC_UNAUTHORIZED); return; } // 5、携带了token，解析token try { JwtUtils.parseJWT(token); } catch (Exception e) { log.info(\"令牌未通过校验，响应401\"); response.setStatus(HttpServletResponse.SC_UNAUTHORIZED); return; } // 6、解析成功，放行 log.info(\"令牌通过校验，放行\"); filterChain.doFilter(servletRequest,servletResponse); } 思考：\n记得要加@WebFilter(urlPatterns = \"/*\") 注解，要不然不会生效，这个注解可以指定拦截的路径，注意一个服务器里的过滤器不要冲突了\n这个代码想要实现需要逻辑比较清晰，前边的需要把对象转换成HttpServletRequest不要忘记了，本质上就是HttpServletRequest\nHttpServletResponse.SC_UNAUTHORIZED 这个的值就是401\nFilter执行流程 问题1：放行后访问对应资源，资源访问完成后，还会回到Filter中吗？会\n问题2：如果回到Filter中，是重新执行还是执行放行后的逻辑呢？执行放行后逻辑\nFilter拦截路径 根据@WebFilter里边的urlPatterns的值不同，可以拦截不同的路径\n拦截路径 urlPatterns值 含义 拦截具体路径 /login 只有访问 /login 路径时，才会被拦截 目录拦截 /emps/* 访问/emps下的所有资源，都会被拦截 拦截所有 /* 访问所有资源，都会被拦截 Filter过滤器链 介绍：一个web应用中，可以配置多个过滤器，这多个过滤器就形成了一个过滤器链。\n顺序：注解配置的Filter，优先级是按照过滤器类名（字符串）的自然排序。\n执行序号已经在图上的编号中标出来了\n拦截器-Interceptor 概念：是一种动态拦截方法调用的机制，类似于过滤器。Spring框架中提供的，主要用来动态拦截控制器方法的执行。\n作用：拦截请求，在指定的方法调用前后，根据业务需要执行预先设定的代码。\nInterceptor快速入门 拦截器是Spring提供的，需要加上@Component交给IOC容器管理\n拦截器实现的步骤：\n1、定义拦截器\n@Component @Slf4j public class DemoInterceptor implements HandlerInterceptor { // 目标方法执行前，返回TRUE放行请求，返回FALSE拦截请求 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { log.info(\"preHandle ....\"); return true; } // 目标方法执行后 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { log.info(\"postHandle ....\"); } // 视图渲染完毕后 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { log.info(\"afterCompletion ....\"); } } 注意有加上Component注解，加入到ioc容器中\n2、注册拦截器，定义配置类实现WebMv\n@Configuration public class WebConfig implements WebMvcConfigurer { @Autowired private DemoInterceptor demoInterceptor; // 注册自定义拦截器对象 @Override public void addInterceptors(InterceptorRegistry registry) { // 设置拦截器拦截的路径 registry.addInterceptor(demoInterceptor).addPathPatterns(\"/**\"); } } 在拦截器中拦截所有用的是/**\n令牌校验-拦截器 里边的逻辑和Filter一样，只需要控制返回值即可\n拦截器的放行只需要通过return的值来控制\n拦截器-拦截路径 可以在配置中配置可以放行的路径，这样就不需要判断\n@Override public void addInterceptors(InterceptorRegistry registry) { // 设置拦截器拦截的路径 registry.addInterceptor(tokenInterceptor) .addPathPatterns(\"/**\") .excludePathPatterns(\"/login\"); } 拦截路径 含义 举例 /* 一级路径 能匹配/depts，/emps，/login，不能匹配 /depts/1 /** 任意级路径 能匹配/depts，/depts/1，/depts/1/2 /depts/* /depts下的一级路径 能匹配/depts/1，不能匹配/depts/1/2，/depts /depts/** /depts下的任意级路径 能匹配/depts，/depts/1，/depts/1/2，不能匹配/emps/1 拦截器-执行流程 拦截器是Spring提供的技术，他只会拦截对于Spring的请求，而过滤器是Servlet规范中提供的技术，所以他的拦截权限更高，可以拦截所有资源\nFilter 与 Interceptor 区别：\n接口规范不同：过滤器需要实现Filter接口，而拦截器需要实现HandlerInterceptor接口。 拦截范围不同：过滤器Filter会拦截所有的资源，而Interceptor只会拦截Spring环境中的资源。 ","wordCount":"4752","inLanguage":"zh","image":"https://wqnm1gb.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-03-06T10:10:08+08:00","dateModified":"2025-03-06T10:10:08+08:00","author":{"@type":"Person","name":"冷漠三狗子丶"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wqnm1gb.github.io/posts/day12%E5%90%8E%E7%AB%AFweb%E5%AE%9E%E6%88%98%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81/"},"publisher":{"@type":"Organization","name":"三狗子的博客","logo":{"@type":"ImageObject","url":"https://wqnm1gb.github.io/images/favicon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wqnm1gb.github.io/ accesskey=h title="主页 (Alt + H)"><img src=https://wqnm1gb.github.io/apple-touch-icon.png alt aria-label=logo height=35>主页</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wqnm1gb.github.io/ title=三狗子的博客><span>首页</span></a></li><li><a href=https://wqnm1gb.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://wqnm1gb.github.io/categories/ title=Categories><span>分类</span></a></li><li><a href=https://wqnm1gb.github.io/tags/ title=Tags><span>标签</span></a></li><li><a href=https://wqnm1gb.github.io/search/ title=搜索><span>搜索</span></a></li><li><a href=https://wqnm1gb.github.io/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://wqnm1gb.github.io/>主页</a>&nbsp;»&nbsp;<a href=https://wqnm1gb.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Day12 后端Web实战（登录认证）</h1><div class=post-meta><span title='2025-03-06 10:10:08 +0800 +0800'>三月 6, 2025</span>&nbsp;·&nbsp;10 分钟&nbsp;·&nbsp;4752 字&nbsp;·&nbsp;冷漠三狗子丶</div></header><div class=post-content><h1 id=登录功能>登录功能<a hidden class=anchor aria-hidden=true href=#登录功能>#</a></h1><p><img loading=lazy src=/images/Day12%e5%90%8e%e7%ab%afWeb%e5%ae%9e%e6%88%98%ef%bc%88%e7%99%bb%e5%bd%95%e8%ae%a4%e8%af%81%ef%bc%89.assets/1734842185377-afcbdfcd-b857-4293-bfd7-949c29c1c2d8.png alt></p><h2 id=controller层>Controller层<a hidden class=anchor aria-hidden=true href=#controller层>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=w>    </span><span class=c1>//    接收登录信息</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@PostMapping</span><span class=p>(</span><span class=s>&#34;/login&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>Result</span><span class=w> </span><span class=nf>login</span><span class=p>(</span><span class=nd>@RequestBody</span><span class=w> </span><span class=n>Emp</span><span class=w> </span><span class=n>emp</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>log</span><span class=p>.</span><span class=na>info</span><span class=p>(</span><span class=s>&#34;员工登录：{}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>emp</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>LoginInfo</span><span class=w> </span><span class=n>loginInfo</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>empService</span><span class=p>.</span><span class=na>login</span><span class=p>(</span><span class=n>emp</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>loginInfo</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=n>Result</span><span class=p>.</span><span class=na>success</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=n>Result</span><span class=p>.</span><span class=na>error</span><span class=p>(</span><span class=s>&#34;用户名或密码错误&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>返回的信息中有token，最好重新定一个专门用来返回的类，不要直接使用Emp</p><h2 id=service层>Service层<a hidden class=anchor aria-hidden=true href=#service层>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>LoginInfo</span><span class=w> </span><span class=nf>login</span><span class=p>(</span><span class=n>Emp</span><span class=w> </span><span class=n>emp</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 1、查询用户密码信息</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Emp</span><span class=w> </span><span class=n>e</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>empMapper</span><span class=p>.</span><span class=na>selectUsernameAndPassword</span><span class=p>(</span><span class=n>emp</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>log</span><span class=p>.</span><span class=na>info</span><span class=p>(</span><span class=s>&#34;登录信息{}&#34;</span><span class=p>,</span><span class=n>e</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 2、检查信息是否匹配，并且创建一个LoginInfo对象，因为里边的token信息是不会在数据库中查询到的，</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 需要在Service层进行补全</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>e</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>LoginInfo</span><span class=p>(</span><span class=n>e</span><span class=p>.</span><span class=na>getId</span><span class=p>(),</span><span class=n>e</span><span class=p>.</span><span class=na>getUsername</span><span class=p>(),</span><span class=n>e</span><span class=p>.</span><span class=na>getName</span><span class=p>(),</span><span class=n>e</span><span class=p>.</span><span class=na>getPassword</span><span class=p>(),</span><span class=s>&#34;&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 3、返回结果</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Mapper层取的方法的名字可以不用和业务挂钩，直接见名知义即可</p><p>SQL语句太简单了，就不复制过来了。</p><h1 id=登录校验功能>登录校验功能<a hidden class=anchor aria-hidden=true href=#登录校验功能>#</a></h1><p>因为刚刚设置的登录功能其实是假的，因为我们可以直接绕过，并没有进行认证，就像是安全里边说的登录绕过</p><p><strong>登录认证的思路如下：</strong></p><p><img loading=lazy src=/images/Day12%e5%90%8e%e7%ab%afWeb%e5%ae%9e%e6%88%98%ef%bc%88%e7%99%bb%e5%bd%95%e8%ae%a4%e8%af%81%ef%bc%89.assets/1734842389266-b1b57d62-c61b-441b-9a4f-f04beff58357.png alt></p><p><strong>因为定义的接口很多，不可能每个里边都加一个验证功能，所以加一个统一拦截的功能，这个想法很细节</strong></p><hr><p><strong>登录标记：用户登录成功之后，在后续的每一次请求中，都可以获取到该标记。【会话技术】</strong></p><p><strong>统一拦截：过滤器Filter、拦截器Interceptor</strong></p><h2 id=会话技术>会话技术<a hidden class=anchor aria-hidden=true href=#会话技术>#</a></h2><p>会话：用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。<strong>在一次会话中可以包含多次请求和响应</strong>。</p><p>会话跟踪：一种维护浏览器状态的方法，服务器需要识别多次请求<strong>是否来自于同一浏览器</strong>，以便<strong>在同一次会话的多次请求间共享数据（课上举的是验证码的例子，首先客户端请求服务器响应验证码，然后登录之后，服务器响应的是新的登录请求，但是这次登录请求需要与上一次的验证码的响应进行比对，看看验证码是否输入正确）</strong>。</p><p>会话跟踪方案：</p><ul><li>客户端会话跟踪技术：Cookie</li><li>服务端会话跟踪技术：Session</li><li>令牌技术</li></ul><h2 id=cookie技术>Cookie技术<a hidden class=anchor aria-hidden=true href=#cookie技术>#</a></h2><p><img loading=lazy src=/images/Day12%e5%90%8e%e7%ab%afWeb%e5%ae%9e%e6%88%98%ef%bc%88%e7%99%bb%e5%bd%95%e8%ae%a4%e8%af%81%ef%bc%89.assets/1734842705033-510c7a67-f415-4c2f-a47a-f357736fa930.png alt></p><p><strong>优点：HTTP协议中支持的技术</strong></p><p>http支持cookie，在请求数据中包含了请求头Cookie，在响应数据中包含了响应头Set-Cookie</p><p>在同一次会话的多次请求之间共享数据，只需要把需要共享的数据放在Cookie中</p><p><strong>缺点：</strong></p><ul><li>移动端APP无法使用Cookie（安卓和iOS不支持）</li><li>不安全，用户可以自己禁用Cookie</li><li>Cookie不能跨域（如下图所示）访问前端服务器的时候可以有Cookie，但是请求后端数据的时候，Cookie就失效了</li></ul><p><img loading=lazy src=/images/Day12%e5%90%8e%e7%ab%afWeb%e5%ae%9e%e6%88%98%ef%bc%88%e7%99%bb%e5%bd%95%e8%ae%a4%e8%af%81%ef%bc%89.assets/1734842753332-52c4dfa3-30cb-4884-8e5e-89c9591796ba.png alt></p><h2 id=sessions技术>Sessions技术<a hidden class=anchor aria-hidden=true href=#sessions技术>#</a></h2><p><img loading=lazy src=/images/Day12%e5%90%8e%e7%ab%afWeb%e5%ae%9e%e6%88%98%ef%bc%88%e7%99%bb%e5%bd%95%e8%ae%a4%e8%af%81%ef%bc%89.assets/1734844057629-ec846956-a8a8-403b-b916-1153d0a31910.png alt></p><p><strong>优点：存储在服务端，安全</strong></p><p><strong>缺点：</strong></p><ul><li>服务器集群环境下无法直接使用Session</li><li>Cookie的缺点</li></ul><p><img loading=lazy src=/images/Day12%e5%90%8e%e7%ab%afWeb%e5%ae%9e%e6%88%98%ef%bc%88%e7%99%bb%e5%bd%95%e8%ae%a4%e8%af%81%ef%bc%89.assets/1734844091287-3561481a-7a89-4c1c-be4f-9680832425c4.png alt></p><p>Nginx可以做负载均衡服务器，不同的服务器没有存sessions，所以分布式的环境不适用</p><p>访问s1，会有响应set-cookie</p><p><img loading=lazy src=/images/Day12%e5%90%8e%e7%ab%afWeb%e5%ae%9e%e6%88%98%ef%bc%88%e7%99%bb%e5%bd%95%e8%ae%a4%e8%af%81%ef%bc%89.assets/1734844009454-7daf2721-30a4-4042-9103-a3e9331158b9.png alt></p><p>访问s2，会有Cookie数据返回</p><p><img loading=lazy src=/images/Day12%e5%90%8e%e7%ab%afWeb%e5%ae%9e%e6%88%98%ef%bc%88%e7%99%bb%e5%bd%95%e8%ae%a4%e8%af%81%ef%bc%89.assets/1734844370847-1cbab601-39f0-41d2-863a-1aa5c43c893d.png alt></p><h2 id=令牌技术>令牌技术<a hidden class=anchor aria-hidden=true href=#令牌技术>#</a></h2><p><img loading=lazy src=/images/Day12%e5%90%8e%e7%ab%afWeb%e5%ae%9e%e6%88%98%ef%bc%88%e7%99%bb%e5%bd%95%e8%ae%a4%e8%af%81%ef%bc%89.assets/1734919986708-a9d35b17-170d-4c9e-9cca-6b23cc715e7d.png alt></p><p>令牌技术是现在的主流技术</p><p><strong>优点：</strong></p><ul><li>支持PC端、移动端</li><li>解决集群环境下的认证问题</li><li>减轻服务器端存储压力</li></ul><p><strong>缺点：需要自己实现</strong></p><h1 id=jwt令牌>JWT令牌<a hidden class=anchor aria-hidden=true href=#jwt令牌>#</a></h1><p>全称：JSON web Token （<a href=https://jwt.ioL>https://jwt.io</a>/）</p><p>定义了一种简洁的、自包含的格式，用于在通信双方以json数据格式安全的传输信息。</p><p>组成：</p><ul><li>第一部分：Header（头），记录令牌类型、签名算法等。例如｛&ldquo;alg&rdquo;：&ldquo;HS256&rdquo;，&ldquo;type&rdquo;：&ldquo;JWT&rdquo;｝</li><li>第二部分：Payload（有效载荷），携带一些自定义信息、默认信息等。例如：｛&ldquo;id&rdquo;：&ldquo;1&rdquo;，“username"：&ldquo;Tom&rdquo;｝</li><li>第三部分：Signature（签名），防止Token被篡改、确保安全性。将header、payload融入，并加入指定秘钥，通过指定签名算法计算而来。</li></ul><p><img loading=lazy src=/images/Day12%e5%90%8e%e7%ab%afWeb%e5%ae%9e%e6%88%98%ef%bc%88%e7%99%bb%e5%bd%95%e8%ae%a4%e8%af%81%ef%bc%89.assets/1734920155793-c7af3af0-34a3-4d74-b2ad-2176ff21ad78.png alt></p><p>= 是base64编码中的补位符号</p><p>签名不是 base64编码，而是基于一定的加密规则加密出来的字符串</p><p>令牌的长度不是固定的</p><h2 id=生成令牌>生成令牌<a hidden class=anchor aria-hidden=true href=#生成令牌>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=w>    </span><span class=c1>// 生成的令牌：&#34;eyJhbGciOiJIUzI1NiJ9.eyJpZCI6NSwidXNlcm5hbWUiOiJhZG1pbiIsImV4cCI6MTczNDkyNDYyNX0.qJbvnksEHOmoE-OvNDuOUVjuCG0y4EDa1Ad_jDfhYs8&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Test</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>testJwtGenerate</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Map</span><span class=o>&lt;</span><span class=n>String</span><span class=p>,</span><span class=w> </span><span class=n>Object</span><span class=o>&gt;</span><span class=w> </span><span class=n>dataMap</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>HashMap</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>dataMap</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=s>&#34;id&#34;</span><span class=p>,</span><span class=n>5</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>dataMap</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=s>&#34;username&#34;</span><span class=p>,</span><span class=s>&#34;admin&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>String</span><span class=w> </span><span class=n>jwt</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Jwts</span><span class=p>.</span><span class=na>builder</span><span class=p>().</span><span class=w>  </span><span class=c1>// 生成一个jwt令牌</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>signWith</span><span class=p>(</span><span class=n>SignatureAlgorithm</span><span class=p>.</span><span class=na>HS256</span><span class=p>,</span><span class=w> </span><span class=s>&#34;enp6enlq&#34;</span><span class=p>).</span><span class=w> </span><span class=c1>// 设置签名算法和密钥</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>addClaims</span><span class=p>(</span><span class=n>dataMap</span><span class=p>).</span><span class=w> </span><span class=c1>// 设置自定义数据</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>setExpiration</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>Date</span><span class=p>(</span><span class=n>System</span><span class=p>.</span><span class=na>currentTimeMillis</span><span class=p>()</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>3600</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>1000</span><span class=p>)).</span><span class=w> </span><span class=c1>// 设置过期时间，先获取现在的时间戳，再添加3600毫秒的1000倍就是一个小时</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>compact</span><span class=p>();</span><span class=w> </span><span class=c1>// 生成jwt令牌</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>jwt</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=解析令牌>解析令牌<a hidden class=anchor aria-hidden=true href=#解析令牌>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=w>    </span><span class=nd>@Test</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>testJwtParse</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>String</span><span class=w> </span><span class=n>token</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;eyJhbGciOiJIUzI1NiJ9.eyJpZCI6NSwidXNlcm5hbWUiOiJhZG1pbiIsImV4cCI6MTczNDkyNDY4Nn0._nJwP9_V7Z6vaTC_nWeubmaF9W58QXHtLdOtrKuGkG0&#34;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Claims</span><span class=w> </span><span class=n>claims</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Jwts</span><span class=p>.</span><span class=na>parser</span><span class=p>().</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>setSigningKey</span><span class=p>(</span><span class=s>&#34;enp6enlq&#34;</span><span class=p>).</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>parseClaimsJws</span><span class=p>(</span><span class=n>token</span><span class=p>).</span><span class=w> </span><span class=c1>// 这里是s不是t 导致了错误的原因</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>getBody</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>claims</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ol><li><code>**parseClaimsJwt**</code><strong>方法</strong>：<ul><li>这个方法适用于解析<strong>未签名</strong>的JWT。它不验证JWT的签名，只是简单地解析JWT字符串并返回一个包含载荷（Payload）的<code>Claims</code>对象。因此，如果你的JWT没有签名，或者你不需要验证签名，可以使用这个方法。</li><li>代码示例：<code>Jwts.parser().parseClaimsJwt(jwt).getBody();</code></li></ul></li><li><code>**parseClaimsJws**</code><strong>方法</strong>：<ul><li>这个方法用于解析<strong>已签名</strong>的JWT。它会验证JWT的结构和签名，确保JWT是有效的。如果签名验证失败，会抛出异常。这个方法返回一个<code>Jws&lt;Claims></code>对象，其中包含了JWT的头部（Header）、载荷（Payload）和签名（Signature）。</li><li>代码示例：<code>Jwts.parser().parseClaimsJws(token).getBody();</code></li></ul></li></ol><p>令牌被篡改或者令牌过期，都会报错</p><p>JWT校验时使用的签名秘钥，必须和生成JWT令牌时使用的秘钥是配套的</p><h2 id=登录成功后-生成令牌>登录成功后-生成令牌<a hidden class=anchor aria-hidden=true href=#登录成功后-生成令牌>#</a></h2><p><strong>分析：令牌是怎么来的？</strong></p><p>是第一次登录成功的时候，从服务器生成一个令牌传回来给客户端的，然后客户端会一直保存着</p><p><img loading=lazy src=/images/Day12%e5%90%8e%e7%ab%afWeb%e5%ae%9e%e6%88%98%ef%bc%88%e7%99%bb%e5%bd%95%e8%ae%a4%e8%af%81%ef%bc%89.assets/1734923912628-17b60bac-03ff-4a4f-bdbd-5f51c47f9e86.png alt></p><p>1、定义JWT令牌操作工具类。（基于AI）</p><p>2、登录完成后，调用工具类生成JWT令牌，并返回。</p><h1 id=过滤器-filter>过滤器-Filter<a hidden class=anchor aria-hidden=true href=#过滤器-filter>#</a></h1><p>概念：Filter过滤器，是Javaweb三大组件（Servlet、Filter、Listener）之一。（现在只有Filter还有人用）</p><p>过滤器可以把对资源的请求<strong>拦截</strong>下来，从而实现一些特殊的功能。</p><p>过滤器一般完成一些<strong>通用的操作</strong>，比如：登录校验、统一编码处理、敏感字符处理等。</p><p><strong>Filter是在servlet下的包</strong></p><h2 id=使用步骤>使用步骤<a hidden class=anchor aria-hidden=true href=#使用步骤>#</a></h2><ol><li>定义Filter：定义一个类，实现 Filter 接口，并实现其所有方法。</li><li>配置Filter：Filter类上加@WebFilter注解，配置拦截路径。引导类上加 @ServletComponentScan 开启Servlet组件支持。</li></ol><p></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Slf4j</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@WebFilter</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>DemoFilter</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>Filter</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>init</span><span class=p>(</span><span class=n>FilterConfig</span><span class=w> </span><span class=n>filterConfig</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>ServletException</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>log</span><span class=p>.</span><span class=na>info</span><span class=p>(</span><span class=s>&#34;init方法执行了...&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>doFilter</span><span class=p>(</span><span class=n>ServletRequest</span><span class=w> </span><span class=n>servletRequest</span><span class=p>,</span><span class=w> </span><span class=n>ServletResponse</span><span class=w> </span><span class=n>servletResponse</span><span class=p>,</span><span class=w> </span><span class=n>FilterChain</span><span class=w> </span><span class=n>filterChain</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>IOException</span><span class=p>,</span><span class=w> </span><span class=n>ServletException</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>log</span><span class=p>.</span><span class=na>info</span><span class=p>(</span><span class=s>&#34;doFilter方法执行了...&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>filterChain</span><span class=p>.</span><span class=na>doFilter</span><span class=p>(</span><span class=n>servletRequest</span><span class=p>,</span><span class=n>servletResponse</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>destroy</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>log</span><span class=p>.</span><span class=na>info</span><span class=p>(</span><span class=s>&#34;destroy方法执行了...&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><strong>filterChain中只包含了一个方法，就是doFilter方法，用于放行</strong></p><p>思考：</p><ul><li>所有的请求，拦截到了之后，都需要校验令牌吗？有一个例外，<strong>登录请求，或者注册请求</strong></li><li>拦截到请求后，什么情况下才可以放行，执行业务操作？<strong>有令牌，且令牌校验通过（合法）</strong>；否则都返回未登录错误结果</li></ul><h2 id=令牌校验filter-流程>令牌校验Filter-流程<a hidden class=anchor aria-hidden=true href=#令牌校验filter-流程>#</a></h2><ol><li>获取请求url。</li><li>判断请求url中是否包含login，如果包含，说明是登录操作，放行。</li><li>获取请求头中的令牌（token）。</li><li>判断令牌是否存在，如果不存在，响应401。</li><li>解析token，如果解析失败，响应401。</li><li>放行。</li></ol><p><img loading=lazy src=/images/Day12%e5%90%8e%e7%ab%afWeb%e5%ae%9e%e6%88%98%ef%bc%88%e7%99%bb%e5%bd%95%e8%ae%a4%e8%af%81%ef%bc%89.assets/1735007094926-0ba5673a-b1c2-49fc-9ea0-21f32057e21c.png alt></p><p>代码实现：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>doFilter</span><span class=p>(</span><span class=n>ServletRequest</span><span class=w> </span><span class=n>servletRequest</span><span class=p>,</span><span class=w> </span><span class=n>ServletResponse</span><span class=w> </span><span class=n>servletResponse</span><span class=p>,</span><span class=w> </span><span class=n>FilterChain</span><span class=w> </span><span class=n>filterChain</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>IOException</span><span class=p>,</span><span class=w> </span><span class=n>ServletException</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 1、获取请求路径</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 1.1 先把Request对象转换为HttpServletRequest对象</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>HttpServletRequest</span><span class=w> </span><span class=n>request</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=n>HttpServletRequest</span><span class=p>)</span><span class=w> </span><span class=n>servletRequest</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>HttpServletResponse</span><span class=w> </span><span class=n>response</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=n>HttpServletResponse</span><span class=p>)</span><span class=w> </span><span class=n>servletResponse</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>String</span><span class=w> </span><span class=n>requestURI</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>request</span><span class=p>.</span><span class=na>getRequestURI</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 2、判断是否包含登录请求</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>requestURI</span><span class=p>.</span><span class=na>contains</span><span class=p>(</span><span class=s>&#34;login&#34;</span><span class=p>)){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>log</span><span class=p>.</span><span class=na>info</span><span class=p>(</span><span class=s>&#34;登录请求，放行&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 放行</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>filterChain</span><span class=p>.</span><span class=na>doFilter</span><span class=p>(</span><span class=n>servletRequest</span><span class=p>,</span><span class=n>servletResponse</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 3、不是登录请求，就判断是否携带token</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>String</span><span class=w> </span><span class=n>token</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>request</span><span class=p>.</span><span class=na>getHeader</span><span class=p>(</span><span class=s>&#34;token&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>token</span><span class=o>==</span><span class=kc>null</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=n>token</span><span class=p>.</span><span class=na>isEmpty</span><span class=p>()){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>log</span><span class=p>.</span><span class=na>info</span><span class=p>(</span><span class=s>&#34;请求头中不存在token，响应401...&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 4、没有携带token，就响应401</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>response</span><span class=p>.</span><span class=na>setStatus</span><span class=p>(</span><span class=n>HttpServletResponse</span><span class=p>.</span><span class=na>SC_UNAUTHORIZED</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 5、携带了token，解析token</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>JwtUtils</span><span class=p>.</span><span class=na>parseJWT</span><span class=p>(</span><span class=n>token</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>Exception</span><span class=w> </span><span class=n>e</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>log</span><span class=p>.</span><span class=na>info</span><span class=p>(</span><span class=s>&#34;令牌未通过校验，响应401&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>response</span><span class=p>.</span><span class=na>setStatus</span><span class=p>(</span><span class=n>HttpServletResponse</span><span class=p>.</span><span class=na>SC_UNAUTHORIZED</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 6、解析成功，放行</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>log</span><span class=p>.</span><span class=na>info</span><span class=p>(</span><span class=s>&#34;令牌通过校验，放行&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>filterChain</span><span class=p>.</span><span class=na>doFilter</span><span class=p>(</span><span class=n>servletRequest</span><span class=p>,</span><span class=n>servletResponse</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>思考：</p><p>记得要加@WebFilter(urlPatterns = "/*") 注解，要不然不会生效，这个注解可以指定拦截的路径，注意一个服务器里的过滤器不要冲突了</p><p>这个代码想要实现需要逻辑比较清晰，前边的需要把对象转换成HttpServletRequest不要忘记了，本质上就是HttpServletRequest</p><p>HttpServletResponse.SC_UNAUTHORIZED 这个的值就是401</p><h2 id=filter执行流程>Filter执行流程<a hidden class=anchor aria-hidden=true href=#filter执行流程>#</a></h2><p><img loading=lazy src=/images/Day12%e5%90%8e%e7%ab%afWeb%e5%ae%9e%e6%88%98%ef%bc%88%e7%99%bb%e5%bd%95%e8%ae%a4%e8%af%81%ef%bc%89.assets/1735009912154-65d26820-38a5-49f9-a853-fa6124b4541e.png alt></p><p>问题1：放行后访问对应资源，资源访问完成后，<strong>还会回到Filter中吗</strong>？<strong>会</strong></p><p>问题2：如果回到Filter中，是重新执行还是执行放行后的逻辑呢？<strong>执行放行后逻辑</strong></p><hr><h2 id=filter拦截路径>Filter拦截路径<a hidden class=anchor aria-hidden=true href=#filter拦截路径>#</a></h2><p>根据@WebFilter里边的urlPatterns的值不同，可以拦截不同的路径</p><table><thead><tr><th style=text-align:center>拦截路径</th><th style=text-align:center>urlPatterns值</th><th style=text-align:center>含义</th></tr></thead><tbody><tr><td style=text-align:center>拦截具体路径</td><td style=text-align:center>/login</td><td style=text-align:center>只有访问 /login 路径时，才会被拦截</td></tr><tr><td style=text-align:center>目录拦截</td><td style=text-align:center>/emps/*</td><td style=text-align:center>访问/emps下的所有资源，都会被拦截</td></tr><tr><td style=text-align:center>拦截所有</td><td style=text-align:center>/*</td><td style=text-align:center>访问所有资源，都会被拦截</td></tr></tbody></table><h2 id=filter过滤器链>Filter过滤器链<a hidden class=anchor aria-hidden=true href=#filter过滤器链>#</a></h2><p>介绍：一个web应用中，可以<strong>配置多个过滤器</strong>，这多个过滤器就<strong>形成了一个过滤器链</strong>。</p><p>顺序：注解配置的Filter，<strong>优先级是按照过滤器类名（字符串）的自然排序</strong>。</p><p><img loading=lazy src=/images/Day12%e5%90%8e%e7%ab%afWeb%e5%ae%9e%e6%88%98%ef%bc%88%e7%99%bb%e5%bd%95%e8%ae%a4%e8%af%81%ef%bc%89.assets/1735010114180-b8cca0a9-334e-48eb-9299-98a1ac826269.png alt></p><p>执行序号已经在图上的编号中标出来了</p><h1 id=拦截器-interceptor>拦截器-Interceptor<a hidden class=anchor aria-hidden=true href=#拦截器-interceptor>#</a></h1><p>概念：是一种动态拦截方法调用的机制，类似于过滤器。Spring框架中提供的，主要用来动态拦截控制器方法的执行。</p><p>作用：拦截请求，在指定的方法调用前后，根据业务需要执行预先设定的代码。</p><p><img loading=lazy src=/images/Day12%e5%90%8e%e7%ab%afWeb%e5%ae%9e%e6%88%98%ef%bc%88%e7%99%bb%e5%bd%95%e8%ae%a4%e8%af%81%ef%bc%89.assets/1735015078010-f90e5432-7869-45d0-9993-543d08fa5526.png alt></p><h2 id=interceptor快速入门>Interceptor快速入门<a hidden class=anchor aria-hidden=true href=#interceptor快速入门>#</a></h2><p>拦截器是Spring提供的，需要加上@Component交给IOC容器管理</p><p>拦截器实现的步骤：</p><p><strong>1、定义拦截器</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Component</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@Slf4j</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>DemoInterceptor</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>HandlerInterceptor</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 目标方法执行前，返回TRUE放行请求，返回FALSE拦截请求</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=nf>preHandle</span><span class=p>(</span><span class=n>HttpServletRequest</span><span class=w> </span><span class=n>request</span><span class=p>,</span><span class=w> </span><span class=n>HttpServletResponse</span><span class=w> </span><span class=n>response</span><span class=p>,</span><span class=w> </span><span class=n>Object</span><span class=w> </span><span class=n>handler</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>Exception</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>log</span><span class=p>.</span><span class=na>info</span><span class=p>(</span><span class=s>&#34;preHandle ....&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 目标方法执行后</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>postHandle</span><span class=p>(</span><span class=n>HttpServletRequest</span><span class=w> </span><span class=n>request</span><span class=p>,</span><span class=w> </span><span class=n>HttpServletResponse</span><span class=w> </span><span class=n>response</span><span class=p>,</span><span class=w> </span><span class=n>Object</span><span class=w> </span><span class=n>handler</span><span class=p>,</span><span class=w> </span><span class=n>ModelAndView</span><span class=w> </span><span class=n>modelAndView</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>Exception</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>log</span><span class=p>.</span><span class=na>info</span><span class=p>(</span><span class=s>&#34;postHandle ....&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 视图渲染完毕后</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>afterCompletion</span><span class=p>(</span><span class=n>HttpServletRequest</span><span class=w> </span><span class=n>request</span><span class=p>,</span><span class=w> </span><span class=n>HttpServletResponse</span><span class=w> </span><span class=n>response</span><span class=p>,</span><span class=w> </span><span class=n>Object</span><span class=w> </span><span class=n>handler</span><span class=p>,</span><span class=w> </span><span class=n>Exception</span><span class=w> </span><span class=n>ex</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>Exception</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>log</span><span class=p>.</span><span class=na>info</span><span class=p>(</span><span class=s>&#34;afterCompletion ....&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>注意有加上Component注解，加入到ioc容器中</p><p><strong>2、注册拦截器，定义配置类实现WebMv</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Configuration</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>WebConfig</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>WebMvcConfigurer</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Autowired</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>DemoInterceptor</span><span class=w> </span><span class=n>demoInterceptor</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 注册自定义拦截器对象</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>addInterceptors</span><span class=p>(</span><span class=n>InterceptorRegistry</span><span class=w> </span><span class=n>registry</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 设置拦截器拦截的路径</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>registry</span><span class=p>.</span><span class=na>addInterceptor</span><span class=p>(</span><span class=n>demoInterceptor</span><span class=p>).</span><span class=na>addPathPatterns</span><span class=p>(</span><span class=s>&#34;/**&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>在拦截器中拦截所有用的是/**</p><h2 id=令牌校验-拦截器>令牌校验-拦截器<a hidden class=anchor aria-hidden=true href=#令牌校验-拦截器>#</a></h2><p>里边的逻辑和Filter一样，只需要控制返回值即可</p><p>拦截器的放行只需要通过return的值来控制</p><h2 id=拦截器-拦截路径>拦截器-拦截路径<a hidden class=anchor aria-hidden=true href=#拦截器-拦截路径>#</a></h2><p>可以在配置中配置可以放行的路径，这样就不需要判断</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>addInterceptors</span><span class=p>(</span><span class=n>InterceptorRegistry</span><span class=w> </span><span class=n>registry</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 设置拦截器拦截的路径</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>registry</span><span class=p>.</span><span class=na>addInterceptor</span><span class=p>(</span><span class=n>tokenInterceptor</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>.</span><span class=na>addPathPatterns</span><span class=p>(</span><span class=s>&#34;/**&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>.</span><span class=na>excludePathPatterns</span><span class=p>(</span><span class=s>&#34;/login&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><table><thead><tr><th style=text-align:center>拦截路径</th><th style=text-align:center>含义</th><th style=text-align:center>举例</th></tr></thead><tbody><tr><td style=text-align:center>/*</td><td style=text-align:center>一级路径</td><td style=text-align:center>能匹配/depts，/emps，/login，不能匹配 /depts/1</td></tr><tr><td style=text-align:center>/**</td><td style=text-align:center>任意级路径</td><td style=text-align:center>能匹配/depts，/depts/1，/depts/1/2</td></tr><tr><td style=text-align:center>/depts/*</td><td style=text-align:center>/depts下的一级路径</td><td style=text-align:center>能匹配/depts/1，不能匹配/depts/1/2，/depts</td></tr><tr><td style=text-align:center>/depts/**</td><td style=text-align:center>/depts下的任意级路径</td><td style=text-align:center>能匹配/depts，/depts/1，/depts/1/2，不能匹配/emps/1</td></tr></tbody></table><h2 id=拦截器-执行流程>拦截器-执行流程<a hidden class=anchor aria-hidden=true href=#拦截器-执行流程>#</a></h2><p><img loading=lazy src=/images/Day12%e5%90%8e%e7%ab%afWeb%e5%ae%9e%e6%88%98%ef%bc%88%e7%99%bb%e5%bd%95%e8%ae%a4%e8%af%81%ef%bc%89.assets/1735089950079-13578fdb-47ca-40fb-94ae-08d949590670.png alt></p><p>拦截器是Spring提供的技术，他只会拦截对于Spring的请求，而过滤器是Servlet规范中提供的技术，所以他的拦截权限更高，可以拦截所有资源</p><p>Filter 与 Interceptor 区别：</p><ol><li>接口规范不同：过滤器需要实现Filter接口，而拦截器需要实现HandlerInterceptor接口。</li><li>拦截范围不同：过滤器Filter会拦截所有的资源，而Interceptor只会拦截Spring环境中的资源。</li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://wqnm1gb.github.io/tags/java-web/>Java Web</a></li></ul><nav class=paginav><a class=prev href=https://wqnm1gb.github.io/posts/day13spring-aop/><span class=title>« 上一页</span><br><span>Day13 Spring-AOP</span>
</a><a class=next href=https://wqnm1gb.github.io/posts/day11%E5%90%8E%E7%AB%AFweb%E5%AE%9E%E6%88%98%E7%8F%AD%E7%BA%A7%E5%AD%A6%E5%91%98/><span class=title>下一页 »</span><br><span>Day11 后端Web实战（班级学员）</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://wqnm1gb.github.io/>三狗子的博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>