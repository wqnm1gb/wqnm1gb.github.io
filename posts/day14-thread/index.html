<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Day14 Thread | 三狗子的博客</title>
<meta name=keywords content="java基础"><meta name=description content="多线程
什么是线程？
线程（Thread）是一个程序内部的一条执行流程
程序中如果只有一条执行流程，那这个程序就是单线程的程序
多线程是指从软硬件上实现的多条执行流程的技术（多条线程由CPU负责调度执行）"><meta name=author content="冷漠三狗子丶"><link rel=canonical href=https://wqnm1gb.github.io/posts/day14-thread/><link crossorigin=anonymous href=/assets/css/stylesheet.3d688279d829dc24da48acd11f9e33ebea2f39c035e899e1bf4297d8b7aa89b9.css integrity="sha256-PWiCedgp3CTaSKzRH54z6+ovOcA16Jnhv0KX2Leqibk=" rel="preload stylesheet" as=style><link rel=icon href=https://wqnm1gb.github.io/images/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://wqnm1gb.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wqnm1gb.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wqnm1gb.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://wqnm1gb.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://wqnm1gb.github.io/posts/day14-thread/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel=stylesheet><script type=text/javascript async src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["[[","]]"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=" has-jax"})</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style><meta property="og:title" content="Day14 Thread"><meta property="og:description" content="多线程
什么是线程？
线程（Thread）是一个程序内部的一条执行流程
程序中如果只有一条执行流程，那这个程序就是单线程的程序
多线程是指从软硬件上实现的多条执行流程的技术（多条线程由CPU负责调度执行）"><meta property="og:type" content="article"><meta property="og:url" content="https://wqnm1gb.github.io/posts/day14-thread/"><meta property="og:image" content="https://wqnm1gb.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-02-08T10:46:30+08:00"><meta property="article:modified_time" content="2025-02-08T10:46:30+08:00"><meta property="og:site_name" content="三狗子的博客"><meta property="fb:admins" content="your-facebook-admin-id"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wqnm1gb.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Day14 Thread","item":"https://wqnm1gb.github.io/posts/day14-thread/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Day14 Thread","name":"Day14 Thread","description":"多线程 什么是线程？\n线程（Thread）是一个程序内部的一条执行流程\n程序中如果只有一条执行流程，那这个程序就是单线程的程序\n多线程是指从软硬件上实现的多条执行流程的技术（多条线程由CPU负责调度执行）\n","keywords":["java基础"],"articleBody":"多线程 什么是线程？\n线程（Thread）是一个程序内部的一条执行流程\n程序中如果只有一条执行流程，那这个程序就是单线程的程序\n多线程是指从软硬件上实现的多条执行流程的技术（多条线程由CPU负责调度执行）\n创建线程的方式一：继承Thread类 ① 定义一个子类MyJhread继承线程类java.lang.Thread，重写run()方法\n② 创建MyThread类的对象\n③ 调用线程对象的start()方法启动线程（启动后还是执行run方法的）\n方式一优缺点：\n优点：编码简单\n缺点：线程类已经继承Thread，无法继承其他类，不利于功能的扩展。\n创建线程的注意事项 启动线程必须是调用start方法，不是调用run方法。\n•直接调用run方法会当成普通方法执行，此时相当于还是单线程执行。\n•只有调用start方法才是启动一个新的线程执行。\n不要把主线程任务放在启动子线程之前。\n• 这样主线程一直是先跑完的，相当于是一个单线程的效果了。\n创建线程的方式二：实现Runnable接口 ① 定义一个线程任务类MyRunnable实现Runnable接口，重写run()方法\n② 创建MyRunnable任务对象\n③ 把MyRunnable任务对象交给Thread处理。\nThread****类提供的构造器 说明 public Thread(Runnable target) 封装Runnable对象成为线程对象 ④ 调用线程对象的start()方法启动线程\n方式二的优缺点\n优点：任务类只是实现接口，可以继续继承其他类、实现其他接口，扩展性强。\n缺点：需要多一个Runnable对象。\n匿名内部类的写法\n① 可以创建Runnable的匿名内部类对象。\n② 再交给Thread线程对象。\n③ 再调用线程对象的start()启动线程。\nnew Thread(()-\u003e{for (int i = 0; i \u003c 5; i++) { System.out.println(\"子线程2输出：\"+ i); }}).start(); 创建线程的方式三：实现Callabel接口 ①创建任务对象\n定义一个类实现Callable接口，重写call方法，封装要做的事情，和要返回的数据。把Callable类型的对象封装成FutureJask（线程任务对象）\n②把线程任务对象交给Thread对象\n③调用Thread对象的start方法启动线程\n④线程执行完毕后、通过FutureJask对象的的get方法去获取线程任务执行的结果\nFutureTask的API\nFutureTask****提供的构造器 说明 public FutureTask\u003c\u003e(Callable call) 把Callable对象封装成FutureTask对象。 FutureTask****提供的方法 说明 public V get() throws Exception 获取线程执行call方法返回的结果。 线程创建方式三的优缺点\n优点：线程任务类只是实现接口，可以继续继承类和实现接口，扩展性强；可以在线程执行完毕后去获取线程执行的结果。\n缺点：编码复杂一点\n三种线程方式的对比 方式 优点 缺点 继承Thread类 编程比较简单，可以直接使用Thread类中的方法 扩展性较差，不能再继承其他的类，不能返回线程执行的结果 实现Runnable接口 扩展性强，实现该接口的同时还可以继承其他的类。 编程相对复杂，不能返回线程执行的结果 实现Callable接口 扩展性强，实现该接口的同时还可以继承其他的类。可以得到线程执行的结果 编程相对复杂 Thread的常用方法 Thread****提供的常用方法 说明 public void run() 线程的任务方法 public void start() 启动线程 public String getName****() 获取当前线程的名称，线程名称默认是Thread-索引 public void setName****(String name) 为线程设置名称，设置名字要在启动线程之前 public static Thread currentThread****() 获取当前执行的线程对象 public static void sleep(long time) 让当前执行的线程休眠多少毫秒后，再继续执行 public final void join()… 让调用当前这个方法的线程先执行完，相当于插队 Thread****提供的常见构造器 说明 public Thread(String name) 可以为当前线程指定名称 public Thread(Runnable target) 封装Runnable对象成为线程对象 public Thread(Runnable target,String name) 封装Runnable对象成为线程对象，并指定线程名称 主线程的名字是main\n创建的线程名字是 Thread-编号\n解决线程安全问题的方法 方法1：同步代码块 作用：把访问共享资源的核心代码给上锁，以此保证线程安全。\nsynchronized（同步锁）{ 访问共享资源的核心代码 } 原理：每次只允许一个线程加锁后进入，执行完毕后自动解锁，其他线程才可以进来执行\n同步锁的注意事项\n对于当前同时执行的线程来说，同步锁必须是同一把（同一个对象），否则会出bug。\n锁对象随便选择一个唯一的对象好不好呢？\n不好，会影响其他无关线程的执行。\n锁对象的使用规范\n建议使用共享资源作为锁对象，对于实例方法建议使用this作为锁对象。\n对于静态方法建议使用字节码（类名.class）对象作为锁对象。\n方法2：同步方法 作用：把访问共享资源的核心方法给上锁，以此保证线程安全。\n修饰符 synchronized 返回值类型 方法名称（形参列表）{ 操作共享资源的代码 } 原理：每次只能一个线程进入，执行完毕以后自动解锁，其他线程才可以进来执行\n同步方法底层原理\n同步方法其实底层也是有隐式对象的，只是锁的范围是整个方法代码。\n如果方法是实例方法：同步方法默认用this作为的锁对象。\n如果方法是静态方法：同步方法默认用类名.class作为的锁对象。\n把run方法用synchronized修饰不一定有效果\n同步代码块好还是同步方法好？\n范围上：同步代码块锁的范围更小，同步方法锁的范围更大\n可读性：同步方法更好\n方式3：Lock锁 Lock锁是JDK5开始提供的一个新的锁定操作，通过它可以创建出锁对象进行加锁和解锁，更灵活、更方便、更强大。\nLock是接口，不能直接实例化，可以采用它的实现类Reentrantlgck来构建Lock锁对象。\n构造器 说明 public ReentrantLock() 获得Lock锁的实现类对象 方法名称 说明 void lock() 获得锁 void unlock() 释放锁 锁对象建议加上什么修饰？\n建议使用final修饰，防止被别人篡改\n释放锁的操作建议放到哪里？\n建议将释放锁的操作放到finally代码块中，确保锁用完了一定会被释放\n线程池 线程池就是一个可以复用线程的技术。\n不使用线程池的问题\n用户每发起一个请求，后台就需要创建一个新线程来处理，下次新任务来了肯定又要创建新线程处理的，创建新线程的开销是很大的，并且请求过多时，肯定会产生大量的线程出来，这样会严重影响系统的性能。\n任务队列中只能是Runnable和Callable任务\n创建线程池 JDK 5.0起提供了代表线程池的接口：ExecutorService。\n方式一：使用ExecutorService的实现类ThreadPoolExecutor自创建一个线程池对象\nThreadPoolExecutor类提供的构造器 作用 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue«/font\u003eRunnable\u003e workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) 使用指定的初始化参数创建一个新的线程池对象 参数一：corePoolSize：指定线程池的核心线程的数量。 正式工：3\n参数二：maximumPoolSize：指定线程池的最大线程数量。最大员工数：5 临时工：2\n参数三：keepAliveTime：指定临时线程的存活时间。 临时工空闲多久被开除\n参数四：unit：指定临时线程存活的时间单位（秒、分、时、天）\n参数五：workQueue：指定线程池的任务队列。 客人排队的地方\n参数六：threadFactory：指定线程池的线程工厂。 负责招聘员工的（hr）\n参数七：handler：指定线程池的任务拒绝策略（线程都在忙，任务队列也满了的时候，新任务来了该怎么处理） 忙不过来咋办？\n方式二：使用Executors（线程池的工具类）调用方法返回不同特点的线程池对象\n方法名称 说明 public static ExecutorService newFixedThreadPool(int nThreads) 创建固定线程数量的线程池，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程替代它。 public static ExecutorService newSingleThreadExecutor() 创建只有一个线程的线程池对象，如果该线程出现异常而结束，那么线程池会补充一个新线程。 public static ExecutorService newCachedThreadPool() 线程数量随着任务增加而增加，如果线程任务执行完毕且空闲了60s则会被回收掉。 public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) 创建一个线程池，可以实现在给定的延迟后运行任务，或者定期执行任务。 大型并发系统环境中使用Executors如果不注意可能会出现系统风险\nExecutors工具类底层是基于什么方式实现的线程池对象？\n线程池ExecutorSeryi.ce的实现类：ThreadPooJExecutor\nExecutors是否适合做大型互联网场景的线程池方案？\n不合适。\n建议使用ThreadPoolExecutor来指定线程池参数，这样可以明确线程池的运行规则，规避资源耗尽的风险。\n处理Runnable任务 方法名称 说明 void execute(Runnable command) 执行 Runnable 任务 Future submit(Callable task) 执行 Callable 任务，返回未来任务对象，用于获取线程返回的结果 void shutdown() 等全部任务执行完毕后，再关闭线程池！ List«/font\u003eRunnable\u003e shutdownNow() 立刻关闭线程池，停止正在执行的任务，并返回队列中未执行的任务 线程池的注意事项 什么时候开始创建临时线程？ 新任务提交时发现核心线程都在忙，任务队列也满了，并且还可以创建临时线程，此时才会创建临时线程。\n什么时候会拒绝新任务？ 核心线程和临时线程都在忙，任务队列也满了，新的任务过来的时候才会开始拒绝任务。\n任务拒绝策略\n策略 说明 ThreadPoolExecutor.AbortPolicy() 丢弃任务并抛出RejectedExecutionException异常。是默认的策略 ThreadPoolExecutor. DiscardPolicy() 丢弃任务，但是不抛出异常，这是不推荐的做法 ThreadPoolExecutor. DiscardOldestPolicy() 抛弃队列中等待最久的任务 然后把当前任务加入队列中 ThreadPoolExecutor. CallerRunsPolicy() 由主线程负责调用任务的run()方法从而绕过线程池直接执行 处理Callable任务 线程池如何处理Callable任务，并得到任务执行完后返回的结果？\n使用ExecutorService的方法\nFuture submit（Callable command） 多态写法，返回一个RunnableFuture对象，可以调用里边get()方法\n进程 正在运行的程序（软件）就是一个独立的进程\n线程是属于进程的，一个进程中可以同时运行很多个线程\n进程中的多个线程其实是并发和并行执行的\n并发的含义 进程中的线程是由CPU负责调度执行的，但CPU能同时处理线程的数量有限，为了保证全部线程都能往前执行，CPU会轮询为系统的每个线程服务，由于CPU切换的速度很快，给我们的感觉这些线程在同时执行，这就是并发。\n并行的理解 在同一个时刻上，同时有多个线程在被CPU调度执行。\n","wordCount":"4051","inLanguage":"zh","image":"https://wqnm1gb.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-02-08T10:46:30+08:00","dateModified":"2025-02-08T10:46:30+08:00","author":{"@type":"Person","name":"冷漠三狗子丶"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wqnm1gb.github.io/posts/day14-thread/"},"publisher":{"@type":"Organization","name":"三狗子的博客","logo":{"@type":"ImageObject","url":"https://wqnm1gb.github.io/images/favicon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wqnm1gb.github.io/ accesskey=h title="主页 (Alt + H)"><img src=https://wqnm1gb.github.io/apple-touch-icon.png alt aria-label=logo height=35>主页</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wqnm1gb.github.io/ title=三狗子的博客><span>首页</span></a></li><li><a href=https://wqnm1gb.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://wqnm1gb.github.io/categories/ title=Categories><span>分类</span></a></li><li><a href=https://wqnm1gb.github.io/tags/ title=Tags><span>标签</span></a></li><li><a href=https://wqnm1gb.github.io/search/ title=搜索><span>搜索</span></a></li><li><a href=https://wqnm1gb.github.io/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://wqnm1gb.github.io/>主页</a>&nbsp;»&nbsp;<a href=https://wqnm1gb.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Day14 Thread</h1><div class=post-meta><span title='2025-02-08 10:46:30.948269 +0800 +0800'>二月 8, 2025</span>&nbsp;·&nbsp;9 分钟&nbsp;·&nbsp;4051 字&nbsp;·&nbsp;冷漠三狗子丶</div></header><div class=post-content><h2 id=多线程>多线程<a hidden class=anchor aria-hidden=true href=#多线程>#</a></h2><p>什么是线程？</p><p>线程（Thread）是一个程序内部的一条执行流程</p><p>程序中如果只有一条执行流程，那这个程序就是单线程的程序</p><p>多线程是指从软硬件上实现的多条执行流程的技术（多条线程由CPU负责调度执行）</p><h3 id=创建线程的方式一继承thread类>创建线程的方式一：继承Thread类<a hidden class=anchor aria-hidden=true href=#创建线程的方式一继承thread类>#</a></h3><p>① 定义一个子类MyJhread继承线程类java.lang.Thread，重写run()方法</p><p>② 创建MyThread类的对象</p><p>③ 调用线程对象的start()方法启动线程（启动后还是执行run方法的）</p><p>方式一优缺点：</p><p>优点：编码简单</p><p>缺点：线程类已经继承Thread，无法继承其他类，不利于功能的扩展。</p><h4 id=创建线程的注意事项>创建线程的注意事项<a hidden class=anchor aria-hidden=true href=#创建线程的注意事项>#</a></h4><p>启动线程必须是调用start方法，不是调用run方法。</p><p>•直接调用run方法会当成普通方法执行，此时相当于还是单线程执行。</p><p>•只有调用start方法才是启动一个新的线程执行。</p><p>不要把主线程任务放在启动子线程之前。</p><p>• 这样主线程一直是先跑完的，相当于是一个单线程的效果了。</p><h3 id=创建线程的方式二实现runnable接口>创建线程的方式二：实现Runnable接口<a hidden class=anchor aria-hidden=true href=#创建线程的方式二实现runnable接口>#</a></h3><p>① 定义一个线程任务类MyRunnable实现Runnable接口，重写run()方法</p><p>② 创建MyRunnable任务对象</p><p>③ 把MyRunnable任务对象交给Thread处理。</p><table><thead><tr><th><strong>Thread****类提供的构造器</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>public Thread(Runnable target)</td><td>封装Runnable对象成为线程对象</td></tr></tbody></table><p>④ 调用线程对象的start()方法启动线程</p><p><strong>方式二的优缺点</strong></p><p>优点：任务类只是实现接口，可以继续继承其他类、实现其他接口，扩展性强。</p><p>缺点：需要多一个Runnable对象。</p><p>匿名内部类的写法</p><p>① 可以创建Runnable的匿名内部类对象。</p><p>② 再交给Thread线程对象。</p><p>③ 再调用线程对象的start()启动线程。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Thread</span><span class=p>(()</span><span class=o>-&gt;</span><span class=p>{</span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>5</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;子线程2输出：&#34;</span><span class=o>+</span><span class=w> </span><span class=n>i</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}}).</span><span class=na>start</span><span class=p>();</span><span class=w>
</span></span></span></code></pre></div><h3 id=创建线程的方式三实现callabel接口>创建线程的方式三：实现Callabel接口<a hidden class=anchor aria-hidden=true href=#创建线程的方式三实现callabel接口>#</a></h3><p>①创建任务对象</p><p>定义一个类实现Callable接口，重写call方法，封装要做的事情，和要返回的数据。把Callable类型的对象封装成FutureJask（线程任务对象）</p><p>②把线程任务对象交给Thread对象</p><p>③调用Thread对象的start方法启动线程</p><p>④线程执行完毕后、通过FutureJask对象的的get方法去获取线程任务执行的结果</p><p>FutureTask的API</p><table><thead><tr><th><strong>FutureTask****提供的构造器</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>public FutureTask&lt;>(Callable call)</td><td>把Callable对象封装成FutureTask对象。</td></tr></tbody></table><table><thead><tr><th><strong>FutureTask****提供的方法</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>public V get() throws Exception</td><td>获取线程执行call方法返回的结果。</td></tr></tbody></table><p>线程创建方式三的优缺点</p><p>优点：线程任务类只是实现接口，可以继续继承类和实现接口，扩展性强；可以在线程执行完毕后去获取线程执行的结果。</p><p>缺点：编码复杂一点</p><h3 id=三种线程方式的对比>三种线程方式的对比<a hidden class=anchor aria-hidden=true href=#三种线程方式的对比>#</a></h3><table><thead><tr><th>方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>继承Thread类</td><td>编程比较简单，可以直接使用Thread类中的方法</td><td>扩展性较差，不能再继承其他的类，不能返回线程执行的结果</td></tr><tr><td>实现Runnable接口</td><td>扩展性强，实现该接口的同时还可以继承其他的类。</td><td>编程相对复杂，不能返回线程执行的结果</td></tr><tr><td>实现Callable接口</td><td>扩展性强，实现该接口的同时还可以继承其他的类。可以得到线程执行的结果</td><td>编程相对复杂</td></tr></tbody></table><h3 id=thread的常用方法>Thread的常用方法<a hidden class=anchor aria-hidden=true href=#thread的常用方法>#</a></h3><table><thead><tr><th><strong>Thread****提供的常用方法</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>public void run()</td><td>线程的任务方法</td></tr><tr><td>public void start()</td><td>启动线程</td></tr><tr><td>public String <strong>getName****()</strong></td><td>获取当前线程的名称，线程名称默认是Thread-索引</td></tr><tr><td>public void <strong>setName****(String name)</strong></td><td>为线程设置名称，设置名字要在启动线程之前</td></tr><tr><td>public <strong>static</strong> Thread <strong>currentThread****()</strong></td><td>获取当前执行的线程对象</td></tr><tr><td>public <strong>static</strong> void <strong>sleep(long time)</strong></td><td>让当前执行的线程休眠多少毫秒后，再继续执行</td></tr><tr><td>public final void join()&mldr;</td><td>让调用当前这个方法的线程先执行完，相当于插队</td></tr></tbody></table><table><thead><tr><th><strong>Thread****提供的常见构造器</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>public Thread(String name)</td><td>可以为当前线程指定名称</td></tr><tr><td>public Thread(Runnable target)</td><td>封装Runnable对象成为线程对象</td></tr><tr><td>public Thread(Runnable target,String name)</td><td>封装Runnable对象成为线程对象，并指定线程名称</td></tr></tbody></table><p>主线程的名字是main</p><p>创建的线程名字是 Thread-编号</p><h2 id=解决线程安全问题的方法>解决线程安全问题的方法<a hidden class=anchor aria-hidden=true href=#解决线程安全问题的方法>#</a></h2><h3 id=方法1同步代码块>方法1：同步代码块<a hidden class=anchor aria-hidden=true href=#方法1同步代码块>#</a></h3><p>作用：把访问共享资源的核心代码给上锁，以此保证线程安全。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>synchronized</span><span class=err>（</span><span class=n>同步锁</span><span class=err>）</span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>访问共享资源的核心代码</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>原理：每次只允许一个线程加锁后进入，执行完毕后自动解锁，其他线程才可以进来执行</p><p><strong>同步锁的注意事项</strong></p><p>对于当前同时执行的线程来说，同步锁必须是同一把（同一个对象），否则会出bug。</p><p><strong>锁对象随便选择一个唯一的对象好不好呢？</strong></p><p>不好，会影响其他无关线程的执行。</p><p><strong>锁对象的使用规范</strong></p><p>建议使用共享资源作为锁对象，对于实例方法建议使用this作为锁对象。</p><p>对于静态方法建议使用字节码（类名.class）对象作为锁对象。</p><h3 id=方法2同步方法>方法2：同步方法<a hidden class=anchor aria-hidden=true href=#方法2同步方法>#</a></h3><p>作用：把访问共享资源的核心方法给上锁，以此保证线程安全。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>修饰符</span><span class=w> </span><span class=kd>synchronized</span><span class=w> </span><span class=n>返回值类型</span><span class=w> </span><span class=n>方法名称</span><span class=err>（</span><span class=n>形参列表</span><span class=err>）</span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>操作共享资源的代码</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>原理：每次只能一个线程进入，执行完毕以后自动解锁，其他线程才可以进来执行</p><p><strong>同步方法底层原理</strong></p><p>同步方法其实底层也是有隐式对象的，只是锁的范围是整个方法代码。</p><p>如果方法是实例方法：同步方法默认用this作为的锁对象。</p><p>如果方法是静态方法：同步方法默认用类名.class作为的锁对象。</p><p><strong>把run方法用synchronized修饰不一定有效果</strong></p><p><strong>同步代码块好还是同步方法好？</strong></p><p>范围上：同步代码块锁的范围更小，同步方法锁的范围更大</p><p>可读性：同步方法更好</p><h3 id=方式3lock锁>方式3：Lock锁<a hidden class=anchor aria-hidden=true href=#方式3lock锁>#</a></h3><p>Lock锁是JDK5开始提供的一个新的锁定操作，通过它可以创建出锁对象进行加锁和解锁，更灵活、更方便、更强大。</p><p>Lock是接口，不能直接实例化，可以采用它的实现类Reentrantlgck来构建Lock锁对象。</p><table><thead><tr><th><strong>构造器</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>public ReentrantLock()</td><td>获得Lock锁的实现类对象</td></tr></tbody></table><table><thead><tr><th><strong>方法名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>void lock()</td><td>获得锁</td></tr><tr><td>void unlock()</td><td>释放锁</td></tr></tbody></table><p><strong>锁对象建议加上什么修饰？</strong></p><p>建议使用final修饰，防止被别人篡改</p><p><strong>释放锁的操作建议放到哪里？</strong></p><p>建议将释放锁的操作放到finally代码块中，确保锁用完了一定会被释放</p><h2 id=线程池>线程池<a hidden class=anchor aria-hidden=true href=#线程池>#</a></h2><p>线程池就是一个可以复用线程的技术。</p><p><strong>不使用线程池的问题</strong></p><p>用户每发起一个请求，后台就需要创建一个新线程来处理，下次新任务来了肯定又要创建新线程处理的，创建新线程的开销是很大的，并且请求过多时，肯定会产生大量的线程出来，这样会严重影响系统的性能。</p><p><img loading=lazy src=/images/Day14%20Thread.assets/1730255847137-dba40729-8486-4cef-b2fb-66172512f513.png alt></p><p>任务队列中只能是Runnable和Callable任务</p><h3 id=创建线程池>创建线程池<a hidden class=anchor aria-hidden=true href=#创建线程池>#</a></h3><p>JDK 5.0起提供了代表线程池的接口：ExecutorService。</p><p><strong>方式一：使用ExecutorService的实现类ThreadPoolExecutor自创建一个线程池对象</strong></p><p><img loading=lazy src=/images/Day14%20Thread.assets/1730255925564-cb4e0e20-3331-4141-a906-1c24f88c2055.png alt></p><table><thead><tr><th>ThreadPoolExecutor类提供的构造器</th><th>作用</th></tr></thead><tbody><tr><td>public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&#171;/font>Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</td><td>使用指定的初始化参数创建一个新的线程池对象</td></tr></tbody></table><p>参数一：corePoolSize：指定线程池的核心线程的数量。 <strong>正式工：3</strong></p><p>参数二：maximumPoolSize：指定线程池的最大线程数量。<strong>最大员工数：5 临时工：2</strong></p><p>参数三：keepAliveTime：指定临时线程的存活时间。 <strong>临时工空闲多久被开除</strong></p><p>参数四：unit：指定临时线程存活的时间单位（秒、分、时、天）</p><p>参数五：workQueue：指定线程池的任务队列。 <strong>客人排队的地方</strong></p><p>参数六：threadFactory：指定线程池的线程工厂。 <strong>负责招聘员工的（hr）</strong></p><p>参数七：handler：指定线程池的任务拒绝策略（线程都在忙，任务队列也满了的时候，新任务来了该怎么处理） <strong>忙不过来咋办？</strong></p><hr><hr><hr><p><strong>方式二：使用Executors（线程池的工具类）调用方法返回不同特点的线程池对象</strong></p><table><thead><tr><th><strong>方法名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>public static ExecutorService newFixedThreadPool(int nThreads)</td><td>创建固定线程数量的线程池，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程替代它。</td></tr><tr><td>public static ExecutorService newSingleThreadExecutor()</td><td>创建只有一个线程的线程池对象，如果该线程出现异常而结束，那么线程池会补充一个新线程。</td></tr><tr><td>public static ExecutorService newCachedThreadPool()</td><td>线程数量随着任务增加而增加，如果线程任务执行完毕且空闲了60s则会被回收掉。</td></tr><tr><td>public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)</td><td>创建一个线程池，可以实现在给定的延迟后运行任务，或者定期执行任务。</td></tr></tbody></table><p><strong>大型并发系统环境中使用Executors如果不注意可能会出现系统风险</strong></p><p><img loading=lazy src=/images/Day14%20Thread.assets/1730258858856-d98ea956-3716-43ed-8fab-ce7fb179427d.png alt></p><p><strong>Executors工具类底层是基于什么方式实现的线程池对象？</strong></p><p>线程池ExecutorSeryi.ce的实现类：ThreadPooJExecutor</p><p><strong>Executors是否适合做大型互联网场景的线程池方案？</strong></p><p>不合适。</p><p>建议使用ThreadPoolExecutor来指定线程池参数，这样可以明确线程池的运行规则，规避资源耗尽的风险。</p><h3 id=处理runnable任务>处理Runnable任务<a hidden class=anchor aria-hidden=true href=#处理runnable任务>#</a></h3><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>void execute(Runnable command)</td><td>执行 Runnable 任务</td></tr><tr><td>Future submit(Callable task)</td><td>执行 Callable 任务，返回未来任务对象，用于获取线程返回的结果</td></tr><tr><td>void shutdown()</td><td>等全部任务执行完毕后，再关闭线程池！</td></tr><tr><td>List&#171;/font>Runnable> shutdownNow()</td><td>立刻关闭线程池，停止正在执行的任务，并返回队列中未执行的任务</td></tr></tbody></table><h3 id=线程池的注意事项>线程池的注意事项<a hidden class=anchor aria-hidden=true href=#线程池的注意事项>#</a></h3><h4 id=什么时候开始创建临时线程>什么时候开始创建临时线程？<a hidden class=anchor aria-hidden=true href=#什么时候开始创建临时线程>#</a></h4><p>新任务提交时发现核心线程都在忙，任务队列也满了，并且还可以创建临时线程，此时才会创建临时线程。</p><h4 id=什么时候会拒绝新任务>什么时候会拒绝新任务？<a hidden class=anchor aria-hidden=true href=#什么时候会拒绝新任务>#</a></h4><p>核心线程和临时线程都在忙，任务队列也满了，新的任务过来的时候才会开始拒绝任务。</p><p><strong>任务拒绝策略</strong></p><table><thead><tr><th>策略</th><th>说明</th></tr></thead><tbody><tr><td>ThreadPoolExecutor.AbortPolicy()</td><td>丢弃任务并抛出RejectedExecutionException异常。是默认的策略</td></tr><tr><td>ThreadPoolExecutor. DiscardPolicy()</td><td>丢弃任务，但是不抛出异常，这是不推荐的做法</td></tr><tr><td>ThreadPoolExecutor. DiscardOldestPolicy()</td><td>抛弃队列中等待最久的任务 然后把当前任务加入队列中</td></tr><tr><td>ThreadPoolExecutor. CallerRunsPolicy()</td><td>由主线程负责调用任务的run()方法从而绕过线程池直接执行</td></tr></tbody></table><h3 id=处理callable任务>处理Callable任务<a hidden class=anchor aria-hidden=true href=#处理callable任务>#</a></h3><p>线程池如何处理Callable任务，并得到任务执行完后返回的结果？</p><p><strong>使用ExecutorService的方法</strong></p><p>Future submit（Callable command） 多态写法，返回一个RunnableFuture对象，可以调用里边get()方法</p><h3 id=进程>进程<a hidden class=anchor aria-hidden=true href=#进程>#</a></h3><p>正在运行的程序（软件）就是一个独立的进程</p><p>线程是属于进程的，一个进程中可以同时运行很多个线程</p><p>进程中的多个线程其实是并发和并行执行的</p><h3 id=并发的含义>并发的含义<a hidden class=anchor aria-hidden=true href=#并发的含义>#</a></h3><p>进程中的线程是由CPU负责调度执行的，但CPU能同时处理线程的数量有限，为了保证全部线程都能往前执行，CPU会轮询为系统的每个线程服务，由于CPU切换的速度很快，给我们的感觉这些线程在同时执行，这就是并发。</p><h3 id=并行的理解>并行的理解<a hidden class=anchor aria-hidden=true href=#并行的理解>#</a></h3><p>在同一个时刻上，同时有多个线程在被CPU调度执行。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://wqnm1gb.github.io/tags/java%E5%9F%BA%E7%A1%80/>Java基础</a></li></ul><nav class=paginav><a class=prev href=https://wqnm1gb.github.io/posts/day15-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/><span class=title>« 上一页</span><br><span>Day15 网络编程</span>
</a><a class=next href=https://wqnm1gb.github.io/posts/day13-file%E5%92%8Cio%E6%B5%81/><span class=title>下一页 »</span><br><span>Day13 File和IO流</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://wqnm1gb.github.io/>三狗子的博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>