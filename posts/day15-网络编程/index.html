<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Day15 网络编程 | 三狗子的博客</title>
<meta name=keywords content="java基础"><meta name=description content="InetAddress类
代表IP地址

  
      
          InetAddress类的常用方法
          说明
      
  
  
      
          public static InetAddress getLocalHost() throws UnknownHostException
          获取本机IP，返回一个InetAddress对象
      
      
          public String getHostName()
          获取该ip地址对象对应的主机名。
      
      
          public String getHostAddress()
          获取该ip地址对象中的ip地址信息。
      
      
          public static InetAddress getByName(String host)       throws UnknownHostException
          根据ip地址或者域名，返回一个inetAddress对象
      
      
          public boolean isReachable(int timeout) throws IOException
          判断主机在指定毫秒内与该ip对应的主机是否能连通
      
  

UDP通信
特点：无连接、不可靠通信。"><meta name=author content="冷漠三狗子丶"><link rel=canonical href=https://wqnm1gb.github.io/posts/day15-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/><link crossorigin=anonymous href=/assets/css/stylesheet.3d688279d829dc24da48acd11f9e33ebea2f39c035e899e1bf4297d8b7aa89b9.css integrity="sha256-PWiCedgp3CTaSKzRH54z6+ovOcA16Jnhv0KX2Leqibk=" rel="preload stylesheet" as=style><link rel=icon href=https://wqnm1gb.github.io/images/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://wqnm1gb.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wqnm1gb.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wqnm1gb.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://wqnm1gb.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://wqnm1gb.github.io/posts/day15-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel=stylesheet><script type=text/javascript async src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["[[","]]"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=" has-jax"})</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style><meta property="og:title" content="Day15 网络编程"><meta property="og:description" content="InetAddress类
代表IP地址

  
      
          InetAddress类的常用方法
          说明
      
  
  
      
          public static InetAddress getLocalHost() throws UnknownHostException
          获取本机IP，返回一个InetAddress对象
      
      
          public String getHostName()
          获取该ip地址对象对应的主机名。
      
      
          public String getHostAddress()
          获取该ip地址对象中的ip地址信息。
      
      
          public static InetAddress getByName(String host)       throws UnknownHostException
          根据ip地址或者域名，返回一个inetAddress对象
      
      
          public boolean isReachable(int timeout) throws IOException
          判断主机在指定毫秒内与该ip对应的主机是否能连通
      
  

UDP通信
特点：无连接、不可靠通信。"><meta property="og:type" content="article"><meta property="og:url" content="https://wqnm1gb.github.io/posts/day15-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><meta property="og:image" content="https://wqnm1gb.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-02-08T10:47:03+08:00"><meta property="article:modified_time" content="2025-02-08T10:47:03+08:00"><meta property="og:site_name" content="三狗子的博客"><meta property="fb:admins" content="your-facebook-admin-id"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wqnm1gb.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Day15 网络编程","item":"https://wqnm1gb.github.io/posts/day15-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Day15 网络编程","name":"Day15 网络编程","description":"InetAddress类 代表IP地址\nInetAddress类的常用方法 说明 public static InetAddress getLocalHost() throws UnknownHostException 获取本机IP，返回一个InetAddress对象 public String getHostName() 获取该ip地址对象对应的主机名。 public String getHostAddress() 获取该ip地址对象中的ip地址信息。 public static InetAddress getByName(String host) throws UnknownHostException 根据ip地址或者域名，返回一个inetAddress对象 public boolean isReachable(int timeout) throws IOException 判断主机在指定毫秒内与该ip对应的主机是否能连通 UDP通信 特点：无连接、不可靠通信。\n","keywords":["java基础"],"articleBody":"InetAddress类 代表IP地址\nInetAddress类的常用方法 说明 public static InetAddress getLocalHost() throws UnknownHostException 获取本机IP，返回一个InetAddress对象 public String getHostName() 获取该ip地址对象对应的主机名。 public String getHostAddress() 获取该ip地址对象中的ip地址信息。 public static InetAddress getByName(String host) throws UnknownHostException 根据ip地址或者域名，返回一个inetAddress对象 public boolean isReachable(int timeout) throws IOException 判断主机在指定毫秒内与该ip对应的主机是否能连通 UDP通信 特点：无连接、不可靠通信。\n不事先建立连接；发送端每次把要发送的数据（限制在64KB内）、接收端IP、等信息封装成一个数据包，发出去就不管了。\nJava提供了一个java.net.DatagramSocket类来实现UDP通信。\nDatagramSocket：用于创建客户端、服务端\n构造器 说明 public DatagramSocket() 创建客户端的Socket对象, 系统会随机分配一个端口号。 public DatagramSocket(int port) 创建服务端的Socket对象, 并指定端口号 方法 说明 public void send(DatagramPacketdp****) 发送数据包 public void receive(DatagramPacket p) 使用数据包接收数据 DatagramPacket：创建数据包\n构造器 说明 public DatagramPacket(byte[] buf, int length, InetAddress address, int port) 创建发出去的数据包对象 public DatagramPacket(byte[] buf, int length) 创建用来接收数据的数据包 方法 说明 public int getLength() 获取数据包，实际接收到的字节个数 客户端实现步骤 ① 创建DatagramSocket对象（客户端对象）——\u003e扔韭菜的人\n② 创建DatagramPacket对象封装需要发送的数据（数据包对象）—–\u003e韭菜盘子\n③ 使用Datagramsocket对象的send方法，传入DatagramPaket对象 —–\u003e开始抛出韭菜\n④ 释放资源\n客户端实现可以反复发送数据 ① 创建DatagramSocket对象（发送端对象）\n② 使用while死循环不断的接收用户的数据输入，如果用户输入的exit则退出程序\n③ 如果用户输入的不是exit，把数据封装成DatagramPacket\n④ 使用DatagramSocket对象的send方法将数据包对象进行发送\n⑤ 释放资源\n服务端实现步骤 ① 创建DatagramSocket对象并指定端口（服务端对象）—–\u003e 接韭菜的人\n② 创建DatagramPacket对象接收数据（数据包对象）——-\u003e 韭菜盘子\n③ 使用DatagramSocket对象的receive方法，传入DatagramPacket对象 ——-\u003e开始接收韭菜\n④ 释放资源\n服务端实现可以反复发送数据 ① 创建DatagramSocket对象并指定端口（服务端对象）—–\u003e 接韭菜的人\n② 创建DatagramPacket对象接收数据（数据包对象）——-\u003e 韭菜盘子\n③ 使用DatagramSocket对象的receive方法，传入DatagramPacket对象 ——-\u003e开始接收韭菜\n④ 使用while死循环不断的进行第3步\nUDP的接收端为什么可以接收很多发送端的消息？\n接收端只负责接收数据包，无所谓是哪个发送端的数据包。\nTCP通信 客户端程序就是通过java.net包下的Socket类来实现的。\n构造器 说明 public Socket(String host , int port) 根据指定的服务器ip、端口号请求与服务端建立连接，连接通过，就获得了客户端socket 方法 说明 public OutputStreamgetOutputStream() 获得字节输出流对象 public InputStreamgetInputStream() 获得字节输入流对象 通过流对象来接收和传输数据\n服务端是通过java.net包下的ServerSocket类来实现的。\n构造器 说明 public ServerSocket(int port) 为服务端程序注册端口 方法 说明 public Socket accept() 阻塞等待客户端的连接请求，一旦与某个客户端成功连接，则返回服务端这边的Socket对象。 客户端实现步骤 ① 创建客户端的Socket对象，请求与服务端的连接。\n② 使用socket对象调用getOutputstream()方法得到字节输出流。\n③ 使用字节输出流完成数据的发送。\n④ 释放资源：关闭socket管道。\n服务端实现步骤 ① 创建ServerSocket对象，注册服务端端口。\n② 调用ServerSocket对象的accept()方法，等待客户端的连接，并得到Socket管道对象。\n③ 通过Socket对象调用getInputStream()方法得到字节输入流、完成数据的接收。\n④ 释放资源：关闭socket管道\n继承了Thread类本身也可以当一个Runnable对象来进行使用，因为Thread类也实现了Runnable接口！\n时间类 JDK8之后的新方案\nLocalDate：代表本地日期（年、月、日、星期）\nLocalTime：代表本地时间（时、分、秒、纳秒）\nLocalDateTime：代表本地日期、时间（年、月、日、星期、时、分、秒、纳秒）\n方法名 示例 public static Xxxx now(): 获取系统当前时间对应的该对象 LocaDateld = LocalDate.now(); LocalTimelt = LocalTime.now(); LocalDateTimeldt = LocalDateTime.now(); LocalDateTime的常用API（可以处理年、月、日、星期、时、分、秒、纳秒等信息）\n方法名 说明 getYear、getMonthValue、getDayOfMonth、getDayOfYeargetDayOfWeek、getHour、getMinute、getSecond、getNano 获取年月日、时分秒、纳秒等 withYear、withMonth、withDayOfMonth、withDayOfYearwithHour、withMinute、withSecond、withNano 修改某个信息，返回新日期时间对象 plusYears、plusMonths、plusDays、plusWeeksplusHours、plusMinutes、plusSeconds、plusNanos 把某个信息加多少，返回新日期时间对象 minusYears、minusMonths、minusDays、minusWeeksminusHours、minusMinutes、minusSeconds、minusNanos 把某个信息减多少，返回新日期时间对象 equals isBeforeisAfter 判断2个时间对象，是否相等，在前还是在后 字符串高效操作 +号拼接字符串内容，效率不高，原因是String的对象是不可变变量，每次都要指向新的对象\n对于字符串相关的操作，如频繁的拼接、修改等，建议用StringBuidler，效率更高！\n注意：如果操作字符串较少，或者不需要操作，以及定义字符串变量，还是建议用String。\nStringBuilder代表可变字符串对象，相当于是一个容器，它里面装的字符串是可以改变的，就是用来操作字符串的。\n好处：StringBuilder比String更适合做字符串的修改操作，效率会更高，代码也会更简洁，而且支持链式操作\n构造器 说明 public StringBuilder() 创建一个空白的可变的字符串对象，不包含任何内容 public StringBuilder(String str) 创建一个指定字符串内容的可变字符串对象 方法名称 说明 public StringBuilder append(任意类型) 添加数据并返回StringBuilder对象本身 public StringBuilder reverse() 将对象的内容反转 public int length() 返回对象内容长度 public String toString() 通过toString()就可以实现把StringBuilder转换为String BigDecimal 用于解决浮点型运算时，出现结果失真的问题\n构造器 说明 public BigDecimal(double val) 注意：不推荐使用这个 将 double转换为 BigDecimal public BigDecimal(String val) 把String转成BigDecimal 方法名 说明 public static BigDecimal valueOf(double val) 转换一个 double成 BigDecimal public BigDecimal add(BigDecimal b) 加法 public BigDecimal subtract(BigDecimal b) 减法 public BigDecimal multiply(BigDecimal b) 乘法 public BigDecimal divide(BigDecimal b) 除法 public BigDecimal divide (另一个BigDecimal对象，精确几位，舍入模式) 除法、可以控制精确到小数几位 public double doubleValue() 将BigDecimal转换为double 应该如何把浮点型转换成Biglecimal的对象？\nBigDecimal b1 = BigDecimal. valueOf（0.1）\n","wordCount":"3095","inLanguage":"zh","image":"https://wqnm1gb.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-02-08T10:47:03+08:00","dateModified":"2025-02-08T10:47:03+08:00","author":{"@type":"Person","name":"冷漠三狗子丶"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wqnm1gb.github.io/posts/day15-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},"publisher":{"@type":"Organization","name":"三狗子的博客","logo":{"@type":"ImageObject","url":"https://wqnm1gb.github.io/images/favicon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wqnm1gb.github.io/ accesskey=h title="主页 (Alt + H)"><img src=https://wqnm1gb.github.io/apple-touch-icon.png alt aria-label=logo height=35>主页</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wqnm1gb.github.io/ title=三狗子的博客><span>首页</span></a></li><li><a href=https://wqnm1gb.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://wqnm1gb.github.io/categories/ title=Categories><span>分类</span></a></li><li><a href=https://wqnm1gb.github.io/tags/ title=Tags><span>标签</span></a></li><li><a href=https://wqnm1gb.github.io/search/ title=搜索><span>搜索</span></a></li><li><a href=https://wqnm1gb.github.io/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://wqnm1gb.github.io/>主页</a>&nbsp;»&nbsp;<a href=https://wqnm1gb.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Day15 网络编程</h1><div class=post-meta><span title='2025-02-08 10:47:03.678253 +0800 +0800'>二月 8, 2025</span>&nbsp;·&nbsp;7 分钟&nbsp;·&nbsp;3095 字&nbsp;·&nbsp;冷漠三狗子丶</div></header><div class=post-content><h1 id=inetaddress类>InetAddress类<a hidden class=anchor aria-hidden=true href=#inetaddress类>#</a></h1><p>代表IP地址</p><table><thead><tr><th>InetAddress类的常用方法</th><th>说明</th></tr></thead><tbody><tr><td>public static InetAddress getLocalHost() throws UnknownHostException</td><td>获取本机IP，返回一个InetAddress对象</td></tr><tr><td>public String getHostName()</td><td>获取该ip地址对象对应的主机名。</td></tr><tr><td>public String getHostAddress()</td><td>获取该ip地址对象中的ip地址信息。</td></tr><tr><td>public static InetAddress getByName(String host) throws UnknownHostException</td><td>根据ip地址或者域名，返回一个inetAddress对象</td></tr><tr><td>public boolean isReachable(int timeout) throws IOException</td><td>判断主机在指定毫秒内与该ip对应的主机是否能连通</td></tr></tbody></table><h1 id=udp通信>UDP通信<a hidden class=anchor aria-hidden=true href=#udp通信>#</a></h1><p>特点：无连接、不可靠通信。</p><p>不事先建立连接；发送端每次把要发送的数据（限制在64KB内）、接收端IP、等信息封装成一个数据包，发出去就不管了。</p><p>Java提供了一个java.net.DatagramSocket类来实现UDP通信。</p><p><strong>DatagramSocket：用于创建客户端、服务端</strong></p><table><thead><tr><th><strong>构造器</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>public DatagramSocket()</td><td>创建<strong>客户端</strong>的Socket对象, 系统会随机分配一个端口号。</td></tr><tr><td>public DatagramSocket(int port)</td><td>创建<strong>服务端</strong>的Socket对象, 并指定端口号</td></tr></tbody></table><table><thead><tr><th><strong>方法</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>public void <strong>send(<strong><strong>DatagramPacket</strong></strong>dp****)</strong></td><td>发送数据包</td></tr><tr><td>public void <strong>receive(<strong><strong>DatagramPacket</strong></strong> p)</strong></td><td>使用数据包接收数据</td></tr></tbody></table><p><strong>DatagramPacket：创建数据包</strong></p><table><thead><tr><th><strong>构造器</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>public DatagramPacket(byte[] buf, int length, InetAddress address, int port)</td><td>创建发出去的数据包对象</td></tr><tr><td>public DatagramPacket(byte[] buf, int length)</td><td>创建用来接收数据的数据包</td></tr></tbody></table><table><thead><tr><th><strong>方法</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>public int <strong>getLength</strong>()</td><td>获取数据包，实际接收到的字节个数</td></tr></tbody></table><h2 id=客户端实现步骤>客户端实现步骤<a hidden class=anchor aria-hidden=true href=#客户端实现步骤>#</a></h2><p>① 创建DatagramSocket对象（客户端对象）&mdash;&mdash;>扔韭菜的人</p><p>② 创建DatagramPacket对象封装需要发送的数据（数据包对象）&mdash;&ndash;>韭菜盘子</p><p>③ 使用Datagramsocket对象的send方法，传入DatagramPaket对象 &mdash;&ndash;>开始抛出韭菜</p><p>④ 释放资源</p><h3 id=客户端实现可以反复发送数据>客户端实现可以反复发送数据<a hidden class=anchor aria-hidden=true href=#客户端实现可以反复发送数据>#</a></h3><p>① 创建DatagramSocket对象（发送端对象）</p><p>② 使用while死循环不断的接收用户的数据输入，如果用户输入的exit则退出程序</p><p>③ 如果用户输入的不是exit，把数据封装成DatagramPacket</p><p>④ 使用DatagramSocket对象的send方法将数据包对象进行发送</p><p>⑤ 释放资源</p><h2 id=服务端实现步骤>服务端实现步骤<a hidden class=anchor aria-hidden=true href=#服务端实现步骤>#</a></h2><p>① 创建DatagramSocket对象并指定端口（服务端对象）&mdash;&ndash;> 接韭菜的人</p><p>② 创建DatagramPacket对象接收数据（数据包对象）&mdash;&mdash;-> 韭菜盘子</p><p>③ 使用DatagramSocket对象的receive方法，传入DatagramPacket对象 &mdash;&mdash;->开始接收韭菜</p><p>④ 释放资源</p><h3 id=服务端实现可以反复发送数据>服务端实现可以反复发送数据<a hidden class=anchor aria-hidden=true href=#服务端实现可以反复发送数据>#</a></h3><p>① 创建DatagramSocket对象并指定端口（服务端对象）&mdash;&ndash;> 接韭菜的人</p><p>② 创建DatagramPacket对象接收数据（数据包对象）&mdash;&mdash;-> 韭菜盘子</p><p>③ 使用DatagramSocket对象的receive方法，传入DatagramPacket对象 &mdash;&mdash;->开始接收韭菜</p><p>④ 使用while死循环不断的进行第3步</p><p><strong>UDP的接收端为什么可以接收很多发送端的消息？</strong></p><p>接收端只负责接收数据包，无所谓是哪个发送端的数据包。</p><h1 id=tcp通信>TCP通信<a hidden class=anchor aria-hidden=true href=#tcp通信>#</a></h1><p><strong>客户端程序就是通过java.net包下的Socket类来实现的。</strong></p><table><thead><tr><th><strong>构造器</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>public Socket(String host , int port)</td><td>根据指定的服务器ip、端口号请求与服务端建立连接，连接通过，就获得了客户端socket</td></tr></tbody></table><table><thead><tr><th><strong>方法</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>public OutputStreamgetOutputStream()</td><td>获得字节输出流对象</td></tr><tr><td>public InputStreamgetInputStream()</td><td>获得字节输入流对象</td></tr></tbody></table><p>通过流对象来接收和传输数据</p><p><strong>服务端是通过java.net包下的ServerSocket类来实现的。</strong></p><table><thead><tr><th><strong>构造器</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>public ServerSocket(int port)</td><td>为服务端程序注册端口</td></tr></tbody></table><table><thead><tr><th><strong>方法</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>public Socket accept()</td><td>阻塞等待客户端的连接请求，一旦与某个客户端成功连接，则返回服务端这边的Socket对象。</td></tr></tbody></table><h2 id=客户端实现步骤-1>客户端实现步骤<a hidden class=anchor aria-hidden=true href=#客户端实现步骤-1>#</a></h2><p>① 创建客户端的Socket对象，请求与服务端的连接。</p><p>② 使用socket对象调用getOutputstream()方法得到字节输出流。</p><p>③ 使用字节输出流完成数据的发送。</p><p>④ 释放资源：关闭socket管道。</p><h2 id=服务端实现步骤-1>服务端实现步骤<a hidden class=anchor aria-hidden=true href=#服务端实现步骤-1>#</a></h2><p>① 创建ServerSocket对象，注册服务端端口。</p><p>② 调用ServerSocket对象的accept()方法，等待客户端的连接，并得到Socket管道对象。</p><p>③ 通过Socket对象调用getInputStream()方法得到字节输入流、完成数据的接收。</p><p>④ 释放资源：关闭socket管道</p><p>继承了Thread类本身也可以当一个Runnable对象来进行使用，因为Thread类也实现了Runnable接口！</p><h1 id=时间类>时间类<a hidden class=anchor aria-hidden=true href=#时间类>#</a></h1><p><strong>JDK8之后的新方案</strong></p><p>LocalDate：代表本地日期（年、月、日、星期）</p><p>LocalTime：代表本地时间（时、分、秒、纳秒）</p><p>LocalDateTime：代表本地日期、时间（年、月、日、星期、时、分、秒、纳秒）</p><table><thead><tr><th>方法名</th><th>示例</th></tr></thead><tbody><tr><td>public static Xxxx now(): 获取系统当前时间对应的该对象</td><td>LocaDateld = LocalDate.now(); LocalTimelt = LocalTime.now(); LocalDateTimeldt = LocalDateTime.now();</td></tr></tbody></table><p>LocalDateTime的常用API（可以处理年、月、日、星期、时、分、秒、纳秒等信息）</p><table><thead><tr><th><strong>方法名</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>getYear、getMonthValue、getDayOfMonth、getDayOfYeargetDayOfWeek、getHour、getMinute、getSecond、getNano</td><td>获取年月日、时分秒、纳秒等</td></tr><tr><td>withYear、withMonth、withDayOfMonth、withDayOfYearwithHour、withMinute、withSecond、withNano</td><td>修改某个信息，返回新日期时间对象</td></tr><tr><td>plusYears、plusMonths、plusDays、plusWeeksplusHours、plusMinutes、plusSeconds、plusNanos</td><td>把某个信息加多少，返回新日期时间对象</td></tr><tr><td>minusYears、minusMonths、minusDays、minusWeeksminusHours、minusMinutes、minusSeconds、minusNanos</td><td>把某个信息减多少，返回新日期时间对象</td></tr><tr><td>equals isBeforeisAfter</td><td>判断2个时间对象，是否相等，在前还是在后</td></tr></tbody></table><h1 id=字符串高效操作>字符串高效操作<a hidden class=anchor aria-hidden=true href=#字符串高效操作>#</a></h1><p>+号拼接字符串内容，效率不高，原因是String的对象是不可变变量，每次都要指向新的对象</p><p>对于字符串相关的操作，如频繁的拼接、修改等，建议用StringBuidler，效率更高！</p><p>注意：如果操作字符串较少，或者不需要操作，以及定义字符串变量，还是建议用String。</p><p>StringBuilder代表可变字符串对象，相当于是一个容器，它里面装的字符串是可以改变的，就是用来操作字符串的。</p><p>好处：StringBuilder比String更适合做字符串的修改操作，效率会更高，代码也会更简洁，而且支持链式操作</p><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public StringBuilder()</td><td>创建一个空白的可变的字符串对象，不包含任何内容</td></tr><tr><td>public StringBuilder(String str)</td><td>创建一个指定字符串内容的可变字符串对象</td></tr></tbody></table><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>public StringBuilder append(任意类型)</td><td>添加数据并返回StringBuilder对象本身</td></tr><tr><td>public StringBuilder reverse()</td><td>将对象的内容反转</td></tr><tr><td>public int length()</td><td>返回对象内容长度</td></tr><tr><td>public String toString()</td><td>通过toString()就可以实现把StringBuilder转换为String</td></tr></tbody></table><h1 id=bigdecimal>BigDecimal<a hidden class=anchor aria-hidden=true href=#bigdecimal>#</a></h1><p>用于解决浮点型运算时，出现结果失真的问题</p><table><thead><tr><th><strong>构造器</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>public BigDecimal(double val) 注意：不推荐使用这个</td><td>将 double转换为 BigDecimal</td></tr><tr><td>public BigDecimal(String val)</td><td>把String转成BigDecimal</td></tr></tbody></table><table><thead><tr><th><strong>方法名</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>public static BigDecimal valueOf(double val)</td><td>转换一个 double成 BigDecimal</td></tr><tr><td>public BigDecimal add(BigDecimal b)</td><td>加法</td></tr><tr><td>public BigDecimal subtract(BigDecimal b)</td><td>减法</td></tr><tr><td>public BigDecimal multiply(BigDecimal b)</td><td>乘法</td></tr><tr><td>public BigDecimal divide(BigDecimal b)</td><td>除法</td></tr><tr><td>public BigDecimal divide (另一个BigDecimal对象，精确几位，舍入模式)</td><td>除法、可以控制精确到小数几位</td></tr><tr><td>public double doubleValue()</td><td>将BigDecimal转换为double</td></tr></tbody></table><p><strong>应该如何把浮点型转换成Biglecimal的对象？</strong></p><p>BigDecimal b1 = BigDecimal. valueOf（0.1）</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://wqnm1gb.github.io/tags/java%E5%9F%BA%E7%A1%80/>Java基础</a></li></ul><nav class=paginav><a class=prev href=https://wqnm1gb.github.io/posts/day16-java%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF/><span class=title>« 上一页</span><br><span>Day16 Java高级技术</span>
</a><a class=next href=https://wqnm1gb.github.io/posts/day14-thread/><span class=title>下一页 »</span><br><span>Day14 Thread</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://wqnm1gb.github.io/>三狗子的博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>