<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Day11 异常、泛型和集合 | 三狗子的博客</title>
<meta name=keywords content="java基础"><meta name=description content="异常
Error
Error 代表的系统级别错误（属于严重问题），也就是说系统一旦出现问题，sun公司会把这些问题封装成Error对象给出来（说白了，Error是给sun公司自己用的，不是给我们程序员用的，因此我们开发人员不用管它）"><meta name=author content="冷漠三狗子丶"><link rel=canonical href=https://wqnm1gb.github.io/posts/day11-%E5%BC%82%E5%B8%B8%E6%B3%9B%E5%9E%8B%E5%92%8C%E9%9B%86%E5%90%88/><link crossorigin=anonymous href=/assets/css/stylesheet.3d688279d829dc24da48acd11f9e33ebea2f39c035e899e1bf4297d8b7aa89b9.css integrity="sha256-PWiCedgp3CTaSKzRH54z6+ovOcA16Jnhv0KX2Leqibk=" rel="preload stylesheet" as=style><link rel=icon href=https://wqnm1gb.github.io/images/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://wqnm1gb.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wqnm1gb.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wqnm1gb.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://wqnm1gb.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://wqnm1gb.github.io/posts/day11-%E5%BC%82%E5%B8%B8%E6%B3%9B%E5%9E%8B%E5%92%8C%E9%9B%86%E5%90%88/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel=stylesheet><script type=text/javascript async src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["[[","]]"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=" has-jax"})</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style><meta property="og:title" content="Day11 异常、泛型和集合"><meta property="og:description" content="异常
Error
Error 代表的系统级别错误（属于严重问题），也就是说系统一旦出现问题，sun公司会把这些问题封装成Error对象给出来（说白了，Error是给sun公司自己用的，不是给我们程序员用的，因此我们开发人员不用管它）"><meta property="og:type" content="article"><meta property="og:url" content="https://wqnm1gb.github.io/posts/day11-%E5%BC%82%E5%B8%B8%E6%B3%9B%E5%9E%8B%E5%92%8C%E9%9B%86%E5%90%88/"><meta property="og:image" content="https://wqnm1gb.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-02-08T10:44:46+08:00"><meta property="article:modified_time" content="2025-02-08T10:44:46+08:00"><meta property="og:site_name" content="三狗子的博客"><meta property="fb:admins" content="your-facebook-admin-id"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wqnm1gb.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Day11 异常、泛型和集合","item":"https://wqnm1gb.github.io/posts/day11-%E5%BC%82%E5%B8%B8%E6%B3%9B%E5%9E%8B%E5%92%8C%E9%9B%86%E5%90%88/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Day11 异常、泛型和集合","name":"Day11 异常、泛型和集合","description":"异常 Error Error 代表的系统级别错误（属于严重问题），也就是说系统一旦出现问题，sun公司会把这些问题封装成Error对象给出来（说白了，Error是给sun公司自己用的，不是给我们程序员用的，因此我们开发人员不用管它）\n","keywords":["java基础"],"articleBody":"异常 Error Error 代表的系统级别错误（属于严重问题），也就是说系统一旦出现问题，sun公司会把这些问题封装成Error对象给出来（说白了，Error是给sun公司自己用的，不是给我们程序员用的，因此我们开发人员不用管它）\nException 运行时异常 编译阶段不报错，运行时报错，继承自RunTimeException，一旦错误出现，程序就会结束\nNullPointException空指针\n编译时异常 提醒程序员这里的程序很容易出错，需要小心\n使用try catch解决(可以解决编译时异常，也可以解决运行时异常），提醒会更加的强烈，同时处理完异常后，程序不会结束\n异常的基本处理 throws抛出异常 在方法上使用throws关键字，可以将方法内部出现的异常抛出去给调用者处理。\ntry catch捕获异常 直接捕获可能出现的异常\n异常的作用 1、用来定位bug的关键信息\n2、作为方法内部的一种特殊的返回值，以便通知上层调用者，方法执行的问题\n自定义异常 Java无法为这个世界上全部的问题都提供异常类来代表 如果企业自己的某种问题， 想通过异常来表示，以便用异常来管理该问题，那就需要自己来定义异常类了。\n建议使用运行时异常，这样提醒没有那么强烈\n自定义运行时异常 定义一个异常类继承RuntimeException\n重写构造器\n通过throw new 异常类（xxx）来创建异常对象并拋出\n特点：编译阶段不报错，运行时才可能出现！提醒不属于激进型\n自定义编译时异常 定义一个异常类继承Exception\n重写构造器\n通过throw new 异常类（xxxx）创建异常对象并抛出\n特点：编译阶段就报错，提醒比较激进\n异常的处理方案 command option t 快捷生成try catch\n方案1 底层异常层层往上抛出，最外层捕获异常，记录下异常信息，并响应适合用户观看的信息进行提示\n有多个异常的时候，直接抛Exception，这样不用多个异常写多个异常的种类\n然后catch的时候，也就catch Exception类就行了\n方案2 最外层捕获异常后，尝试重新修复\n泛型 定义类、接口、方法时，同时声明了一个或者多个类型变量（如：）\n称为泛型类、泛型接口，泛型方法、它们统称为泛型。\npublic class ArrayList\u003cE\u003e{ } 作用：泛型提供了在编译阶段约束所能操作的数据类型，并自动进行检查的能力！\n泛型的本质：把具体的数据类型作为参数传给类型变量\n泛型类 修饰符 class类名\u003c类型变量，类型变量，…\u003e｛ ｝ 注意：类型变量建议用大写的英文字母，常用的有：E、T、K、V等\n泛型接口 修饰符 interface 接口名\u003c类型变量，类型变量，...\u003e ｝ 泛型方法，通配符，上下限 泛型方法 修饰符\u003c类型变量，类型变量，…＞返回值类型 方法名（形参列表）｛ ｝ // 泛型方法声明都有一个类型参数声明部分（由尖括号分隔） public static \u003cT\u003e void test（T t）｛ ｝ 通配符 就是“？”，可以在“使用泛型”的时候代表一切类型；ET KV 是在定义泛型的时候使用。\n泛型的上下限 • 泛型上限：？extends Car：？能接收的必须是Car或者其子类。\n• 泛型下限：？super Car：？能接收的必须是Car或者其父类。\n泛型支持的类型 泛型不支持基本数据类型，只能支持对象类型（引用数据类型）\n泛型擦除：泛型工作在编译阶段，等编译后泛型就没用了，所以泛型在编译后都会被擦除。所有类型会恢复成Object类型，Object一定要指向一个对象\n包装类 包装类就是把基本类型的数据包装成对象的类型\nInteger把-128-127先缓存起来了\nInteger it1 = Integer.valueof(100); Integer it3 = 100;//和第一句一样的，自动装箱，变成对象 Integer it2 = Integer.valueof(100); System.out.println(it1==it2);//true 自动装箱：基本数据类型可以自动转换为包装类型。\n自动拆箱：包装类型可以自动转换为基本数据类型。\n包装类的其他功能 可以把基本类型的数据转换成字符串类型。\npublic static String toString(double d) public String toString() //功能比较鸡肋，一般转成字符串会用 String s1 = 123 + \"\"; 可以把字符串类型的数值转换成数值本身对应的真实数据类型（这个重要）\npublic static int parselnt(String s) public static Integer valueOf(String s) 集合框架 集合是一种容器，用来装数据的，类似于数组，但集合的大小可变，开发中也非常常用\n集合体系结构 集合的结构分成了两类\nCollection-单列集合 每个元素（数据）只包含一个值\n常用功能\n方法名 说明 public boolean add(E e) 把给定的对象添加到当前集合中 public void clear() 清空集合中所有的元素 public boolean remove(E e) 把给定的对象在当前集合中删除 public boolean contains(Object obj) 判断当前集合中是否包含给定的对象 public boolean isEmpty() 判断当前集合是否为空 public int size() 返回集合中元素的个数。 public Object[] toArray() 把集合中的元素，存储到数组中，默认转换成Object数组 Collection的遍历方式1：迭代器遍历\nnext() 函数默认是在第一个元素的位置，先取值在去到下一个元素位置\nhasnext() 函数是判断当前位置是否有元素\n获取迭代器\n方法名称 说明 Iterator iterator() 返回集合中的迭代器对象，该迭代器对象默认指向当前集合的第一个元素 迭代器中常用的方法\n方法名称 说明 boolean hasNext() 询问当前位置是否有元素存在，存在返回true ,不存在返回false E next() 获取当前位置的元素，并同时将迭代器对象指向下一个元素处。 Collection的遍历方式2：增强for循环\nfor (元素的数据类型 变量名 : 数组或者集合) { } 增强for可以用来遍历集合或者数组\n增强for遍历集合，本质就是迭代器遍历集合的简化写法\n快捷方式 数组/集合名.for\n底层就是基于迭代器\nCollection的遍历方式3：Lambda表达式\n要使用如下方法来完成\n方法名称 说明 default void forEach(Consumer\u003c? super T\u003e action) 结合lambda遍历集合 public static void main(String[] args) { //遍历方式3：使用Lambda表达式 ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"张三\"); list.add(\"李四\"); list.add(\"王五\"); list.add(\"赵6\"); list.forEach(s -\u003e System.out.println(s)); list.forEach(System.out::println); } 三种遍历的区别 认识并发修改异常问题\n遍历集合的同时又存在增删集合元素的行为时可能出现业务异常，这种现象被称之为并发修改异常问题。\nfor循环删除元素没删干净的本质原因是：删除一个元素后，后边一个元素立马补上来，导致了漏删\n解决方案1：删除元素后做一步i–\n解决方案2：倒着遍历删除（前提是支持索引），原因是后边的元素补过来都是判断后不用删的，而顺着遍历前边的元素补上来不知道是否要删除\n1、迭代器遍历并删除存在并发修改异常问题，解决方案：使用迭代器自己的删除方法\n2、增强for和lambda都没办法解决并发修改异常问题，他们只适合做遍历，不适合做增删\n如果知道索引可以使用i–的方式解决，如果不知道索引，就用迭代器的删除功能\nList系列集合：添加的元素是有序、可重复、有索引 List集合因为支持索引，所以多了很多与索引相关的方法，当然，Collection的功能List也都继承了。\n方法名称 说明 void add(int index,E element) 在此集合中的指定位置插入指定的元素 E remove(int index) 删除指定索引处的元素，返回被删除的元素 E set(int index,E element) 修改指定索引处的元素，返回被修改的元素 E get(int index) 返回指定索引处的元素 ArrayList、LinekdList：有序、可重复、有索引\nArrayList底层是基于数组存储数据的 数组的特点\n查询速度快（注意：是根据索引查询数据快）：查询数据通过地址值和索引定位，查询任意数据耗时相同。\n增删数据效率低：可能需要把后面很多的数据进行前移。\n第一次创建的时候是创建一个空数组，第一次添加的时候才扩容为初始大小为10的数组，二次添加后，会添加成之前的1.5倍\nLinkedList底层是基于链表存储数据的 链表的特点\n链表中的数据是一个一个独立的结点组成的，结点在内存中是不连续的，每个结点包含数据值和下一个结点的地址。是基于双链表实现的，特点：对首尾元素进行增删改查的速度是极快的，占用的内存更多\nLinkedList新增了：很多首尾操作的特有方法。\n链表的特点1：查询慢，无论查询哪个数据都要从头开始找。\n链表的特点2：链表增删相对快\n只需要一个的对象可以用static修饰\nSet系列集合：添加的元素是无序、不重复、无索引 HashSet： 无序、不重复、无索引\nLinkedHashSet： 有序、不重复、无索引\nTreeSet：按照大小默认升序排序、不重复、无索引\nMap-双列集合 每个元素包含两个值（键值对）\n","wordCount":"3269","inLanguage":"zh","image":"https://wqnm1gb.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-02-08T10:44:46+08:00","dateModified":"2025-02-08T10:44:46+08:00","author":{"@type":"Person","name":"冷漠三狗子丶"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wqnm1gb.github.io/posts/day11-%E5%BC%82%E5%B8%B8%E6%B3%9B%E5%9E%8B%E5%92%8C%E9%9B%86%E5%90%88/"},"publisher":{"@type":"Organization","name":"三狗子的博客","logo":{"@type":"ImageObject","url":"https://wqnm1gb.github.io/images/favicon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wqnm1gb.github.io/ accesskey=h title="主页 (Alt + H)"><img src=https://wqnm1gb.github.io/apple-touch-icon.png alt aria-label=logo height=35>主页</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wqnm1gb.github.io/ title=三狗子的博客><span>首页</span></a></li><li><a href=https://wqnm1gb.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://wqnm1gb.github.io/categories/ title=Categories><span>分类</span></a></li><li><a href=https://wqnm1gb.github.io/tags/ title=Tags><span>标签</span></a></li><li><a href=https://wqnm1gb.github.io/search/ title=搜索><span>搜索</span></a></li><li><a href=https://wqnm1gb.github.io/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://wqnm1gb.github.io/>主页</a>&nbsp;»&nbsp;<a href=https://wqnm1gb.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Day11 异常、泛型和集合</h1><div class=post-meta><span title='2025-02-08 10:44:46.355048 +0800 +0800'>二月 8, 2025</span>&nbsp;·&nbsp;7 分钟&nbsp;·&nbsp;3269 字&nbsp;·&nbsp;冷漠三狗子丶</div></header><div class=post-content><h2 id=异常>异常<a hidden class=anchor aria-hidden=true href=#异常>#</a></h2><h3 id=error>Error<a hidden class=anchor aria-hidden=true href=#error>#</a></h3><p>Error 代表的系统级别错误（属于严重问题），也就是说系统一旦出现问题，sun公司会把这些问题封装成Error对象给出来（说白了，Error是给sun公司自己用的，不是给我们程序员用的，因此我们开发人员不用管它）</p><h3 id=exception>Exception<a hidden class=anchor aria-hidden=true href=#exception>#</a></h3><h4 id=运行时异常>运行时异常<a hidden class=anchor aria-hidden=true href=#运行时异常>#</a></h4><p>编译阶段不报错，运行时报错，继承自RunTimeException，一旦错误出现，程序就会结束</p><p>NullPointException空指针</p><h4 id=编译时异常>编译时异常<a hidden class=anchor aria-hidden=true href=#编译时异常>#</a></h4><p>提醒程序员这里的程序很容易出错，需要小心</p><p>使用try catch解决(可以解决编译时异常，也可以解决运行时异常），提醒会更加的强烈，同时处理完异常后，程序不会结束</p><h2 id=异常的基本处理>异常的基本处理<a hidden class=anchor aria-hidden=true href=#异常的基本处理>#</a></h2><h3 id=throws抛出异常>throws抛出异常<a hidden class=anchor aria-hidden=true href=#throws抛出异常>#</a></h3><p>在方法上使用throws关键字，可以将方法内部出现的异常抛出去给调用者处理。</p><p></p><h3 id=try-catch捕获异常>try catch捕获异常<a hidden class=anchor aria-hidden=true href=#try-catch捕获异常>#</a></h3><p>直接捕获可能出现的异常</p><h2 id=异常的作用>异常的作用<a hidden class=anchor aria-hidden=true href=#异常的作用>#</a></h2><p>1、用来定位bug的关键信息</p><p>2、作为方法内部的一种特殊的返回值，以便通知上层调用者，方法执行的问题</p><h2 id=自定义异常>自定义异常<a hidden class=anchor aria-hidden=true href=#自定义异常>#</a></h2><p>Java无法为这个世界上全部的问题都提供异常类来代表 如果企业自己的某种问题， 想通过异常来表示，以便用异常来管理该问题，那就需要自己来定义异常类了。</p><p>建议使用运行时异常，这样提醒没有那么强烈</p><h3 id=自定义运行时异常>自定义运行时异常<a hidden class=anchor aria-hidden=true href=#自定义运行时异常>#</a></h3><p>定义一个异常类继承RuntimeException</p><p>重写构造器</p><p>通过throw new 异常类（xxx）来创建异常对象并拋出</p><p>特点：编译阶段不报错，运行时才可能出现！提醒不属于激进型</p><h3 id=自定义编译时异常>自定义编译时异常<a hidden class=anchor aria-hidden=true href=#自定义编译时异常>#</a></h3><p>定义一个异常类继承Exception</p><p>重写构造器</p><p>通过throw new 异常类（xxxx）创建异常对象并抛出</p><p>特点：编译阶段就报错，提醒比较激进</p><h2 id=异常的处理方案>异常的处理方案<a hidden class=anchor aria-hidden=true href=#异常的处理方案>#</a></h2><p>command option t 快捷生成try catch</p><h3 id=方案1>方案1<a hidden class=anchor aria-hidden=true href=#方案1>#</a></h3><p>底层异常层层往上抛出，最外层捕获异常，记录下异常信息，并响应适合用户观看的信息进行提示</p><p>有多个异常的时候，直接抛Exception，这样不用多个异常写多个异常的种类</p><p>然后catch的时候，也就catch Exception类就行了</p><h3 id=方案2>方案2<a hidden class=anchor aria-hidden=true href=#方案2>#</a></h3><p>最外层捕获异常后，尝试重新修复</p><h2 id=泛型>泛型<a hidden class=anchor aria-hidden=true href=#泛型>#</a></h2><p>定义类、接口、方法时，同时声明了一个或者多个类型变量（如：）</p><p>称为泛型类、泛型接口，泛型方法、它们统称为泛型。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>ArrayList</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>作用：泛型提供了在编译阶段约束所能操作的数据类型，并自动进行检查的能力！</p><p>泛型的本质：把具体的数据类型作为参数传给类型变量</p><h2 id=泛型类>泛型类<a hidden class=anchor aria-hidden=true href=#泛型类>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>修饰符</span><span class=w> </span><span class=n>class类名</span><span class=o>&lt;</span><span class=n>类型变量</span><span class=err>，</span><span class=n>类型变量</span><span class=err>，…</span><span class=o>&gt;</span><span class=err>｛</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>｝</span><span class=w>
</span></span></span></code></pre></div><p>注意：类型变量建议用大写的英文字母，常用的有：E、T、K、V等</p><h2 id=泛型接口>泛型接口<a hidden class=anchor aria-hidden=true href=#泛型接口>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>修饰符</span><span class=w> </span><span class=kd>interface</span> <span class=nc>接口名</span><span class=o>&lt;</span><span class=n>类型变量</span><span class=err>，</span><span class=n>类型变量</span><span class=err>，</span><span class=p>...</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>｝</span><span class=w>
</span></span></span></code></pre></div><h2 id=泛型方法通配符上下限>泛型方法，通配符，上下限<a hidden class=anchor aria-hidden=true href=#泛型方法通配符上下限>#</a></h2><h3 id=泛型方法>泛型方法<a hidden class=anchor aria-hidden=true href=#泛型方法>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>修饰符</span><span class=o>&lt;</span><span class=n>类型变量</span><span class=err>，</span><span class=n>类型变量</span><span class=err>，…＞</span><span class=n>返回值类型</span><span class=w> </span><span class=n>方法名</span><span class=err>（</span><span class=n>形参列表</span><span class=err>）｛</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>｝</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 泛型方法声明都有一个类型参数声明部分（由尖括号分隔）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=n>test</span><span class=err>（</span><span class=n>T</span><span class=w> </span><span class=n>t</span><span class=err>）｛</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>｝</span><span class=w>
</span></span></span></code></pre></div><h3 id=通配符>通配符<a hidden class=anchor aria-hidden=true href=#通配符>#</a></h3><p>就是“？”，可以在“使用泛型”的时候代表一切类型；ET KV 是在定义泛型的时候使用。</p><h3 id=泛型的上下限>泛型的上下限<a hidden class=anchor aria-hidden=true href=#泛型的上下限>#</a></h3><p>• 泛型上限：？extends Car：？能接收的必须是Car或者其子类。</p><p>• 泛型下限：？super Car：？能接收的必须是Car或者其父类。</p><h2 id=泛型支持的类型>泛型支持的类型<a hidden class=anchor aria-hidden=true href=#泛型支持的类型>#</a></h2><p>泛型不支持基本数据类型，只能支持对象类型（引用数据类型）</p><p>泛型擦除：泛型工作在编译阶段，等编译后泛型就没用了，所以泛型在编译后都会被擦除。所有类型会恢复成Object类型，Object一定要指向一个对象</p><h3 id=包装类>包装类<a hidden class=anchor aria-hidden=true href=#包装类>#</a></h3><p>包装类就是把基本类型的数据包装成对象的类型</p><p>Integer把-128-127先缓存起来了</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Integer</span><span class=w> </span><span class=n>it1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Integer</span><span class=p>.</span><span class=na>valueof</span><span class=p>(</span><span class=n>100</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Integer</span><span class=w> </span><span class=n>it3</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>100</span><span class=p>;</span><span class=c1>//和第一句一样的，自动装箱，变成对象</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Integer</span><span class=w> </span><span class=n>it2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Integer</span><span class=p>.</span><span class=na>valueof</span><span class=p>(</span><span class=n>100</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>it1</span><span class=o>==</span><span class=n>it2</span><span class=p>);</span><span class=c1>//true </span><span class=w>
</span></span></span></code></pre></div><p>自动装箱：基本数据类型可以自动转换为包装类型。</p><p>自动拆箱：包装类型可以自动转换为基本数据类型。</p><h3 id=包装类的其他功能>包装类的其他功能<a hidden class=anchor aria-hidden=true href=#包装类的其他功能>#</a></h3><p>可以把基本类型的数据转换成字符串类型。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=nf>toString</span><span class=p>(</span><span class=kt>double</span><span class=w> </span><span class=n>d</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=nf>toString</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//功能比较鸡肋，一般转成字符串会用</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>String</span><span class=w> </span><span class=n>s1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>123</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34;&#34;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>可以把字符串类型的数值转换成数值本身对应的真实数据类型（这个重要）</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>parselnt</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>s</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=n>Integer</span><span class=w> </span><span class=nf>valueOf</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>s</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></div><h2 id=集合框架>集合框架<a hidden class=anchor aria-hidden=true href=#集合框架>#</a></h2><p>集合是一种容器，用来装数据的，类似于数组，但集合的大小可变，开发中也非常常用</p><h3 id=集合体系结构>集合体系结构<a hidden class=anchor aria-hidden=true href=#集合体系结构>#</a></h3><p>集合的结构分成了两类</p><h2 id=collection-单列集合>Collection-单列集合<a hidden class=anchor aria-hidden=true href=#collection-单列集合>#</a></h2><p>每个元素（数据）只包含一个值</p><p>常用功能</p><table><thead><tr><th><strong>方法名</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>public boolean add(E e)</td><td>把给定的对象添加到当前集合中</td></tr><tr><td>public void clear()</td><td>清空集合中所有的元素</td></tr><tr><td>public boolean remove(E e)</td><td>把给定的对象在当前集合中删除</td></tr><tr><td>public boolean contains(Object obj)</td><td>判断当前集合中是否包含给定的对象</td></tr><tr><td>public boolean isEmpty()</td><td>判断当前集合是否为空</td></tr><tr><td>public int size()</td><td>返回集合中元素的个数。</td></tr><tr><td>public Object[] toArray()</td><td>把集合中的元素，存储到数组中，默认转换成Object数组</td></tr></tbody></table><p><strong>Collection的遍历方式1：迭代器遍历</strong></p><p>next() 函数默认是在第一个元素的位置，先取值在去到下一个元素位置</p><p>hasnext() 函数是判断当前位置是否有元素</p><p>获取迭代器</p><table><thead><tr><th><strong>方法名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>Iterator <strong>iterator()</strong></td><td>返回集合中的迭代器对象，该迭代器对象默认指向当前集合的第一个元素</td></tr></tbody></table><p>迭代器中常用的方法</p><table><thead><tr><th><strong>方法名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>boolean hasNext()</td><td>询问当前位置是否有元素存在，存在返回true ,不存在返回false</td></tr><tr><td>E next()</td><td>获取当前位置的元素，并同时将迭代器对象指向下一个元素处。</td></tr></tbody></table><p><strong>Collection的遍历方式2：增强for循环</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>元素的数据类型</span><span class=w> </span><span class=n>变量名</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>数组或者集合</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>增强for可以用来遍历集合或者数组</p><p>增强for遍历集合，本质就是迭代器遍历集合的简化写法</p><p>快捷方式 数组/集合名.for</p><p>底层就是基于迭代器</p><p><strong>Collection的遍历方式3：Lambda表达式</strong></p><p>要使用如下方法来完成</p><table><thead><tr><th><strong>方法名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>default void forEach(Consumer&lt;? super T> action)</td><td>结合lambda遍历集合</td></tr></tbody></table><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>//遍历方式3：使用Lambda表达式</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>list</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ArrayList</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>list</span><span class=p>.</span><span class=na>add</span><span class=p>(</span><span class=s>&#34;张三&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>list</span><span class=p>.</span><span class=na>add</span><span class=p>(</span><span class=s>&#34;李四&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>list</span><span class=p>.</span><span class=na>add</span><span class=p>(</span><span class=s>&#34;王五&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>list</span><span class=p>.</span><span class=na>add</span><span class=p>(</span><span class=s>&#34;赵6&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>list</span><span class=p>.</span><span class=na>forEach</span><span class=p>(</span><span class=n>s</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>s</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>list</span><span class=p>.</span><span class=na>forEach</span><span class=p>(</span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>::</span><span class=n>println</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h3 id=三种遍历的区别>三种遍历的区别<a hidden class=anchor aria-hidden=true href=#三种遍历的区别>#</a></h3><p>认识并发修改异常问题</p><p>遍历集合的同时又存在增删集合元素的行为时可能出现业务异常，这种现象被称之为并发修改异常问题。</p><p>for循环删除元素没删干净的本质原因是：删除一个元素后，后边一个元素立马补上来，导致了漏删</p><p>解决方案1：删除元素后做一步i&ndash;</p><p>解决方案2：倒着遍历删除（前提是支持索引），原因是后边的元素补过来都是判断后不用删的，而顺着遍历前边的元素补上来不知道是否要删除</p><p>1、迭代器遍历并删除存在并发修改异常问题，解决方案：使用迭代器自己的删除方法</p><p>2、增强for和lambda都没办法解决并发修改异常问题，他们只适合做遍历，不适合做增删</p><p>如果知道索引可以使用i&ndash;的方式解决，如果不知道索引，就用迭代器的删除功能</p><h3 id=list系列集合添加的元素是有序可重复有索引>List系列集合：添加的元素是有序、可重复、有索引<a hidden class=anchor aria-hidden=true href=#list系列集合添加的元素是有序可重复有索引>#</a></h3><p>List集合因为支持索引，所以多了很多与索引相关的方法，当然，Collection的功能List也都继承了。</p><table><thead><tr><th><strong>方法名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>void add(int index,E element)</td><td>在此集合中的指定位置插入指定的元素</td></tr><tr><td>E remove(int index)</td><td>删除指定索引处的元素，返回被删除的元素</td></tr><tr><td>E set(int index,E element)</td><td>修改指定索引处的元素，返回被修改的元素</td></tr><tr><td>E get(int index)</td><td>返回指定索引处的元素</td></tr></tbody></table><p><strong>ArrayList、LinekdList：有序、可重复、有索引</strong></p><h4 id=arraylist底层是基于数组存储数据的>ArrayList底层是基于数组存储数据的<a hidden class=anchor aria-hidden=true href=#arraylist底层是基于数组存储数据的>#</a></h4><p>数组的特点</p><p>查询速度快（注意：是根据索引查询数据快）：查询数据通过地址值和索引定位，查询任意数据耗时相同。</p><p>增删数据效率低：可能需要把后面很多的数据进行前移。</p><p>第一次创建的时候是创建一个空数组，第一次添加的时候才扩容为初始大小为10的数组，二次添加后，会添加成之前的1.5倍</p><h4 id=linkedlist底层是基于链表存储数据的>LinkedList底层是基于链表存储数据的<a hidden class=anchor aria-hidden=true href=#linkedlist底层是基于链表存储数据的>#</a></h4><p>链表的特点</p><p>链表中的数据是一个一个独立的结点组成的，结点在内存中是不连续的，每个结点包含数据值和下一个结点的地址。是基于双链表实现的，特点：对首尾元素进行增删改查的速度是极快的，占用的内存更多</p><p>LinkedList新增了：很多首尾操作的特有方法。</p><p>链表的特点1：查询慢，无论查询哪个数据都要从头开始找。</p><p>链表的特点2：链表增删相对快</p><p>只需要一个的对象可以用static修饰</p><h3 id=set系列集合添加的元素是无序不重复无索引>Set系列集合：添加的元素是无序、不重复、无索引<a hidden class=anchor aria-hidden=true href=#set系列集合添加的元素是无序不重复无索引>#</a></h3><p>HashSet： 无序、不重复、无索引</p><p>LinkedHashSet： 有序、不重复、无索引</p><p>TreeSet：按照大小默认升序排序、不重复、无索引</p><h2 id=map-双列集合>Map-双列集合<a hidden class=anchor aria-hidden=true href=#map-双列集合>#</a></h2><p>每个元素包含两个值（键值对）</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://wqnm1gb.github.io/tags/java%E5%9F%BA%E7%A1%80/>Java基础</a></li></ul><nav class=paginav><a class=prev href=https://wqnm1gb.github.io/posts/day12-mapstream%E6%B5%81/><span class=title>« 上一页</span><br><span>Day12 Map、Stream流</span>
</a><a class=next href=https://wqnm1gb.github.io/posts/day10-arraylist%E9%9B%86%E5%90%88/><span class=title>下一页 »</span><br><span>Day10 ArrayList集合</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://wqnm1gb.github.io/>三狗子的博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>