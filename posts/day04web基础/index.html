<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Day04 Web基础 | 三狗子的博客</title>
<meta name=keywords content="java Web"><meta name=description content="

SpringBoot Web入门
Spring
官网：spring.io
Spring发展到今天已经形成了一种开发生态圈，Spring提供了若干个子项目，每个项目用于完成特定的功能，他们最底层都是基于Spring Framework"><meta name=author content="冷漠三狗子丶"><link rel=canonical href=https://wqnm1gb.github.io/posts/day04web%E5%9F%BA%E7%A1%80/><link crossorigin=anonymous href=/assets/css/stylesheet.3d688279d829dc24da48acd11f9e33ebea2f39c035e899e1bf4297d8b7aa89b9.css integrity="sha256-PWiCedgp3CTaSKzRH54z6+ovOcA16Jnhv0KX2Leqibk=" rel="preload stylesheet" as=style><link rel=icon href=https://wqnm1gb.github.io/images/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://wqnm1gb.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wqnm1gb.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wqnm1gb.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://wqnm1gb.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://wqnm1gb.github.io/posts/day04web%E5%9F%BA%E7%A1%80/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel=stylesheet><script type=text/javascript async src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["[[","]]"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=" has-jax"})</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style><meta property="og:title" content="Day04 Web基础"><meta property="og:description" content="

SpringBoot Web入门
Spring
官网：spring.io
Spring发展到今天已经形成了一种开发生态圈，Spring提供了若干个子项目，每个项目用于完成特定的功能，他们最底层都是基于Spring Framework"><meta property="og:type" content="article"><meta property="og:url" content="https://wqnm1gb.github.io/posts/day04web%E5%9F%BA%E7%A1%80/"><meta property="og:image" content="https://wqnm1gb.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-03-06T10:02:42+08:00"><meta property="article:modified_time" content="2025-03-06T10:02:42+08:00"><meta property="og:site_name" content="三狗子的博客"><meta property="fb:admins" content="your-facebook-admin-id"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wqnm1gb.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Day04 Web基础","item":"https://wqnm1gb.github.io/posts/day04web%E5%9F%BA%E7%A1%80/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Day04 Web基础","name":"Day04 Web基础","description":" SpringBoot Web入门 Spring 官网：spring.io\nSpring发展到今天已经形成了一种开发生态圈，Spring提供了若干个子项目，每个项目用于完成特定的功能，他们最底层都是基于Spring Framework\n","keywords":["java Web"],"articleBody":" SpringBoot Web入门 Spring 官网：spring.io\nSpring发展到今天已经形成了一种开发生态圈，Spring提供了若干个子项目，每个项目用于完成特定的功能，他们最底层都是基于Spring Framework\nSpring Boot简化配置，可以快速开发，对比起Spring Framework\nSpringBoot入门程序 创建一个项目：\n项目结构：\n新建的文件可以放在zzzyj里边\n入门程序：\n@RestController //标识当前类是一个请求处理类 public class HelloController { @RequestMapping (\"/hello\")//标识请求路径 public String hello(String name){ System.out.println(\"name:\"+name); return \"hello:\"+name+\"~\"; } } “脚手架”（Scaffold）通常指的是一个自动生成的项目结构和基础代码框架。它帮助开发者快速搭建项目的初始结构，减少重复性的基础工作。\n连接不上的解决方法\n入门程序解析 为什么main方法能将程序启动起来\n运行起来tomcat\nhttp协议 概念：Hyper Text Transfer Protocol，超文本传输协议，规定了浏览器和服务器之间数据传输的规则。\n特点：\n基于TCP协议：面向连接，安全 基于请求-响应模型的：一次请求对应一次晌应 HTTP协议是无状态的协议：对于事务处理没有记忆能力。每次请求-响应都是独立的 • 缺点：多次请求间不能共享数据\n• 优点：速度快\nhttp请求协议 请求方式-GET：请求参数在请求行中，没有请求体，如：/brand/findAlL?name=OPPO\u0026status=1。GET请求大小在浏览器中是有限制的。\n请求方式-POST：请求参数在请求体中，POST请求大小是没有限制的。\n请求头和请求体之间有一个空行隔开\nGET方式一般没有请求体，POST传递的数据在请求体中\nHost 请求的主机名 User-Agent 浏览器版本，例如Chrome浏览器的标识类似Mozilla/5.0 … Chrome/79，IE浏览器的标识类似****Mozilla/5.0 (Windows NT …) like Gecko Accept 表示浏览器能接收的资源类型，如****text/***，****image/或者/***表示所有； Accept-Language 表示浏览器偏好的语言，服务器可以据此返回不同语言的网页； Accept-Encoding 表示浏览器可以支持的压缩类型，例如gzip, deflate****等。 Content-Type 请求主体的数据类型。 Content-Length 请求主体的大小（单位：字节）。 请求数据的获取 Web服务器（Tomcat）对HTTP协议的请求数据进行解析，并进行了封装（HttpServletRequest），在调用Controller方法的时候传递给了该方法。这样，就使得程序员不必直接对协议进行操作，让web开发更加便捷。\n@RestController public class RequestController { @RequestMapping(\"/request\") public String reques(HttpServletRequest request){ // 获取请求方法 String method = request.getMethod(); System.out.println(\"method:\"+method); // 获取请求参数 String name1 = request.getParameter(\"name\"); String name2 = request.getParameter(\"age\"); System.out.println(\"name:\"+name1); System.out.println(\"age:\"+name2); // 获取请求路径url和uri String url = request.getRequestURL().toString(); // 这是一个完整的路径 String uri = request.getRequestURI(); // 这是后边的相对路径 System.out.println(\"url:\"+url); System.out.println(\"uri:\"+uri); // 获取请求体 String header = request.getHeader(\"User-Agent\"); System.out.println(\"header = \" + header); return \"ok\"; } } http响应数据 响应码：\n1xx 响应中-临时状态码，表示请求已经接收，告诉客户端应该继续请求或者如果它已经完成则忽略它。 2xx 成功-表示请求已经被成功接收，处理已完成。 3xx 重定向-重定向到其他地方；让客户端再发起一次请求以完成整个处理。 4xx 客户端错误-处理发生错误，责任在客户端。如: 请求了不存在的资源、客户端未被授权、禁止访问等。 5xx 服务器错误-处理发生错误，责任在服务端。如：程序抛出异常等。 响应头：\nContent-Type 表示该响应内容的类型，例如text/html，application/json。 Content-Length 表示该响应内容的长度（字节数）。 Content-Encoding 表示该响应压缩算法，例如gzip。 Cache-Control 指示客户端应如何缓存，例如max-age=300表示可以最多缓存300秒。 Set-Cookie 告诉浏览器为当前页面所在的域设置cookie。 响应数据的设置 @RestController public class ResponseController { @RequestMapping(\"/response\") public void response(HttpServletResponse response) throws IOException { // 设置响应状态码 response.setStatus(401); // 设置响应头 response.setHeader(\"zzzzyj\",\"哈哈哈\"); // 设置响应体 response.getWriter().write(\"hello,response\"); } @RequestMapping(\"/response2\") public ResponseEntity\u003cString\u003e response2(){ // spring提供的 return ResponseEntity.status(401) .header(\"zzzzyj\",\"xixixi\") .body(\"hello,response\"); } } 响应状态码 和 响应头如果没有特殊要求的话，通常不手动设定。服务器会根据请求处理的逻辑，自动设置响应状态码和响应头。\nSpringBoot案例 构建项目的时候，需要勾选上lombok依赖，这个就是之前在javase中学习的@Data注解，可以直接有getset和构造器方法\n返回的数据之所以可以是json格式，是因为加了注解@RestController，他的底层还有一个注解@ResponseBody 作用：将controller返回值直接作为响应体的数据直接响应；返回值是对象/集合-\u003ejson-\u003e再响应\n@RestController public class UserController { // 当访问list的时候，就会读取txt文件返回数据，加载到html页面中 @RequestMapping(\"/list\") public List\u003cUser\u003e list(){ // 1、加载并读取文件 InputStream in = this.getClass().getClassLoader().getResourceAsStream(\"user.txt\"); ArrayList\u003cString\u003e lines = IoUtil.readLines(in, StandardCharsets.UTF_8, new ArrayList\u003c\u003e()); // 2、解析数据，封装成对象 --\u003e集合 List\u003cUser\u003e userList = lines.stream().map(line -\u003e { String[] parts = line.split(\",\"); Integer id = Integer.parseInt(parts[0]); String username = parts[1]; String password = parts[2]; String name = parts[3]; Integer age = Integer.parseInt(parts[4]); LocalDateTime updateTime = LocalDateTime.parse(parts[5], DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\")); return new User(id, username, password, name, age, updateTime); // 流的终结方法，打回集合 }).collect(Collectors.toList()); // 3、响应数据 return userList; } } 分层解耦 三层架构 单一职责原则\ncontroller：控制层，接收前端发送的请求，对请求进行处理，并响应数据。\nservice：业务逻辑层，处理具体的业务逻辑。\ndao：数据访问层（Data Access Object）（持久层），负责数据访问操作，包括数据的增、删、改、查。\n转换后的代码\n分层解耦 耦合：衡量软件中各个层/各个模块的依赖关联程度。\n内聚：软件中各个功能模块内部的功能联系。\n软件设计原则：高内聚低耦合。\n因为用new创建了对象，所以是高耦合\n控制反转： Inversion Of Control，简称IOC。对象的创建控制权由程序自身转移到外部（容器），这种思想称为控制反转。\n依赖注入：Dependency Injection，简称DI。容器为应用程序提供运行时，所依赖的资源，称之为依赖注入。\nBean对象：IOC容器中创建、管理的对象，称之为Bean。\nIOC\u0026DI入门 1、将Dao 及 Service层的实现类，交给IOC容器管理。\n2、为Controller 及 Service注入运行时所依赖的对象。\nIOC详解 要把某个对象交给IOC容器管理，需要在对应类中加上下列注解之一：\n注解 说明 位置 @Component 声明bean的基础注解 不属于以下三类时，用此注解 @Controller @Component的衍生注解 标注在控制层类上(@RestController中包含了@Controller) @Service @Component的衍生注解 标注在业务层类上 @Repository @Component的衍生注解 标注在数据访问层类上（由于与mybatis整合，用的少） 不指定Bean的名字默认是类名首字母小写\n使用以上四个注解都可以声明bean，但是在springboot集成web开发中，声明控制器bean只能用@Controller。\n前面声明bean的四大注解，要想生效，还需要被组件扫描注解@ComponentScan扫描。\n该注解虽然没有显式配置，但是实际上已经包含在了启动类声明注解@SpringBootAppljcatjon 中，默认扫描的范围是启动类所在包及其子包。\nDI详解 @Autowired注解，默认是按照类型进行自动装配的（去IOC容器中找某个类型的对象，然后完成注入操作）\n入门程序举例：在EmpController运行的时候，就要到IOC容器当中去查找EmpService这个类型的对象，而我们的IOC容器中刚好有一个EmpService这个类型的对象，所以就找到了这个类型的对象完成注入操作。\n三种注解形式\n方式1：属性注入\n@RestController public class UserController { @Autowired private UserService userService; //...... } 优点：代码简洁、方便快速开发。\n缺点：隐藏了类之间的依赖关系、可能会破坏类的封装性。\n方式一破坏了类的封装性，因为封装性要求私有成员变量却没有提供get和set方法\n方式2：构造器注入\n@RestController public class UserController { //方式二: 构造器注入 private final UserService userService; @Autowired //如果当前类中只存在一个构造函数, @Autowired可以省略 public UserController(UserService userService) { this.userService = userService; } } 优点：能清晰地看到类的依赖关系、提高了代码的安全性。\n缺点：代码繁琐、如果构造参数过多，可能会导致构造函数臃肿。\n注意：如果只有一个构造函数，@Autowired注解可以省略。\n方式3：setter注入\n/** * 用户信息Controller */ @RestController public class UserController { //方式三: setter注入 private UserService userService; @Autowired public void setUserService(UserService userService) { this.userService = userService; } } 优点：保持了类的封装性，依赖关系更清晰。\n缺点：需要额外编写setter方法，增加了代码量。\n一般使用的比较多的是方式1和方式2\n@Autowired注解，默认是按照类型进行注入的。\n如果存在多个相同类型的bean，将会报出如下错误：\n解决方式1：使用@Primary注解\n注意注释的地方是在类的上边\n@Primary @Service public class UserServiceImpl implements UserService { } 解决方式2：使用@Qualifier注解\n指定当前要注入的bean对象。 在@Qualifier的value属性中，指定注入的bean的名称。 @Qualifier注解不能单独使用，必须配合@Autowired使用。\n@RestController public class UserController { @Qualifier(\"userServiceImpl\") @Autowired private UserService userService; 解决方式3：使用@Resource注解\n是按照bean的名称进行注入。通过name属性指定要注入的bean的名称。\n@RestController public class UserController { @Resource(name = \"userServiceImpl\") private UserService userService; @Resource 与 @Autowired区别？ • @Autowired是Spring框架提供的注解，而@Resource是JavaEE规范提供的\n• @Autowired默认是按照类型注入，而@Resource默认是按照名称注入\n","wordCount":"3768","inLanguage":"zh","image":"https://wqnm1gb.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-03-06T10:02:42+08:00","dateModified":"2025-03-06T10:02:42+08:00","author":{"@type":"Person","name":"冷漠三狗子丶"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wqnm1gb.github.io/posts/day04web%E5%9F%BA%E7%A1%80/"},"publisher":{"@type":"Organization","name":"三狗子的博客","logo":{"@type":"ImageObject","url":"https://wqnm1gb.github.io/images/favicon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wqnm1gb.github.io/ accesskey=h title="主页 (Alt + H)"><img src=https://wqnm1gb.github.io/apple-touch-icon.png alt aria-label=logo height=35>主页</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wqnm1gb.github.io/ title=三狗子的博客><span>首页</span></a></li><li><a href=https://wqnm1gb.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://wqnm1gb.github.io/categories/ title=Categories><span>分类</span></a></li><li><a href=https://wqnm1gb.github.io/tags/ title=Tags><span>标签</span></a></li><li><a href=https://wqnm1gb.github.io/search/ title=搜索><span>搜索</span></a></li><li><a href=https://wqnm1gb.github.io/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://wqnm1gb.github.io/>主页</a>&nbsp;»&nbsp;<a href=https://wqnm1gb.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Day04 Web基础</h1><div class=post-meta><span title='2025-03-06 10:02:42 +0800 +0800'>三月 6, 2025</span>&nbsp;·&nbsp;8 分钟&nbsp;·&nbsp;3768 字&nbsp;·&nbsp;冷漠三狗子丶</div></header><div class=post-content><p><img loading=lazy src=/images/Day04Web%e5%9f%ba%e7%a1%80.assets/1731977559201-73e5a329-2595-4cae-bff1-05bfe1edee42-20250224204642352.png alt></p><h1 id=springboot-web入门>SpringBoot Web入门<a hidden class=anchor aria-hidden=true href=#springboot-web入门>#</a></h1><h2 id=spring>Spring<a hidden class=anchor aria-hidden=true href=#spring>#</a></h2><p>官网：<a href=https://spring.io/>spring.io</a></p><p>Spring发展到今天已经形成了一种开发生态圈，Spring提供了若干个子项目，每个项目用于完成特定的功能，他们最底层都是基于Spring Framework</p><p><img loading=lazy src=/images/Day04Web%e5%9f%ba%e7%a1%80.assets/1731977939876-1cb91577-8431-4231-800e-46a69d15f9b6-20250224204645375.png alt></p><p>Spring Boot简化配置，可以快速开发，对比起Spring Framework</p><h2 id=springboot入门程序>SpringBoot入门程序<a hidden class=anchor aria-hidden=true href=#springboot入门程序>#</a></h2><p>创建一个项目：</p><p><img loading=lazy src=/images/Day04Web%e5%9f%ba%e7%a1%80.assets/1731978995743-25569ad7-8091-41d0-a054-fc5e20f9b6fd-20250224204647559.png alt></p><p>项目结构：</p><p><img loading=lazy src=/images/Day04Web%e5%9f%ba%e7%a1%80.assets/1731979125955-155617f2-f6d1-4384-902c-1cc94dd35452-20250224204649478.png alt>
新建的文件可以放在zzzyj里边</p><p>入门程序：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=err>@</span><span class=nx>RestController</span> <span class=c1>//标识当前类是一个请求处理类
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>public</span> <span class=kr>class</span> <span class=nx>HelloController</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=err>@</span><span class=nx>RequestMapping</span> <span class=p>(</span><span class=s2>&#34;/hello&#34;</span><span class=p>)</span><span class=c1>//标识请求路径
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kr>public</span> <span class=nb>String</span> <span class=nx>hello</span><span class=p>(</span><span class=nb>String</span> <span class=nx>name</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=nx>System</span><span class=p>.</span><span class=nx>out</span><span class=p>.</span><span class=nx>println</span><span class=p>(</span><span class=s2>&#34;name:&#34;</span><span class=o>+</span><span class=nx>name</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s2>&#34;hello:&#34;</span><span class=o>+</span><span class=nx>name</span><span class=o>+</span><span class=s2>&#34;~&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>“脚手架”（Scaffold）通常指的是一个自动生成的项目结构和基础代码框架。它帮助开发者快速搭建项目的初始结构，减少重复性的基础工作。</p><p>连接不上的解决方法</p><p><img loading=lazy src=/images/Day04Web%e5%9f%ba%e7%a1%80.assets/1731981813306-2a7b0a66-3ef5-4bfa-92e0-70a1922b477f-20250224204651888.png alt></p><h3 id=入门程序解析>入门程序解析<a hidden class=anchor aria-hidden=true href=#入门程序解析>#</a></h3><p>为什么main方法能将程序启动起来</p><p><img loading=lazy src=/images/Day04Web%e5%9f%ba%e7%a1%80.assets/1731982388065-4ff3ca3d-cf21-4799-a854-59c491408448-20250224204653780.png alt></p><p>运行起来tomcat</p><p><img loading=lazy src=/images/Day04Web%e5%9f%ba%e7%a1%80.assets/1731982417280-30a4a135-6843-4d33-921f-52f25c2a62bf-20250224204655800.png alt></p><h1 id=http协议>http协议<a hidden class=anchor aria-hidden=true href=#http协议>#</a></h1><p>概念：Hyper Text Transfer Protocol，超文本传输协议，规定了浏览器和服务器之间数据传输的规则。</p><p><img loading=lazy src=/images/Day04Web%e5%9f%ba%e7%a1%80.assets/1731982946259-0f85eada-5394-4b1a-aed6-130dae066adf-20250224204700332.png alt></p><p>特点：</p><ol><li>基于TCP协议：面向连接，安全</li><li>基于请求-响应模型的：一次请求对应一次晌应</li><li>HTTP协议是无状态的协议：对于事务处理没有记忆能力。每次请求-响应都是独立的</li></ol><p>• 缺点：多次请求间不能共享数据</p><p>• 优点：速度快</p><h2 id=http请求协议>http请求协议<a hidden class=anchor aria-hidden=true href=#http请求协议>#</a></h2><p><img loading=lazy src=/images/Day04Web%e5%9f%ba%e7%a1%80.assets/1731983414970-5ef236f5-4371-4a90-93ef-2ca9fb33d50e-20250224204702721.png alt></p><p>请求方式-GET：请求参数在请求行中，没有请求体，如：/brand/findAlL?name=OPPO&amp;status=1。GET请求大小在浏览器中是有限制的。</p><p>请求方式-POST：请求参数在请求体中，POST请求大小是没有限制的。</p><p>请求头和请求体之间有一个空行隔开</p><p>GET方式一般没有请求体，POST传递的数据在请求体中</p><table><thead><tr><th style=text-align:center><strong>Host</strong></th><th style=text-align:left><strong>请求的主机名</strong></th></tr></thead><tbody><tr><td style=text-align:center><strong>User-Agent</strong></td><td style=text-align:left><strong>浏览器版本，例如<strong><strong>Chrome</strong></strong>浏览器的标识类似<strong><strong>Mozilla/5.0 &mldr; Chrome/79</strong></strong>，<strong><strong>IE</strong></strong>浏览器的标识类似****Mozilla/5.0 (Windows NT &mldr;) like Gecko</strong></td></tr><tr><td style=text-align:center><strong>Accept</strong></td><td style=text-align:left><strong>表示浏览器能接收的资源类型，如****text/</strong>***，****image/<em><strong><strong>或者</strong></strong></em>/***<strong>表示所有；</strong></td></tr><tr><td style=text-align:center><strong>Accept-Language</strong></td><td style=text-align:left><strong>表示浏览器偏好的语言，服务器可以据此返回不同语言的网页；</strong></td></tr><tr><td style=text-align:center><strong>Accept-Encoding</strong></td><td style=text-align:left><strong>表示浏览器可以支持的压缩类型，例如<strong><strong>gzip</strong></strong>, deflate****等。</strong></td></tr><tr><td style=text-align:center><strong>Content-Type</strong></td><td style=text-align:left><strong>请求主体的数据类型。</strong></td></tr><tr><td style=text-align:center><strong>Content-Length</strong></td><td style=text-align:left><strong>请求主体的大小（单位：字节）。</strong></td></tr></tbody></table><h3 id=请求数据的获取>请求数据的获取<a hidden class=anchor aria-hidden=true href=#请求数据的获取>#</a></h3><p>Web服务器（Tomcat）对HTTP协议的请求数据进行解析，并进行了封装（HttpServletRequest），在调用Controller方法的时候传递给了该方法。这样，就使得程序员不必直接对协议进行操作，让web开发更加便捷。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=err>@</span><span class=nx>RestController</span>
</span></span><span class=line><span class=cl><span class=kr>public</span> <span class=kr>class</span> <span class=nx>RequestController</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=err>@</span><span class=nx>RequestMapping</span><span class=p>(</span><span class=s2>&#34;/request&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=kr>public</span> <span class=nb>String</span> <span class=nx>reques</span><span class=p>(</span><span class=nx>HttpServletRequest</span> <span class=nx>request</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 获取请求方法
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nb>String</span> <span class=nx>method</span> <span class=o>=</span> <span class=nx>request</span><span class=p>.</span><span class=nx>getMethod</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=nx>System</span><span class=p>.</span><span class=nx>out</span><span class=p>.</span><span class=nx>println</span><span class=p>(</span><span class=s2>&#34;method:&#34;</span><span class=o>+</span><span class=nx>method</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// 获取请求参数
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nb>String</span> <span class=nx>name1</span> <span class=o>=</span> <span class=nx>request</span><span class=p>.</span><span class=nx>getParameter</span><span class=p>(</span><span class=s2>&#34;name&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nb>String</span> <span class=nx>name2</span> <span class=o>=</span> <span class=nx>request</span><span class=p>.</span><span class=nx>getParameter</span><span class=p>(</span><span class=s2>&#34;age&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nx>System</span><span class=p>.</span><span class=nx>out</span><span class=p>.</span><span class=nx>println</span><span class=p>(</span><span class=s2>&#34;name:&#34;</span><span class=o>+</span><span class=nx>name1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nx>System</span><span class=p>.</span><span class=nx>out</span><span class=p>.</span><span class=nx>println</span><span class=p>(</span><span class=s2>&#34;age:&#34;</span><span class=o>+</span><span class=nx>name2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// 获取请求路径url和uri
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nb>String</span> <span class=nx>url</span> <span class=o>=</span> <span class=nx>request</span><span class=p>.</span><span class=nx>getRequestURL</span><span class=p>().</span><span class=nx>toString</span><span class=p>();</span> <span class=c1>// 这是一个完整的路径
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nb>String</span> <span class=nx>uri</span> <span class=o>=</span> <span class=nx>request</span><span class=p>.</span><span class=nx>getRequestURI</span><span class=p>();</span> <span class=c1>// 这是后边的相对路径
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>System</span><span class=p>.</span><span class=nx>out</span><span class=p>.</span><span class=nx>println</span><span class=p>(</span><span class=s2>&#34;url:&#34;</span><span class=o>+</span><span class=nx>url</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nx>System</span><span class=p>.</span><span class=nx>out</span><span class=p>.</span><span class=nx>println</span><span class=p>(</span><span class=s2>&#34;uri:&#34;</span><span class=o>+</span><span class=nx>uri</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// 获取请求体
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nb>String</span> <span class=nx>header</span> <span class=o>=</span> <span class=nx>request</span><span class=p>.</span><span class=nx>getHeader</span><span class=p>(</span><span class=s2>&#34;User-Agent&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nx>System</span><span class=p>.</span><span class=nx>out</span><span class=p>.</span><span class=nx>println</span><span class=p>(</span><span class=s2>&#34;header = &#34;</span> <span class=o>+</span> <span class=nx>header</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s2>&#34;ok&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><img loading=lazy src=/images/Day04Web%e5%9f%ba%e7%a1%80.assets/1731984683782-d00895ac-337b-44e9-8351-f94121d42f9f.png alt></p><h2 id=http响应数据>http响应数据<a hidden class=anchor aria-hidden=true href=#http响应数据>#</a></h2><p><img loading=lazy src=/images/Day04Web%e5%9f%ba%e7%a1%80.assets/1731986120423-ded68bf5-a7dc-40f9-9a88-0d7a32ae5b68-20250224204706513.png alt></p><p>响应码：</p><table><thead><tr><th style=text-align:center>1xx</th><th style=text-align:left>响应中-临时状态码，表示请求已经接收，告诉客户端应该继续请求或者如果它已经完成则忽略它。</th></tr></thead><tbody><tr><td style=text-align:center>2xx</td><td style=text-align:left>成功-表示请求已经被成功接收，处理已完成。</td></tr><tr><td style=text-align:center>3xx</td><td style=text-align:left>重定向-重定向到其他地方；让客户端再发起一次请求以完成整个处理。</td></tr><tr><td style=text-align:center>4xx</td><td style=text-align:left>客户端错误-处理发生错误，责任在客户端。如: 请求了不存在的资源、客户端未被授权、禁止访问等。</td></tr><tr><td style=text-align:center>5xx</td><td style=text-align:left>服务器错误-处理发生错误，责任在服务端。如：程序抛出异常等。</td></tr></tbody></table><p>响应头：</p><table><thead><tr><th style=text-align:center>Content-Type</th><th style=text-align:left>表示该响应内容的类型，例如text/html，application/json。</th></tr></thead><tbody><tr><td style=text-align:center>Content-Length</td><td style=text-align:left>表示该响应内容的长度（字节数）。</td></tr><tr><td style=text-align:center>Content-Encoding</td><td style=text-align:left>表示该响应压缩算法，例如gzip。</td></tr><tr><td style=text-align:center>Cache-Control</td><td style=text-align:left>指示客户端应如何缓存，例如max-age=300表示可以最多缓存300秒。</td></tr><tr><td style=text-align:center>Set-Cookie</td><td style=text-align:left>告诉浏览器为当前页面所在的域设置cookie。</td></tr></tbody></table><h3 id=响应数据的设置>响应数据的设置<a hidden class=anchor aria-hidden=true href=#响应数据的设置>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=err>@</span><span class=nx>RestController</span>
</span></span><span class=line><span class=cl><span class=kr>public</span> <span class=kr>class</span> <span class=nx>ResponseController</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=err>@</span><span class=nx>RequestMapping</span><span class=p>(</span><span class=s2>&#34;/response&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=kr>public</span> <span class=k>void</span> <span class=nx>response</span><span class=p>(</span><span class=nx>HttpServletResponse</span> <span class=nx>response</span><span class=p>)</span> <span class=kr>throws</span> <span class=nx>IOException</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 设置响应状态码
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>response</span><span class=p>.</span><span class=nx>setStatus</span><span class=p>(</span><span class=mi>401</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// 设置响应头
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>response</span><span class=p>.</span><span class=nx>setHeader</span><span class=p>(</span><span class=s2>&#34;zzzzyj&#34;</span><span class=p>,</span><span class=s2>&#34;哈哈哈&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// 设置响应体
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>response</span><span class=p>.</span><span class=nx>getWriter</span><span class=p>().</span><span class=nx>write</span><span class=p>(</span><span class=s2>&#34;&lt;h1&gt;hello,response&lt;/h1&gt;&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=err>@</span><span class=nx>RequestMapping</span><span class=p>(</span><span class=s2>&#34;/response2&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=kr>public</span> <span class=nx>ResponseEntity</span><span class=o>&lt;</span><span class=nb>String</span><span class=o>&gt;</span> <span class=nx>response2</span><span class=p>(){</span> <span class=c1>// spring提供的
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=nx>ResponseEntity</span><span class=p>.</span><span class=nx>status</span><span class=p>(</span><span class=mi>401</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=p>.</span><span class=nx>header</span><span class=p>(</span><span class=s2>&#34;zzzzyj&#34;</span><span class=p>,</span><span class=s2>&#34;xixixi&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=p>.</span><span class=nx>body</span><span class=p>(</span><span class=s2>&#34;&lt;h1&gt;hello,response&lt;/h1&gt;&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>响应状态码 和 响应头如果没有特殊要求的话，通常不手动设定。服务器会根据请求处理的逻辑，自动设置响应状态码和响应头。</p><h1 id=springboot案例>SpringBoot案例<a hidden class=anchor aria-hidden=true href=#springboot案例>#</a></h1><p>构建项目的时候，需要勾选上lombok依赖，这个就是之前在javase中学习的@Data注解，可以直接有getset和构造器方法</p><p>返回的数据之所以可以是json格式，是因为加了注解@RestController，他的底层还有一个注解@ResponseBody 作用：将controller返回值直接作为响应体的数据直接响应；返回值是对象/集合->json->再响应</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=err>@</span><span class=nx>RestController</span>
</span></span><span class=line><span class=cl><span class=kr>public</span> <span class=kr>class</span> <span class=nx>UserController</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 当访问list的时候，就会读取txt文件返回数据，加载到html页面中
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=err>@</span><span class=nx>RequestMapping</span><span class=p>(</span><span class=s2>&#34;/list&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=kr>public</span> <span class=nx>List</span><span class=o>&lt;</span><span class=nx>User</span><span class=o>&gt;</span> <span class=nx>list</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 1、加载并读取文件
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>InputStream</span> <span class=k>in</span> <span class=o>=</span> <span class=k>this</span><span class=p>.</span><span class=nx>getClass</span><span class=p>().</span><span class=nx>getClassLoader</span><span class=p>().</span><span class=nx>getResourceAsStream</span><span class=p>(</span><span class=s2>&#34;user.txt&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nx>ArrayList</span><span class=o>&lt;</span><span class=nb>String</span><span class=o>&gt;</span> <span class=nx>lines</span> <span class=o>=</span> <span class=nx>IoUtil</span><span class=p>.</span><span class=nx>readLines</span><span class=p>(</span><span class=k>in</span><span class=p>,</span> <span class=nx>StandardCharsets</span><span class=p>.</span><span class=nx>UTF_8</span><span class=p>,</span> <span class=k>new</span> <span class=nx>ArrayList</span><span class=o>&lt;&gt;</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// 2、解析数据，封装成对象 --&gt;集合
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>List</span><span class=o>&lt;</span><span class=nx>User</span><span class=o>&gt;</span> <span class=nx>userList</span> <span class=o>=</span> <span class=nx>lines</span><span class=p>.</span><span class=nx>stream</span><span class=p>().</span><span class=nx>map</span><span class=p>(</span><span class=nx>line</span> <span class=o>-&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nb>String</span><span class=p>[]</span> <span class=nx>parts</span> <span class=o>=</span> <span class=nx>line</span><span class=p>.</span><span class=nx>split</span><span class=p>(</span><span class=s2>&#34;,&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=nx>Integer</span> <span class=nx>id</span> <span class=o>=</span> <span class=nx>Integer</span><span class=p>.</span><span class=nb>parseInt</span><span class=p>(</span><span class=nx>parts</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>            <span class=nb>String</span> <span class=nx>username</span> <span class=o>=</span> <span class=nx>parts</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=nb>String</span> <span class=nx>password</span> <span class=o>=</span> <span class=nx>parts</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=nb>String</span> <span class=nx>name</span> <span class=o>=</span> <span class=nx>parts</span><span class=p>[</span><span class=mi>3</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=nx>Integer</span> <span class=nx>age</span> <span class=o>=</span> <span class=nx>Integer</span><span class=p>.</span><span class=nb>parseInt</span><span class=p>(</span><span class=nx>parts</span><span class=p>[</span><span class=mi>4</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>            <span class=nx>LocalDateTime</span> <span class=nx>updateTime</span> <span class=o>=</span> <span class=nx>LocalDateTime</span><span class=p>.</span><span class=nx>parse</span><span class=p>(</span><span class=nx>parts</span><span class=p>[</span><span class=mi>5</span><span class=p>],</span> <span class=nx>DateTimeFormatter</span><span class=p>.</span><span class=nx>ofPattern</span><span class=p>(</span><span class=s2>&#34;yyyy-MM-dd HH:mm:ss&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=k>new</span> <span class=nx>User</span><span class=p>(</span><span class=nx>id</span><span class=p>,</span> <span class=nx>username</span><span class=p>,</span> <span class=nx>password</span><span class=p>,</span> <span class=nx>name</span><span class=p>,</span> <span class=nx>age</span><span class=p>,</span> <span class=nx>updateTime</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 流的终结方法，打回集合
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}).</span><span class=nx>collect</span><span class=p>(</span><span class=nx>Collectors</span><span class=p>.</span><span class=nx>toList</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 3、响应数据
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=nx>userList</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><img loading=lazy src=/images/Day04Web%e5%9f%ba%e7%a1%80.assets/1732070561560-33edb307-3e0b-4ea7-859a-e53c32fc9828-20250224204711288.png alt></p><h1 id=分层解耦>分层解耦<a hidden class=anchor aria-hidden=true href=#分层解耦>#</a></h1><h2 id=三层架构>三层架构<a hidden class=anchor aria-hidden=true href=#三层架构>#</a></h2><p>单一职责原则</p><p><img loading=lazy src=/images/Day04Web%e5%9f%ba%e7%a1%80.assets/1732071733179-18baf39a-077e-4107-8e93-b445730da4cc-20250224204714232.png alt></p><p>controller：控制层，接收前端发送的请求，对请求进行处理，并响应数据。</p><p>service：业务逻辑层，处理具体的业务逻辑。</p><p>dao：数据访问层（Data Access Object）（持久层），负责数据访问操作，包括数据的增、删、改、查。</p><p>转换后的代码</p><p><img loading=lazy src=/images/Day04Web%e5%9f%ba%e7%a1%80.assets/1732071883727-e667e1a3-d287-4509-bd29-a0d7125148e4-20250224204716508.png alt></p><h2 id=分层解耦-1>分层解耦<a hidden class=anchor aria-hidden=true href=#分层解耦-1>#</a></h2><p>耦合：衡量软件中各个层/各个模块的依赖关联程度。</p><p>内聚：软件中各个功能模块内部的功能联系。</p><p>软件设计原则：高内聚低耦合。</p><p><img loading=lazy src=/images/Day04Web%e5%9f%ba%e7%a1%80.assets/1732083515604-3706f08c-9266-4602-9c08-39229f4b25dc-20250224204719443.png alt></p><p>因为用new创建了对象，所以是高耦合</p><p>控制反转： Inversion Of Control，简称IOC。对象的创建控制权由程序自身转移到外部（容器），这种思想称为控制反转。</p><p>依赖注入：Dependency Injection，简称DI。容器为应用程序提供运行时，所依赖的资源，称之为依赖注入。</p><p>Bean对象：IOC容器中创建、管理的对象，称之为Bean。</p><h2 id=iocdi入门>IOC&amp;DI入门<a hidden class=anchor aria-hidden=true href=#iocdi入门>#</a></h2><p>1、将Dao 及 Service层的实现类，交给IOC容器管理。</p><p>2、为Controller 及 Service注入运行时所依赖的对象。</p><p></p><h3 id=ioc详解>IOC详解<a hidden class=anchor aria-hidden=true href=#ioc详解>#</a></h3><p>要把某个对象交给IOC容器管理，需要在对应类中加上下列注解之一：</p><table><thead><tr><th style=text-align:center>注解</th><th style=text-align:center>说明</th><th>位置</th></tr></thead><tbody><tr><td style=text-align:center>@Component</td><td style=text-align:center>声明bean的基础注解</td><td>不属于以下三类时，用此注解</td></tr><tr><td style=text-align:center>@Controller</td><td style=text-align:center>@Component的衍生注解</td><td>标注在控制层类上(@RestController中包含了@Controller)</td></tr><tr><td style=text-align:center>@Service</td><td style=text-align:center>@Component的衍生注解</td><td>标注在业务层类上</td></tr><tr><td style=text-align:center>@Repository</td><td style=text-align:center>@Component的衍生注解</td><td>标注在数据访问层类上（由于与mybatis整合，用的少）</td></tr></tbody></table><p>不指定Bean的名字默认是类名首字母小写</p><p></p><p>使用以上四个注解都可以声明bean，但是在springboot集成web开发中，声明控制器bean只能用@Controller。</p><p>前面声明bean的四大注解，要想生效，还需要被组件扫描注解@ComponentScan扫描。</p><p>该注解虽然没有显式配置，但是实际上已经包含在了启动类声明注解@SpringBootAppljcatjon 中，默认扫描的范围是启动类所在包及其子包。</p><p></p><h3 id=di详解>DI详解<a hidden class=anchor aria-hidden=true href=#di详解>#</a></h3><p><code>&lt;font style="color:rgb(222,120,2);">@Autowired&lt;/font></code>注解，默认是按照<strong>类型</strong>进行自动装配的（去IOC容器中找某个类型的对象，然后完成注入操作）</p><p>入门程序举例：在EmpController运行的时候，就要到IOC容器当中去查找EmpService这个类型的对象，而我们的IOC容器中刚好有一个EmpService这个类型的对象，所以就找到了这个类型的对象完成注入操作。</p><p>三种注解形式</p><p><strong>方式1：属性注入</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@RestController</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>UserController</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Autowired</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>UserService</span><span class=w> </span><span class=n>userService</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>//......</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>优点：代码简洁、方便快速开发。</p><p>缺点：隐藏了类之间的依赖关系、可能会破坏类的封装性。</p><p>方式一破坏了类的封装性，因为封装性要求私有成员变量却没有提供get和set方法</p><p><strong>方式2：构造器注入</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@RestController</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>UserController</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>//方式二: 构造器注入</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>UserService</span><span class=w> </span><span class=n>userService</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Autowired</span><span class=w> </span><span class=c1>//如果当前类中只存在一个构造函数, @Autowired可以省略</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>UserController</span><span class=p>(</span><span class=n>UserService</span><span class=w> </span><span class=n>userService</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=na>userService</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>userService</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=p>}</span><span class=w>   
</span></span></span></code></pre></div><p>优点：能清晰地看到类的依赖关系、提高了代码的安全性。</p><p>缺点：代码繁琐、如果构造参数过多，可能会导致构造函数臃肿。</p><p>注意：如果只有一个构造函数，@Autowired注解可以省略。</p><p><strong>方式3：setter注入</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * 用户信息Controller
</span></span></span><span class=line><span class=cl><span class=cm> */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@RestController</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>UserController</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>//方式三: setter注入</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>UserService</span><span class=w> </span><span class=n>userService</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Autowired</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>setUserService</span><span class=p>(</span><span class=n>UserService</span><span class=w> </span><span class=n>userService</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=na>userService</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>userService</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>    
</span></span></span></code></pre></div><p>优点：保持了类的封装性，依赖关系更清晰。</p><p>缺点：需要额外编写setter方法，增加了代码量。</p><p>一般使用的比较多的是方式1和方式2</p><p>@Autowired注解，默认是按照类型进行注入的。</p><p>如果存在多个相同类型的bean，将会报出如下错误：</p><p><img loading=lazy src=/images/Day04Web%e5%9f%ba%e7%a1%80.assets/1732255912510-236f3ec2-690e-45bb-8572-b3edc0db4e9e.png alt></p><p><strong>解决方式1：使用@Primary注解</strong></p><p><strong>注意注释的地方是在类的上边</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Primary</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@Service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>UserServiceImpl</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>UserService</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><strong>解决方式2：使用@Qualifier注解</strong></p><p>指定当前要注入的bean对象。 在@Qualifier的value属性中，指定注入的bean的名称。 @Qualifier注解不能单独使用，必须配合@Autowired使用。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@RestController</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>UserController</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Qualifier</span><span class=p>(</span><span class=s>&#34;userServiceImpl&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Autowired</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>UserService</span><span class=w> </span><span class=n>userService</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p><strong>解决方式3：使用@Resource注解</strong></p><p>是按照bean的名称进行注入。通过name属性指定要注入的bean的名称。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@RestController</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>UserController</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Resource</span><span class=p>(</span><span class=n>name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;userServiceImpl&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>UserService</span><span class=w> </span><span class=n>userService</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><h3 id=resource-与-autowired区别>@Resource 与 @Autowired区别？<a hidden class=anchor aria-hidden=true href=#resource-与-autowired区别>#</a></h3><p>• @Autowired是Spring框架提供的注解，而@Resource是JavaEE规范提供的</p><p>• @Autowired默认是按照类型注入，而@Resource默认是按照名称注入</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://wqnm1gb.github.io/tags/java-web/>Java Web</a></li></ul><nav class=paginav><a class=prev href=https://wqnm1gb.github.io/posts/day05mysql%E6%95%B0%E6%8D%AE%E5%BA%93/><span class=title>« 上一页</span><br><span>Day05 MySQL数据库</span>
</a><a class=next href=https://wqnm1gb.github.io/posts/day03web%E5%90%8E%E7%AB%AF%E5%9F%BA%E7%A1%80/><span class=title>下一页 »</span><br><span>Day03 Web后端基础</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://wqnm1gb.github.io/>三狗子的博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>