<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Day09 函数式编程、方法引用和String类 | 三狗子的博客</title>
<meta name=keywords content="java基础"><meta name=description content="函数式编程
此“函数”类似于数学中的函数（强调做什么），只要输入的数据一致返回的结果也是一致的
可以用于替代某些匿名内部类对象，从而让程序更简洁，可读性更好。"><meta name=author content="冷漠三狗子丶"><link rel=canonical href=https://wqnm1gb.github.io/posts/day09-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E5%92%8Cstring%E7%B1%BB/><link crossorigin=anonymous href=/assets/css/stylesheet.3d688279d829dc24da48acd11f9e33ebea2f39c035e899e1bf4297d8b7aa89b9.css integrity="sha256-PWiCedgp3CTaSKzRH54z6+ovOcA16Jnhv0KX2Leqibk=" rel="preload stylesheet" as=style><link rel=icon href=https://wqnm1gb.github.io/images/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://wqnm1gb.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wqnm1gb.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wqnm1gb.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://wqnm1gb.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://wqnm1gb.github.io/posts/day09-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E5%92%8Cstring%E7%B1%BB/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel=stylesheet><script type=text/javascript async src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["[[","]]"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=" has-jax"})</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style><meta property="og:title" content="Day09 函数式编程、方法引用和String类"><meta property="og:description" content="函数式编程
此“函数”类似于数学中的函数（强调做什么），只要输入的数据一致返回的结果也是一致的
可以用于替代某些匿名内部类对象，从而让程序更简洁，可读性更好。"><meta property="og:type" content="article"><meta property="og:url" content="https://wqnm1gb.github.io/posts/day09-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E5%92%8Cstring%E7%B1%BB/"><meta property="og:image" content="https://wqnm1gb.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-02-08T10:43:35+08:00"><meta property="article:modified_time" content="2025-02-08T10:43:35+08:00"><meta property="og:site_name" content="三狗子的博客"><meta property="fb:admins" content="your-facebook-admin-id"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wqnm1gb.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Day09 函数式编程、方法引用和String类","item":"https://wqnm1gb.github.io/posts/day09-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E5%92%8Cstring%E7%B1%BB/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Day09 函数式编程、方法引用和String类","name":"Day09 函数式编程、方法引用和String类","description":"函数式编程 此“函数”类似于数学中的函数（强调做什么），只要输入的数据一致返回的结果也是一致的\n可以用于替代某些匿名内部类对象，从而让程序更简洁，可读性更好。\n","keywords":["java基础"],"articleBody":"函数式编程 此“函数”类似于数学中的函数（强调做什么），只要输入的数据一致返回的结果也是一致的\n可以用于替代某些匿名内部类对象，从而让程序更简洁，可读性更好。\n(被重写方法的形参列表) -\u003e{ 被重写方法的方法体代码 } 注意：Lambda表达式只能替代函数式接口的匿名内部类！！！\n什么是函数式接口：只有一个抽象方法的接口\n@FunctionInterface 专门用来声明函数式接口\nLambda表达式的省略规则 • 作用：用于进一步简化Lambda表达式的写法。\n具体规则\n1、参数类型全部可以省略不写。\n2、如果只有一个参数，参数类型省略的同时“（）”也可以省略，但多个参数不能省略（）”\n3、如果Lambda表达式中只有一行代码，大括号可以不写，同时要省略分号“；”如果这行代码是return\n语句，也必须去掉return。\n方法引用 静态方法引用 类名::静态方法\n使用场景\n如果某个Lambda表达式里只是调用一个静态方法，并且“-\u003e”前后参数的形式一致，就可以使用静态方法引用。\nArrays.sort(students,Student::compare); 实例方法引用 对象名::实例方法。\n使用场景\n如果某个Lambda表达式里只是通过对象名称调用一个实例方法，并且“-\u003e”前后参数的形式一致，就可以\n使用实例方法引用。\n特定类的方法引用 特定类的名称：方法\n使用场景\n如果某个Lambda表达式里只是调用一个特定类型的实例方法，并且前面参数列表中的第一个参数是作为方法的主调，后面的所有参数都是作为该实例方法的入参的，则此时就可以使用特定类型的方法引用。\n构造器引用 类名::new\n使用场景\n如果某个Lambda表达式里只是在创建对象，并且“-\u003e”前后参数情况一致，就可以使用构造器引用。\nString类 String代表字符串，它的对象可以封装字符串数据，并提供了很多方法完成对字符串的处理。\n创建对线的区别\n只要是以\"..“方式写出的字符串对象，会存储到字符串常量池，且相同内容的字符串只存储一份（节约内存）；\n通过new方式创建字符串对象，每new一次都会产生一个新的对象放在堆内存中。\n字符串对象的内容比较不要用==号，==号默认比较的是地址，字符串对象的内容一样时地址不一定一样\n建议使用String提供的equals方法，只关心内容，不关心地址\nsc.next()用来接收字符串对象\nString创建字符串对象的方式 构造器 说明 public String() 创建一个空白字符串对象，不含有任何内容 public String(String original) 根据传入的字符串内容，来创建字符串对象 public String(char[] chars) 根据字符数组的内容，来创建字符串对象 public String(byte[] bytes) 根据字节数组的内容，来创建字符串对象 String提供的常用方法 方法名 说明 public int length() 获取字符串的长度返回（就是字符个数） public char charAt(int index) 获取某个索引位置处的字符返回 public char[] toCharArray()： 将当前字符串转换成字符数组返回 public boolean equals(Object anObject) 判断当前字符串与另一个字符串的内容一样，一样返回true public booleanequalsIgnoreCase(String anotherString) 判断当前字符串与另一个字符串的内容是否一样(忽略大小写) public String substring(int beginIndex, int endIndex) 根据开始和结束索引进行截取，得到新的字符串（包前不包后，索引从0开始） public String substring(int beginIndex) 从传入的索引处截取，截取到末尾，得到新的字符串返回 public String replace(CharSequence target, CharSequence replacement) 使用新值，将字符串中的旧值替换，得到新的字符串 public boolean contains(CharSequence s) 判断字符串中是否包含了某个字符串 public booleanstartsWith(String prefix) 判断字符串是否以某个字符串内容开头，开头返回true，反之 public String[] split(String regex) 把字符串按照某个字符串内容分割，并返回字符串数组回来 ","wordCount":"1366","inLanguage":"zh","image":"https://wqnm1gb.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-02-08T10:43:35+08:00","dateModified":"2025-02-08T10:43:35+08:00","author":{"@type":"Person","name":"冷漠三狗子丶"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wqnm1gb.github.io/posts/day09-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E5%92%8Cstring%E7%B1%BB/"},"publisher":{"@type":"Organization","name":"三狗子的博客","logo":{"@type":"ImageObject","url":"https://wqnm1gb.github.io/images/favicon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wqnm1gb.github.io/ accesskey=h title="主页 (Alt + H)"><img src=https://wqnm1gb.github.io/apple-touch-icon.png alt aria-label=logo height=35>主页</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wqnm1gb.github.io/ title=三狗子的博客><span>首页</span></a></li><li><a href=https://wqnm1gb.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://wqnm1gb.github.io/categories/ title=Categories><span>分类</span></a></li><li><a href=https://wqnm1gb.github.io/tags/ title=Tags><span>标签</span></a></li><li><a href=https://wqnm1gb.github.io/search/ title=搜索><span>搜索</span></a></li><li><a href=https://wqnm1gb.github.io/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://wqnm1gb.github.io/>主页</a>&nbsp;»&nbsp;<a href=https://wqnm1gb.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Day09 函数式编程、方法引用和String类</h1><div class=post-meta><span title='2025-02-08 10:43:35.797321 +0800 +0800'>二月 8, 2025</span>&nbsp;·&nbsp;3 分钟&nbsp;·&nbsp;1366 字&nbsp;·&nbsp;冷漠三狗子丶</div></header><div class=post-content><h2 id=函数式编程>函数式编程<a hidden class=anchor aria-hidden=true href=#函数式编程>#</a></h2><p>此“函数”类似于数学中的函数（强调做什么），只要输入的数据一致返回的结果也是一致的</p><p>可以用于替代某些匿名内部类对象，从而让程序更简洁，可读性更好。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=p>(</span><span class=n>被重写方法的形参列表</span><span class=p>)</span><span class=w> </span><span class=o>-&gt;</span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>被重写方法的方法体代码</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>注意：Lambda表达式只能替代函数式接口的匿名内部类！！！</p><p>什么是函数式接口：只有一个抽象方法的接口</p><p>@FunctionInterface 专门用来声明函数式接口</p><h3 id=lambda表达式的省略规则>Lambda表达式的省略规则<a hidden class=anchor aria-hidden=true href=#lambda表达式的省略规则>#</a></h3><p>• 作用：用于进一步简化Lambda表达式的写法。</p><p>具体规则</p><p>1、参数类型全部可以省略不写。</p><p>2、如果只有一个参数，参数类型省略的同时“（）”也可以省略，但多个参数不能省略（）”</p><p>3、如果Lambda表达式中只有一行代码，大括号可以不写，同时要省略分号“；”如果这行代码是return</p><p>语句，也必须去掉return。</p><h2 id=方法引用>方法引用<a hidden class=anchor aria-hidden=true href=#方法引用>#</a></h2><h3 id=静态方法引用>静态方法引用<a hidden class=anchor aria-hidden=true href=#静态方法引用>#</a></h3><p>类名::静态方法</p><p>使用场景</p><p>如果某个Lambda表达式里只是调用一个静态方法，并且“->”前后参数的形式一致，就可以使用静态方法引用。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Arrays</span><span class=p>.</span><span class=na>sort</span><span class=p>(</span><span class=n>students</span><span class=p>,</span><span class=n>Student</span><span class=p>::</span><span class=n>compare</span><span class=p>);</span><span class=w> 
</span></span></span></code></pre></div><h3 id=实例方法引用>实例方法引用<a hidden class=anchor aria-hidden=true href=#实例方法引用>#</a></h3><p>对象名::实例方法。</p><p>使用场景</p><p>如果某个Lambda表达式里只是通过对象名称调用一个实例方法，并且“->”前后参数的形式一致，就可以</p><p>使用实例方法引用。</p><h3 id=特定类的方法引用>特定类的方法引用<a hidden class=anchor aria-hidden=true href=#特定类的方法引用>#</a></h3><p>特定类的名称：方法</p><p>使用场景</p><p>如果某个Lambda表达式里只是调用一个特定类型的实例方法，并且前面参数列表中的第一个参数是作为方法的主调，后面的所有参数都是作为该实例方法的入参的，则此时就可以使用特定类型的方法引用。</p><h3 id=构造器引用>构造器引用<a hidden class=anchor aria-hidden=true href=#构造器引用>#</a></h3><p>类名::new</p><p>使用场景</p><p>如果某个Lambda表达式里只是在创建对象，并且“->”前后参数情况一致，就可以使用构造器引用。</p><h2 id=string类>String类<a hidden class=anchor aria-hidden=true href=#string类>#</a></h2><p>String代表字符串，它的对象可以封装字符串数据，并提供了很多方法完成对字符串的处理。</p><p>创建对线的区别</p><p>只要是以"..&ldquo;方式写出的字符串对象，会存储到字符串常量池，且相同内容的字符串只存储一份（节约内存）；</p><p>通过new方式创建字符串对象，每new一次都会产生一个新的对象放在堆内存中。</p><p></p><p>字符串对象的内容比较不要用==号，==号默认比较的是地址，字符串对象的内容一样时地址不一定一样</p><p>建议使用String提供的equals方法，只关心内容，不关心地址</p><p>sc.next()用来接收字符串对象</p><h3 id=string创建字符串对象的方式>String创建字符串对象的方式<a hidden class=anchor aria-hidden=true href=#string创建字符串对象的方式>#</a></h3><table><thead><tr><th>构造器</th><th>说明</th></tr></thead><tbody><tr><td>public String()</td><td>创建一个空白字符串对象，不含有任何内容</td></tr><tr><td>public String(String original)</td><td>根据传入的字符串内容，来创建字符串对象</td></tr><tr><td>public String(char[] chars)</td><td>根据字符数组的内容，来创建字符串对象</td></tr><tr><td>public String(byte[] bytes)</td><td>根据字节数组的内容，来创建字符串对象</td></tr></tbody></table><h3 id=string提供的常用方法>String提供的常用方法<a hidden class=anchor aria-hidden=true href=#string提供的常用方法>#</a></h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public int length()</td><td>获取字符串的长度返回（就是字符个数）</td></tr><tr><td>public char charAt(int index)</td><td>获取某个索引位置处的字符返回</td></tr><tr><td>public char[] toCharArray()：</td><td>将当前字符串转换成字符数组返回</td></tr><tr><td>public boolean equals(Object anObject)</td><td>判断当前字符串与另一个字符串的内容一样，一样返回true</td></tr><tr><td>public booleanequalsIgnoreCase(String anotherString)</td><td>判断当前字符串与另一个字符串的内容是否一样(忽略大小写)</td></tr><tr><td>public String substring(int beginIndex, int endIndex)</td><td>根据开始和结束索引进行截取，得到新的字符串（包前不包后，索引从0开始）</td></tr><tr><td>public String substring(int beginIndex)</td><td>从传入的索引处截取，截取到末尾，得到新的字符串返回</td></tr><tr><td>public String replace(CharSequence target, CharSequence replacement)</td><td>使用新值，将字符串中的旧值替换，得到新的字符串</td></tr><tr><td>public boolean contains(CharSequence s)</td><td>判断字符串中是否包含了某个字符串</td></tr><tr><td>public booleanstartsWith(String prefix)</td><td>判断字符串是否以某个字符串内容开头，开头返回true，反之</td></tr><tr><td>public String[] split(String regex)</td><td>把字符串按照某个字符串内容分割，并返回字符串数组回来</td></tr></tbody></table></div><footer class=post-footer><ul class=post-tags><li><a href=https://wqnm1gb.github.io/tags/java%E5%9F%BA%E7%A1%80/>Java基础</a></li></ul><nav class=paginav><a class=prev href=https://wqnm1gb.github.io/posts/day10-arraylist%E9%9B%86%E5%90%88/><span class=title>« 上一页</span><br><span>Day10 ArrayList集合</span>
</a><a class=next href=https://wqnm1gb.github.io/posts/day08-%E6%8E%A5%E5%8F%A3%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/><span class=title>下一页 »</span><br><span>Day08 接口和面向对象编程</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://wqnm1gb.github.io/>三狗子的博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>